; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\save2flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\save2flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app -I..\..\User\lcd\inc -I..\..\User\hx711 -I..\..\User\delay -I.\RTE\_Flash -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\save2flash.crf ..\..\User\app\save2flash.c]
                          THUMB

                          AREA ||i.MemReadByte||, CODE, READONLY, ALIGN=2

                  MemReadByte PROC
;;;50     ***************************************************************************************************/
;;;51     uint8_t MemReadByte(uint16_t *data,uint16_t num)                               
000000  b510              PUSH     {r4,lr}
;;;52     {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;53             uint16_t *temp_addr = (uint16_t *)EEPROM1_START_ADDR;
000006  4906              LDR      r1,|L1.32|
;;;54            
;;;55             while(num --)
000008  e003              B        |L1.18|
                  |L1.10|
;;;56             {
;;;57                     *data ++ = *temp_addr ++;
00000a  f8310b02          LDRH     r0,[r1],#2
00000e  f8220b02          STRH     r0,[r2],#2
                  |L1.18|
000012  1e18              SUBS     r0,r3,#0              ;55
000014  f1a30401          SUB      r4,r3,#1              ;55
000018  b2a3              UXTH     r3,r4                 ;55
00001a  d1f6              BNE      |L1.10|
;;;58             }
;;;59                                                                                                            
;;;60             return 1;                                                                                                       
00001c  2001              MOVS     r0,#1
;;;61     }
00001e  bd10              POP      {r4,pc}
;;;62     
                          ENDP

                  |L1.32|
                          DCD      0x08015400

                          AREA ||i.MemWriteByte||, CODE, READONLY, ALIGN=2

                  MemWriteByte PROC
;;;71     ***************************************************************************************************/
;;;72     uint8_t MemWriteByte(uint16_t *data,uint16_t num)                               
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;73     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;74             FLASH_Status temp_stat;
;;;75             uint32_t temp_addr = EEPROM1_START_ADDR;
000008  4f12              LDR      r7,|L2.84|
;;;76                    
;;;77             FLASH_Unlock();     // Flash解锁，允许操作相关的寄存器
00000a  f7fffffe          BL       FLASH_Unlock
;;;78             temp_stat = FLASH_ErasePage(EEPROM1_START_ADDR); // 擦出制定的页
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       FLASH_ErasePage
000014  4606              MOV      r6,r0
;;;79            
;;;80             if(temp_stat != FLASH_COMPLETE)
000016  2e04              CMP      r6,#4
000018  d004              BEQ      |L2.36|
;;;81             {
;;;82                     FLASH_Lock();
00001a  f7fffffe          BL       FLASH_Lock
;;;83                     return 0;
00001e  2000              MOVS     r0,#0
                  |L2.32|
;;;84             }
;;;85            
;;;86             while(num --)
;;;87             {
;;;88                     temp_stat = FLASH_ProgramHalfWord(temp_addr,*data);
;;;89                     if(temp_stat != FLASH_COMPLETE)
;;;90                     {
;;;91                             FLASH_Lock();
;;;92                             return 0;
;;;93                     }
;;;94            
;;;95                     temp_addr += 2;
;;;96                     data++;
;;;97             }
;;;98            
;;;99             FLASH_Lock();       
;;;100            return 1;
;;;101    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L2.36|
000024  e00c              B        |L2.64|
                  |L2.38|
000026  8821              LDRH     r1,[r4,#0]            ;88
000028  4638              MOV      r0,r7                 ;88
00002a  f7fffffe          BL       FLASH_ProgramHalfWord
00002e  4606              MOV      r6,r0                 ;88
000030  2e04              CMP      r6,#4                 ;89
000032  d003              BEQ      |L2.60|
000034  f7fffffe          BL       FLASH_Lock
000038  2000              MOVS     r0,#0                 ;92
00003a  e7f1              B        |L2.32|
                  |L2.60|
00003c  1cbf              ADDS     r7,r7,#2              ;95
00003e  1ca4              ADDS     r4,r4,#2              ;96
                  |L2.64|
000040  1e28              SUBS     r0,r5,#0              ;86
000042  f1a50101          SUB      r1,r5,#1              ;86
000046  b28d              UXTH     r5,r1                 ;86
000048  d1ed              BNE      |L2.38|
00004a  f7fffffe          BL       FLASH_Lock
00004e  2001              MOVS     r0,#1                 ;100
000050  e7e6              B        |L2.32|
;;;102    
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
                          DCD      0x08015400

                          AREA ||i.Msg_Read||, CODE, READONLY, ALIGN=1

                  Msg_Read PROC
;;;303    
;;;304    void Msg_Read( uint32_t ReadAddr, uint8_t * pBuffer, uint16_t NumToRead )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;305    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4690              MOV      r8,r2
;;;306    	uint16_t i;
;;;307    	uint16_t tem16;
;;;308    	uint32_t temAdd;
;;;309    	
;;;310        //uint16_t secoff;	   					//扇区内偏移地址(16位字计算)
;;;311    	uint32_t secpos;	   					//扇区地址
;;;312    	uint32_t offaddr;   					//去掉0X08000000后的地址
;;;313    	//uint8_t temp_stat;
;;;314    	
;;;315    //	if( (ReadAddr < FLASH_BASE) || ( ReadAddr >= ( FLASH_BASE + 1024 * STM32_FLASH_SIZE ) ) )
;;;316    //		return 0;											//非法地址
;;;317    	
;;;318    	FLASH_Unlock();
00000a  f7fffffe          BL       FLASH_Unlock
;;;319    	
;;;320    	offaddr = ReadAddr - FLASH_BASE;						    //实际偏移地址.
00000e  f1a46b00          SUB      r11,r4,#0x8000000
;;;321    	secpos = offaddr / STM32_SECTOR_SIZE;					    //扇区地址  0~127 for STM32F103RBT6
000012  ea4f2a9b          LSR      r10,r11,#10
;;;322    	//secoff = ( offaddr % STM32_SECTOR_SIZE ) / 2;				//在扇区内的偏移(2个字节为基本单位.)
;;;323    	
;;;324    	
;;;325    	temAdd = ReadAddr + BYTE_COMP*(secpos+1);
000016  f10a0001          ADD      r0,r10,#1
00001a  2102              MOVS     r1,#2
00001c  fb014900          MLA      r9,r1,r0,r4
;;;326    	
;;;327    	
;;;328    	for(i=0;i<NumToRead;)
000020  2600              MOVS     r6,#0
000022  e00c              B        |L3.62|
                  |L3.36|
;;;329    	{
;;;330    		
;;;331    		tem16 = *(__IO uint16_t*)temAdd;//读取2个字节.
000024  f8b97000          LDRH     r7,[r9,#0]
;;;332    		temAdd+=2;							//偏移2个字节.	
000028  f1090902          ADD      r9,r9,#2
;;;333    		
;;;334    		pBuffer[i++] = (uint8_t)tem16;
00002c  4630              MOV      r0,r6
00002e  1c71              ADDS     r1,r6,#1
000030  b28e              UXTH     r6,r1
000032  542f              STRB     r7,[r5,r0]
;;;335    		pBuffer[i++] = (uint8_t)(tem16>>8);
000034  123a              ASRS     r2,r7,#8
000036  4630              MOV      r0,r6
000038  1c71              ADDS     r1,r6,#1
00003a  b28e              UXTH     r6,r1
00003c  542a              STRB     r2,[r5,r0]
                  |L3.62|
00003e  4546              CMP      r6,r8                 ;328
000040  dbf0              BLT      |L3.36|
;;;336    	}
;;;337    }
000042  e8bd9ff0          POP      {r4-r12,pc}
;;;338    
                          ENDP


                          AREA ||i.Msg_Write||, CODE, READONLY, ALIGN=2

                  Msg_Write PROC
;;;240    **********************************************************************************************************/
;;;241    uint8_t Msg_Write( uint32_t WriteAddr, uint16_t * pBuffer, uint16_t NumToWrite )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;242    {
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4692              MOV      r10,r2
;;;243    	uint16_t secoff;	   					//扇区内偏移地址(16位字计算)
;;;244     	//uint16_t i;    
;;;245    	uint32_t secpos;	   					//扇区地址
;;;246    	uint32_t offaddr;   					//去掉0X08000000后的地址
;;;247    	uint8_t temp_stat;
;;;248    	
;;;249    	if( (WriteAddr < FLASH_BASE) || ( WriteAddr >= ( FLASH_BASE + 1024 * STM32_FLASH_SIZE ) ) )
00000a  f1b46f00          CMP      r4,#0x8000000
00000e  d302              BCC      |L4.22|
000010  4817              LDR      r0,|L4.112|
000012  4284              CMP      r4,r0
000014  d302              BCC      |L4.28|
                  |L4.22|
;;;250    		return 0;											//非法地址
000016  2000              MOVS     r0,#0
                  |L4.24|
;;;251    	
;;;252    	FLASH_Unlock();
;;;253    	
;;;254    	offaddr = WriteAddr - FLASH_BASE;						    //实际偏移地址.
;;;255    	secpos = offaddr / STM32_SECTOR_SIZE;					    //扇区地址  0~127 for STM32F103RBT6
;;;256    	secoff = ( offaddr % STM32_SECTOR_SIZE ) / 2;				//在扇区内的偏移(2个字节为基本单位.)
;;;257    	
;;;258    	//debug_usr("[ 1 ]\r\n");
;;;259    	//Msg_Read( secpos * STM32_SECTOR_SIZE + FLASH_BASE, STMFLASH_BUF, STM32_SECTOR_SIZE / 2);//读出整个扇区的内容
;;;260    	
;;;261    	if(!secoff)
;;;262    	{
;;;263    		temp_stat = FLASH_ErasePage(secpos * STM32_SECTOR_SIZE + FLASH_BASE);
;;;264    	
;;;265    		if(temp_stat != FLASH_COMPLETE)
;;;266    		{
;;;267    				FLASH_Lock();
;;;268    				return 0;
;;;269    		}
;;;270    	}
;;;271    
;;;272    	/*for(i=0;i < NumToWrite;i++)//复制
;;;273    	{
;;;274    		STMFLASH_BUF[i+secoff]=pBuffer[i];	  
;;;275    	}*/
;;;276    	/*
;;;277    	while( !Msg_WriteNoCheck(WriteAddr, pBuffer, NumToWrite) )
;;;278    	{
;;;279    		uint8 i = 10;
;;;280    		Msg_Read( secpos * STM32_SECTOR_SIZE + FLASH_BASE, STMFLASH_BUF, STM32_SECTOR_SIZE / 2);
;;;281    		while( (FLASH_ErasePage(secpos * STM32_SECTOR_SIZE + FLASH_BASE) != FLASH_COMPLETE) && (i--) );
;;;282    		for(i=0;i < NumToWrite;i++)//复制
;;;283    		{
;;;284    			STMFLASH_BUF[i+secoff]=pBuffer[i];	  
;;;285    		}
;;;286    		
;;;287    	}
;;;288    	*/
;;;289    	//temp_stat = Msg_WriteNoCheck(WriteAddr, pBuffer, NumToWrite);
;;;290    	temp_stat = Msg_WriteNoCheck(WriteAddr+BYTE_COMP*(secpos+1), pBuffer, NumToWrite); //每次写入偏移n字节以页对齐
;;;291    	//temp_stat = Msg_WriteNoCheck(secpos * STM32_SECTOR_SIZE + FLASH_BASE, STMFLASH_BUF, (secoff+NumToWrite));//写已经擦除了的,直接写入扇区剩余区间. 				   
;;;292    
;;;293    	if(temp_stat != 1)	//写失败，此地址已经有数据
;;;294    	{
;;;295    		FLASH_Lock();
;;;296    		return 0;
;;;297    	}
;;;298    
;;;299    	FLASH_Lock();
;;;300    
;;;301    	return 1;
;;;302    }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L4.28|
00001c  f7fffffe          BL       FLASH_Unlock
000020  f1a46700          SUB      r7,r4,#0x8000000      ;254
000024  0abd              LSRS     r5,r7,#10             ;255
000026  f3c70848          UBFX     r8,r7,#1,#9           ;256
00002a  f1b80f00          CMP      r8,#0                 ;261
00002e  d10c              BNE      |L4.74|
000030  f04f6100          MOV      r1,#0x8000000         ;263
000034  eb012085          ADD      r0,r1,r5,LSL #10      ;263
000038  f7fffffe          BL       FLASH_ErasePage
00003c  4606              MOV      r6,r0                 ;263
00003e  2e04              CMP      r6,#4                 ;265
000040  d003              BEQ      |L4.74|
000042  f7fffffe          BL       FLASH_Lock
000046  2000              MOVS     r0,#0                 ;268
000048  e7e6              B        |L4.24|
                  |L4.74|
00004a  1c69              ADDS     r1,r5,#1              ;290
00004c  2202              MOVS     r2,#2                 ;290
00004e  fb024001          MLA      r0,r2,r1,r4           ;290
000052  4652              MOV      r2,r10                ;290
000054  4649              MOV      r1,r9                 ;290
000056  f7fffffe          BL       Msg_WriteNoCheck
00005a  4606              MOV      r6,r0                 ;290
00005c  2e01              CMP      r6,#1                 ;293
00005e  d003              BEQ      |L4.104|
000060  f7fffffe          BL       FLASH_Lock
000064  2000              MOVS     r0,#0                 ;296
000066  e7d7              B        |L4.24|
                  |L4.104|
000068  f7fffffe          BL       FLASH_Lock
00006c  2001              MOVS     r0,#1                 ;301
00006e  e7d3              B        |L4.24|
;;;303    
                          ENDP

                  |L4.112|
                          DCD      0x08020000

                          AREA ||i.Msg_WriteNoCheck||, CODE, READONLY, ALIGN=2

                  Msg_WriteNoCheck PROC
;;;351    **********************************************************************************************************/
;;;352    uint8_t Msg_WriteNoCheck ( uint32_t WriteAddr, uint16_t * pBuffer, uint16_t NumToWrite )   
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;353    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;354    	uint16_t i;
;;;355    	FLASH_Status status;
;;;356    	
;;;357    	for(i=0;i<NumToWrite;i++)
00000a  2400              MOVS     r4,#0
00000c  e010              B        |L5.48|
                  |L5.14|
;;;358    	{
;;;359    		status = FLASH_ProgramHalfWord( WriteAddr, pBuffer[i]);
00000e  f8371014          LDRH     r1,[r7,r4,LSL #1]
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       FLASH_ProgramHalfWord
000018  4605              MOV      r5,r0
;;;360    		if(status != FLASH_COMPLETE)
00001a  2d04              CMP      r5,#4
00001c  d005              BEQ      |L5.42|
;;;361    		{
;;;362    						debug_usr("[ SAVE ERROR ]\r\n");
00001e  a006              ADR      r0,|L5.56|
000020  f7fffffe          BL       debug_usr
;;;363    						return 0;
000024  2000              MOVS     r0,#0
                  |L5.38|
;;;364    		}
;;;365    	  WriteAddr+=2;
;;;366    	}
;;;367    	return 1;
;;;368    } 
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L5.42|
00002a  1cb6              ADDS     r6,r6,#2              ;365
00002c  1c60              ADDS     r0,r4,#1              ;357
00002e  b284              UXTH     r4,r0                 ;357
                  |L5.48|
000030  4544              CMP      r4,r8                 ;357
000032  dbec              BLT      |L5.14|
000034  2001              MOVS     r0,#1                 ;367
000036  e7f6              B        |L5.38|
;;;369    
                          ENDP

                  |L5.56|
000038  5b205341          DCB      "[ SAVE ERROR ]\r\n",0
00003c  56452045
000040  52524f52
000044  205d0d0a
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.ReadFromFlash||, CODE, READONLY, ALIGN=2

                  ReadFromFlash PROC
;;;111    
;;;112    uint8_t ReadFromFlash( void )
000000  b500              PUSH     {lr}
;;;113    {
;;;114    //	uint8_t i;
;;;115    	
;;;116        MemReadByte( data_saved.buf, FLASH_DATA_SIZE );
000002  2128              MOVS     r1,#0x28
000004  4802              LDR      r0,|L6.16|
000006  f7fffffe          BL       MemReadByte
;;;117        
;;;118    //    if( data_saved.data.lg.bit.v_init == 1 )
;;;119    //    {
;;;120    //        data_saved.data.lg.bit.v_init = 0;
;;;121    //        data_saved.data.max_room_n = MAX_ROOM_N;
;;;122    //        data_saved.data.TrainNum[0] = TRAIN_NUM_H;
;;;123    //        data_saved.data.TrainNum[1] = TRAIN_NUM_L;
;;;124    //        data_saved.data.dly_move = DLY_MOVE;
;;;125    //        data_saved.data.dly_stop = DLY_STOP;
;;;126    //        data_saved.data.TrainType = TRAIN_TPYE;
;;;127    //        SaveToFlash( );
;;;128    //    }
;;;129    //    
;;;130    //    Train.TrainType = data_saved.data.TrainType;
;;;131    //    
;;;132    //    for( i=0; i<2; i++ )
;;;133    //    {
;;;134    //        Train.TrainNum[i] = data_saved.data.TrainNum[i];
;;;135    //    }
;;;136    //    
;;;137    //    Train.max_room_n = data_saved.data.max_room_n;
;;;138    //    
;;;139    //    if( Train.max_room_n > MAX_ROOM_N )
;;;140    //    {
;;;141    //        Train.max_room_n = MAX_ROOM_N;
;;;142    //    }
;;;143    //    
;;;144        return 1;
00000a  2001              MOVS     r0,#1
;;;145    }
00000c  bd00              POP      {pc}
;;;146    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      data_saved

                          AREA ||i.ReadMsgToRam||, CODE, READONLY, ALIGN=2

                  ReadMsgToRam PROC
;;;185    
;;;186    uint8_t ReadMsgToRam( uint8_t *data, uint8_t len )
000000  b570              PUSH     {r4-r6,lr}
;;;187    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;188    	__disable_irq();
000006  b672              CPSID    i
;;;189    	
;;;190    	//20181219加入，简化算法，只要大于写入的指针，就都清零，防止读指针指向非法数据
;;;191    	if( MsgSaveAddr.read_addr_offset >= MsgSaveAddr.write_addr_offset )
000008  481d              LDR      r0,|L7.128|
00000a  8840              LDRH     r0,[r0,#2]  ; MsgSaveAddr
00000c  491c              LDR      r1,|L7.128|
00000e  8809              LDRH     r1,[r1,#0]  ; MsgSaveAddr
000010  4288              CMP      r0,r1
000012  db0a              BLT      |L7.42|
;;;192    	{
;;;193    	    MsgSaveAddr.read_addr_offset = 0;
000014  2000              MOVS     r0,#0
000016  491a              LDR      r1,|L7.128|
000018  8048              STRH     r0,[r1,#2]
;;;194    	    MsgSaveAddr.write_addr_offset = 0;
00001a  8008              STRH     r0,[r1,#0]
;;;195    	    
;;;196    	    Bkd.read_addr_offset = 0;
00001c  4919              LDR      r1,|L7.132|
00001e  8048              STRH     r0,[r1,#2]
;;;197    	    Bkd.write_addr_offset = 0;
000020  8008              STRH     r0,[r1,#0]
;;;198    	    bkd_save();
000022  f7fffffe          BL       bkd_save
;;;199    	    
;;;200    	    return 0;
000026  2000              MOVS     r0,#0
                  |L7.40|
;;;201    	}
;;;202    	
;;;203    	if( MsgSaveAddr.read_addr_offset >= EEPROM3_MAX_ADDR_OFFSET )
;;;204    	{
;;;205    		MsgSaveAddr.read_addr_offset = 0;
;;;206    		//data_saved.data.write_addr_offset = MsgSaveAddr.write_addr_offset;
;;;207    		//data_saved.data.read_addr_offset 
;;;208    		Bkd.read_addr_offset = MsgSaveAddr.read_addr_offset;
;;;209    		bkd_save();
;;;210    		
;;;211    		return 0;
;;;212    	}
;;;213    	
;;;214    	FLASH_Unlock();
;;;215    	
;;;216    	Msg_Read( EEPROM3_START_ADDR + MsgSaveAddr.read_addr_offset, data, len);//读出整个扇区的内容
;;;217    	
;;;218    	FLASH_Lock();
;;;219    	MsgSaveAddr.read_addr_offset += len;
;;;220    	//data_saved.data.write_addr_offset = MsgSaveAddr.write_addr_offset;
;;;221    	//data_saved.data.read_addr_offset 
;;;222    	Bkd.read_addr_offset = MsgSaveAddr.read_addr_offset;
;;;223    	bkd_save();
;;;224    	
;;;225    	__enable_irq();
;;;226    	
;;;227    	return len;
;;;228    }
000028  bd70              POP      {r4-r6,pc}
                  |L7.42|
00002a  4815              LDR      r0,|L7.128|
00002c  8840              LDRH     r0,[r0,#2]            ;203  ; MsgSaveAddr
00002e  f5b04f20          CMP      r0,#0xa000            ;203
000032  db0a              BLT      |L7.74|
000034  2000              MOVS     r0,#0                 ;205
000036  4912              LDR      r1,|L7.128|
000038  8048              STRH     r0,[r1,#2]            ;205
00003a  4608              MOV      r0,r1                 ;208
00003c  8840              LDRH     r0,[r0,#2]            ;208  ; MsgSaveAddr
00003e  4911              LDR      r1,|L7.132|
000040  8048              STRH     r0,[r1,#2]            ;208
000042  f7fffffe          BL       bkd_save
000046  2000              MOVS     r0,#0                 ;211
000048  e7ee              B        |L7.40|
                  |L7.74|
00004a  f7fffffe          BL       FLASH_Unlock
00004e  490c              LDR      r1,|L7.128|
000050  8849              LDRH     r1,[r1,#2]            ;216  ; MsgSaveAddr
000052  4a0d              LDR      r2,|L7.136|
000054  1888              ADDS     r0,r1,r2              ;216
000056  4622              MOV      r2,r4                 ;216
000058  4629              MOV      r1,r5                 ;216
00005a  f7fffffe          BL       Msg_Read
00005e  f7fffffe          BL       FLASH_Lock
000062  4807              LDR      r0,|L7.128|
000064  8840              LDRH     r0,[r0,#2]            ;219  ; MsgSaveAddr
000066  4420              ADD      r0,r0,r4              ;219
000068  4905              LDR      r1,|L7.128|
00006a  8048              STRH     r0,[r1,#2]            ;219
00006c  4608              MOV      r0,r1                 ;222
00006e  8840              LDRH     r0,[r0,#2]            ;222  ; MsgSaveAddr
000070  4904              LDR      r1,|L7.132|
000072  8048              STRH     r0,[r1,#2]            ;222
000074  f7fffffe          BL       bkd_save
000078  b662              CPSIE    i                     ;225
00007a  4620              MOV      r0,r4                 ;227
00007c  e7d4              B        |L7.40|
;;;229    
                          ENDP

00007e  0000              DCW      0x0000
                  |L7.128|
                          DCD      MsgSaveAddr
                  |L7.132|
                          DCD      Bkd
                  |L7.136|
                          DCD      0x08016000

                          AREA ||i.SaveMsgToFlash||, CODE, READONLY, ALIGN=2

                  SaveMsgToFlash PROC
;;;146    
;;;147    uint8_t SaveMsgToFlash( uint8_t *data, uint8_t len )
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;148    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;149    	uint8_t i;
;;;150    	uint8_t msgbuf[16];
;;;151    	uint8_t tmp_state;
;;;152    	uint32_t temp_addr = EEPROM3_START_ADDR + MsgSaveAddr.write_addr_offset;
000008  481d              LDR      r0,|L8.128|
00000a  8800              LDRH     r0,[r0,#0]  ; MsgSaveAddr
00000c  491d              LDR      r1,|L8.132|
00000e  eb000801          ADD      r8,r0,r1
;;;153    	
;;;154    	if( MsgSaveAddr.write_addr_offset >= EEPROM3_MAX_ADDR_OFFSET )
000012  481b              LDR      r0,|L8.128|
000014  8800              LDRH     r0,[r0,#0]  ; MsgSaveAddr
000016  f5b04f20          CMP      r0,#0xa000
00001a  db09              BLT      |L8.48|
;;;155    	{
;;;156    		temp_addr = EEPROM3_START_ADDR;
00001c  4688              MOV      r8,r1
;;;157    		MsgSaveAddr.write_addr_offset = 0;
00001e  2000              MOVS     r0,#0
000020  4917              LDR      r1,|L8.128|
000022  8008              STRH     r0,[r1,#0]
;;;158    		Bkd.write_addr_offset = MsgSaveAddr.write_addr_offset;
000024  4608              MOV      r0,r1
000026  8800              LDRH     r0,[r0,#0]  ; MsgSaveAddr
000028  4917              LDR      r1,|L8.136|
00002a  8008              STRH     r0,[r1,#0]
;;;159    		bkd_save();
00002c  f7fffffe          BL       bkd_save
                  |L8.48|
;;;160    	}
;;;161    	
;;;162    	for(i=0; i<len; i++)
000030  2500              MOVS     r5,#0
000032  e004              B        |L8.62|
                  |L8.52|
;;;163    	{
;;;164    	    msgbuf[i] = *(data+i);
000034  5d78              LDRB     r0,[r7,r5]
000036  f80d0005          STRB     r0,[sp,r5]
00003a  1c68              ADDS     r0,r5,#1              ;162
00003c  b2c5              UXTB     r5,r0                 ;162
                  |L8.62|
00003e  42a5              CMP      r5,r4                 ;162
000040  dbf8              BLT      |L8.52|
;;;165    	}
;;;166    	
;;;167    	__disable_irq();
000042  b672              CPSID    i
;;;168    	
;;;169    	tmp_state = Msg_Write( temp_addr, (uint16_t *)msgbuf, len/2);
000044  46a1              MOV      r9,r4
000046  eb0470d9          ADD      r0,r4,r9,LSR #31
00004a  f3c0024f          UBFX     r2,r0,#1,#16
00004e  4669              MOV      r1,sp
000050  4640              MOV      r0,r8
000052  f7fffffe          BL       Msg_Write
000056  4606              MOV      r6,r0
;;;170    	
;;;171    	__enable_irq();
000058  b662              CPSIE    i
;;;172    	
;;;173    	if( tmp_state == 0 )
00005a  b916              CBNZ     r6,|L8.98|
;;;174    	{
;;;175    		debug_usr("[ Generate Msg Error ]\r\n");
00005c  a00b              ADR      r0,|L8.140|
00005e  f7fffffe          BL       debug_usr
                  |L8.98|
;;;176    	}
;;;177    
;;;178    		MsgSaveAddr.write_addr_offset += len;
000062  4807              LDR      r0,|L8.128|
000064  8800              LDRH     r0,[r0,#0]  ; MsgSaveAddr
000066  4420              ADD      r0,r0,r4
000068  4905              LDR      r1,|L8.128|
00006a  8008              STRH     r0,[r1,#0]
;;;179    		Bkd.write_addr_offset = MsgSaveAddr.write_addr_offset;
00006c  4608              MOV      r0,r1
00006e  8800              LDRH     r0,[r0,#0]  ; MsgSaveAddr
000070  4905              LDR      r1,|L8.136|
000072  8008              STRH     r0,[r1,#0]
;;;180    		bkd_save();
000074  f7fffffe          BL       bkd_save
;;;181    		
;;;182    	return 1;
000078  2001              MOVS     r0,#1
;;;183    }
00007a  b004              ADD      sp,sp,#0x10
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;184    
                          ENDP

                  |L8.128|
                          DCD      MsgSaveAddr
                  |L8.132|
                          DCD      0x08016000
                  |L8.136|
                          DCD      Bkd
                  |L8.140|
00008c  5b204765          DCB      "[ Generate Msg Error ]\r\n",0
000090  6e657261
000094  7465204d
000098  73672045
00009c  72726f72
0000a0  205d0d0a
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0

                          AREA ||i.SaveToFlash||, CODE, READONLY, ALIGN=2

                  SaveToFlash PROC
;;;102    
;;;103    void SaveToFlash( void )
000000  b510              PUSH     {r4,lr}
;;;104    {
;;;105        //DISABLE_INT();
;;;106    			
;;;107        MemWriteByte( data_saved.buf, FLASH_DATA_SIZE );
000002  2128              MOVS     r1,#0x28
000004  4801              LDR      r0,|L9.12|
000006  f7fffffe          BL       MemWriteByte
;;;108        
;;;109        //ENABLE_INT();
;;;110    }
00000a  bd10              POP      {r4,pc}
;;;111    
                          ENDP

                  |L9.12|
                          DCD      data_saved

                          AREA ||i.bkd_read||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  bkd_read PROC
;;;390    
;;;391    uint8_t bkd_read( void )
000000  b510              PUSH     {r4,lr}
;;;392    {
;;;393        EE_ReadVariable( EEPROM2_W_OFFSET, &Bkd.write_addr_offset );
000002  4908              LDR      r1,|L10.36|
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       EE_ReadVariable
;;;394        EE_ReadVariable( EEPROM2_R_OFFSET, &Bkd.read_addr_offset );
00000a  4906              LDR      r1,|L10.36|
00000c  1c89              ADDS     r1,r1,#2
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       EE_ReadVariable
;;;395        
;;;396        printf("offset: %02X %02X\r\n", Bkd.write_addr_offset, Bkd.read_addr_offset);
000014  4803              LDR      r0,|L10.36|
000016  8842              LDRH     r2,[r0,#2]  ; Bkd
000018  8801              LDRH     r1,[r0,#0]  ; Bkd
00001a  a003              ADR      r0,|L10.40|
00001c  f7fffffe          BL       __2printf
;;;397        
;;;398        return 1;
000020  2001              MOVS     r0,#1
;;;399    }
000022  bd10              POP      {r4,pc}
;;;400    
                          ENDP

                  |L10.36|
                          DCD      Bkd
                  |L10.40|
000028  6f666673          DCB      "offset: %02X %02X\r\n",0
00002c  65743a20
000030  25303258
000034  20253032
000038  580d0a00

                          AREA ||i.bkd_save||, CODE, READONLY, ALIGN=2

                  bkd_save PROC
;;;379    
;;;380    uint8_t bkd_save( void )
000000  b510              PUSH     {r4,lr}
;;;381    {
;;;382        //Bkd.write_addr_offset = 0x55;
;;;383        //Bkd.read_addr_offset  = 0xAA;
;;;384        
;;;385        EE_WriteVariable( EEPROM2_W_OFFSET, Bkd.write_addr_offset );
000002  4806              LDR      r0,|L11.28|
000004  8801              LDRH     r1,[r0,#0]  ; Bkd
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       EE_WriteVariable
;;;386        EE_WriteVariable( EEPROM2_R_OFFSET, Bkd.read_addr_offset );
00000c  4803              LDR      r0,|L11.28|
00000e  8841              LDRH     r1,[r0,#2]  ; Bkd
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       EE_WriteVariable
;;;387        
;;;388        return 1;
000016  2001              MOVS     r0,#1
;;;389    }
000018  bd10              POP      {r4,pc}
;;;390    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      Bkd

                          AREA ||i.msg_get_num||, CODE, READONLY, ALIGN=2

                  msg_get_num PROC
;;;370    
;;;371    uint16_t msg_get_num( void )
000000  4903              LDR      r1,|L12.16|
;;;372    {
;;;373    	uint16_t tem16;
;;;374    	
;;;375    	tem16 = MsgSaveAddr.write_addr_offset - MsgSaveAddr.read_addr_offset;
000002  8809              LDRH     r1,[r1,#0]  ; MsgSaveAddr
000004  4a02              LDR      r2,|L12.16|
000006  8852              LDRH     r2,[r2,#2]  ; MsgSaveAddr
000008  1a89              SUBS     r1,r1,r2
00000a  b288              UXTH     r0,r1
;;;376    	
;;;377    	return tem16;
;;;378    }
00000c  4770              BX       lr
;;;379    
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      MsgSaveAddr

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  BLE_TxBuf
                          %        100
                  BLE_RxBuf
                          %        100
                  data_saved
                          %        80

                          AREA ||.data||, DATA, ALIGN=1

                  Bkd
                          DCDU     0x00000000
                  MsgSaveAddr
                          DCDU     0x00000000
                  VirtAddVarTab
000008  00000001          DCW      0x0000,0x0001

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\save2flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_save2flash_c_a3e1e66a____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_save2flash_c_a3e1e66a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_save2flash_c_a3e1e66a____REVSH|
#line 128
|__asm___12_save2flash_c_a3e1e66a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
