; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_ble.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_ble.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app -I..\..\User\lcd\inc -I..\..\User\hx711 -I..\..\User\delay -I.\RTE\_Flash -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=525 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_ble.crf ..\..\User\bsp\src\bsp_ble.c]
                          THUMB

                          AREA ||i.BLE_CheckState||, CODE, READONLY, ALIGN=2

                  BLE_CheckState PROC
;;;30     
;;;31     void BLE_CheckState( void )
000000  b510              PUSH     {r4,lr}
;;;32     {
;;;33         //uint16_t tem16;
;;;34         
;;;35         if( GPIO_ReadInputData( GPIO_PORT_BLE_LINK ) & GPIO_PIN_BLE_LINK )
000002  480a              LDR      r0,|L1.44|
000004  f7fffffe          BL       GPIO_ReadInputData
000008  f4004000          AND      r0,r0,#0x8000
00000c  b138              CBZ      r0,|L1.30|
;;;36         {
;;;37             Ble.state.bit.link = 1;
00000e  4808              LDR      r0,|L1.48|
000010  7800              LDRB     r0,[r0,#0]  ; Ble
000012  f0200001          BIC      r0,r0,#1
000016  1c40              ADDS     r0,r0,#1
000018  4905              LDR      r1,|L1.48|
00001a  7008              STRB     r0,[r1,#0]
00001c  e005              B        |L1.42|
                  |L1.30|
;;;38         }else
;;;39         {
;;;40             Ble.state.bit.link = 0;
00001e  4804              LDR      r0,|L1.48|
000020  7800              LDRB     r0,[r0,#0]  ; Ble
000022  f0200001          BIC      r0,r0,#1
000026  4902              LDR      r1,|L1.48|
000028  7008              STRB     r0,[r1,#0]
                  |L1.42|
;;;41         }
;;;42     
;;;43     }
00002a  bd10              POP      {r4,pc}
;;;44     void ble_get_token( uint8_t *number )
                          ENDP

                  |L1.44|
                          DCD      0x40010800
                  |L1.48|
                          DCD      Ble

                          AREA ||i.BLE_GetMsg||, CODE, READONLY, ALIGN=2

                  BLE_GetMsg PROC
;;;488    
;;;489    uint8_t BLE_GetMsg( uint8_t *msg, uint16_t len )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;490    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;491        uint8_t i=0, err=0, err_n=0, tem8=0;
000008  2400              MOVS     r4,#0
00000a  46a0              MOV      r8,r4
00000c  2700              MOVS     r7,#0
00000e  2000              MOVS     r0,#0
000010  9000              STR      r0,[sp,#0]
;;;492        
;;;493        if( comGetLen( BLE_COM ) > 5 ) //收接收数据
000012  2003              MOVS     r0,#3
000014  f7fffffe          BL       comGetLen
000018  2805              CMP      r0,#5
00001a  dd1b              BLE      |L2.84|
;;;494        {
;;;495            while( ( err_n<2 ) && ( i<len ) )
00001c  e016              B        |L2.76|
                  |L2.30|
;;;496            {
;;;497                err = comGetChar(BLE_COM, &tem8);
00001e  4669              MOV      r1,sp
000020  2003              MOVS     r0,#3
000022  f7fffffe          BL       comGetChar
000026  4680              MOV      r8,r0
;;;498                if( err ) //有数据
000028  f1b80f00          CMP      r8,#0
00002c  d009              BEQ      |L2.66|
;;;499                {
;;;500                    *( msg + i++ ) = tem8;
00002e  f89d2000          LDRB     r2,[sp,#0]
000032  4620              MOV      r0,r4
000034  1c61              ADDS     r1,r4,#1
000036  b2cc              UXTB     r4,r1
000038  542a              STRB     r2,[r5,r0]
;;;501                    Ble.timer_ble_nodata = BLE_TIME_NODATA; 
00003a  201e              MOVS     r0,#0x1e
00003c  4907              LDR      r1,|L2.92|
00003e  7748              STRB     r0,[r1,#0x1d]
000040  e004              B        |L2.76|
                  |L2.66|
;;;502                }else //无数据等待500ms
;;;503                {
;;;504                    err_n++;
000042  1c78              ADDS     r0,r7,#1
000044  b2c7              UXTB     r7,r0
;;;505                    vTaskDelay(pdMS_TO_TICKS(100));
000046  2064              MOVS     r0,#0x64
000048  f7fffffe          BL       vTaskDelay
                  |L2.76|
00004c  2f02              CMP      r7,#2                 ;495
00004e  da01              BGE      |L2.84|
000050  42b4              CMP      r4,r6                 ;495
000052  dbe4              BLT      |L2.30|
                  |L2.84|
;;;506                }
;;;507            }
;;;508        }
;;;509        
;;;510        //解密
;;;511        
;;;512        return i;
000054  4620              MOV      r0,r4
;;;513    }
000056  e8bd83f8          POP      {r3-r9,pc}
;;;514    
                          ENDP

00005a  0000              DCW      0x0000
                  |L2.92|
                          DCD      Ble

                          AREA ||i.BLE_GetSendMsg||, CODE, READONLY, ALIGN=1

                  BLE_GetSendMsg PROC
;;;603    
;;;604    uint8_t BLE_GetSendMsg( uint8_t *msg, uint16_t cmd )
000000  4602              MOV      r2,r0
;;;605    {
;;;606        //uint8_t i=0, err=0, err_n=0, tem8=0;
;;;607        switch( cmd )
000002  f2a14001          SUB      r0,r1,#0x401
000006  b118              CBZ      r0,|L3.16|
000008  f5b07f00          CMP      r0,#0x200
00000c  d101              BNE      |L3.18|
;;;608        {
;;;609            case BLE_GET_TOKEN : //获取令牌
;;;610                
;;;611                break;
00000e  e001              B        |L3.20|
                  |L3.16|
;;;612            case BLE_SET_NAME : //修改名称
;;;613                break;
000010  e000              B        |L3.20|
                  |L3.18|
;;;614            default : break;    
000012  bf00              NOP      
                  |L3.20|
000014  bf00              NOP                            ;611
;;;615        }
;;;616        return 0;
000016  2000              MOVS     r0,#0
;;;617    }
000018  4770              BX       lr
;;;618    
                          ENDP


                          AREA ||i.BLE_HwReset||, CODE, READONLY, ALIGN=2

                  BLE_HwReset PROC
;;;106    */
;;;107    void BLE_HwReset(void)
000000  b510              PUSH     {r4,lr}
;;;108    {
;;;109        debug_ble("Ble reset!\r\n");
000002  a008              ADR      r0,|L4.36|
000004  f7fffffe          BL       debug_ble
;;;110        
;;;111        GPIO_PORT_BLE_RESET->BRR = GPIO_PIN_BLE_RESET;//拉低2S
000008  2040              MOVS     r0,#0x40
00000a  490a              LDR      r1,|L4.52|
00000c  6008              STR      r0,[r1,#0]
;;;112        vTaskDelay(pdMS_TO_TICKS(100));
00000e  2064              MOVS     r0,#0x64
000010  f7fffffe          BL       vTaskDelay
;;;113        GPIO_PORT_BLE_RESET->BSRR = GPIO_PIN_BLE_RESET;//再拉高
000014  2040              MOVS     r0,#0x40
000016  4907              LDR      r1,|L4.52|
000018  1f09              SUBS     r1,r1,#4
00001a  6008              STR      r0,[r1,#0]
;;;114        vTaskDelay(pdMS_TO_TICKS(100));
00001c  2064              MOVS     r0,#0x64
00001e  f7fffffe          BL       vTaskDelay
;;;115    }
000022  bd10              POP      {r4,pc}
;;;116    
                          ENDP

                  |L4.36|
000024  426c6520          DCB      "Ble reset!\r\n",0
000028  72657365
00002c  74210d0a
000030  00      
000031  00                DCB      0
000032  00                DCB      0
000033  00                DCB      0
                  |L4.52|
                          DCD      0x40010c14

                          AREA ||i.BLE_Init||, CODE, READONLY, ALIGN=1

                  BLE_Init PROC
;;;439    */
;;;440    void BLE_Init(void)
000000  b510              PUSH     {r4,lr}
;;;441    {
;;;442        BLE_IoInit();
000002  f7fffffe          BL       BLE_IoInit
;;;443        BLE_VarInit();
000006  f7fffffe          BL       BLE_VarInit
;;;444    }
00000a  bd10              POP      {r4,pc}
;;;445    
                          ENDP


                          AREA ||i.BLE_IoInit||, CODE, READONLY, ALIGN=2

                  BLE_IoInit PROC
;;;72     }
;;;73     void BLE_IoInit(void)
000000  b508              PUSH     {r3,lr}
;;;74     {
;;;75         GPIO_InitTypeDef GPIO_InitStructure;
;;;76     
;;;77         RCC_APB2PeriphClockCmd(RCC_ALL_BLE, ENABLE);
000002  2101              MOVS     r1,#1
000004  200c              MOVS     r0,#0xc
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;78     	
;;;79     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;80     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出模式
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;81         
;;;82         GPIO_InitStructure.GPIO_Pin = GPIO_PIN_BLE_WAKE;
000016  2080              MOVS     r0,#0x80
000018  f8ad0000          STRH     r0,[sp,#0]
;;;83         GPIO_Init(GPIO_PORT_BLE_WAKE, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  480f              LDR      r0,|L6.92|
000020  f7fffffe          BL       GPIO_Init
;;;84           
;;;85         GPIO_InitStructure.GPIO_Pin = GPIO_PIN_BLE_RESET;
000024  2040              MOVS     r0,#0x40
000026  f8ad0000          STRH     r0,[sp,#0]
;;;86         GPIO_Init(GPIO_PORT_BLE_RESET, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  480b              LDR      r0,|L6.92|
00002e  f7fffffe          BL       GPIO_Init
;;;87         
;;;88     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;// 输入模式
000032  2048              MOVS     r0,#0x48
000034  f88d0003          STRB     r0,[sp,#3]
;;;89         GPIO_InitStructure.GPIO_Pin = GPIO_PIN_BLE_LINK;
000038  f44f4000          MOV      r0,#0x8000
00003c  f8ad0000          STRH     r0,[sp,#0]
;;;90         GPIO_Init(GPIO_PORT_BLE_LINK, &GPIO_InitStructure);
000040  4669              MOV      r1,sp
000042  4807              LDR      r0,|L6.96|
000044  f7fffffe          BL       GPIO_Init
;;;91         
;;;92         //拉高reset和wake
;;;93         GPIO_SetBits(GPIO_PORT_BLE_WAKE, GPIO_PIN_BLE_WAKE);
000048  2180              MOVS     r1,#0x80
00004a  4804              LDR      r0,|L6.92|
00004c  f7fffffe          BL       GPIO_SetBits
;;;94         GPIO_SetBits(GPIO_PORT_BLE_RESET, GPIO_PIN_BLE_RESET);
000050  2140              MOVS     r1,#0x40
000052  4802              LDR      r0,|L6.92|
000054  f7fffffe          BL       GPIO_SetBits
;;;95         
;;;96     }
000058  bd08              POP      {r3,pc}
;;;97     
                          ENDP

00005a  0000              DCW      0x0000
                  |L6.92|
                          DCD      0x40010c00
                  |L6.96|
                          DCD      0x40010800

                          AREA ||i.BLE_PapaInit||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  BLE_PapaInit PROC
;;;323    
;;;324    uint8_t BLE_PapaInit( void )
000000  b53e              PUSH     {r1-r5,lr}
;;;325    {
;;;326        uint8_t i, err;
;;;327        char TEM[ 10 ];
;;;328        i=0;
000002  2500              MOVS     r5,#0
;;;329        //WH-BLE103 V1.0.7
;;;330        while( 1 )
000004  e080              B        |L7.264|
                  |L7.6|
;;;331        {
;;;332            vTaskDelay( 1 );
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       vTaskDelay
;;;333    //        SoftWdtFed( vTaskOtg_ID );
;;;334            
;;;335            switch( i )
00000c  2d09              CMP      r5,#9
00000e  d26f              BCS      |L7.240|
000010  e8dff005          TBB      [pc,r5]
000014  05111a2a          DCB      0x05,0x11,0x1a,0x2a
000018  35404b55          DCB      0x35,0x40,0x4b,0x55
00001c  6200              DCB      0x62,0x00
;;;336            {
;;;337                case 0 ://
;;;338                    err = ble_cmd("+++a","a+ok", 500 );
00001e  f44f72fa          MOV      r2,#0x1f4
000022  a13a              ADR      r1,|L7.268|
000024  a03b              ADR      r0,|L7.276|
000026  f7fffffe          BL       ble_cmd
00002a  4604              MOV      r4,r0
;;;339                    if( err )
00002c  b10c              CBZ      r4,|L7.50|
;;;340                    {
;;;341                        i = 2;
00002e  2502              MOVS     r5,#2
000030  e000              B        |L7.52|
                  |L7.50|
;;;342                    }else
;;;343                    {
;;;344                        i = 1;
000032  2501              MOVS     r5,#1
                  |L7.52|
;;;345                    }
;;;346                    break;
000034  e062              B        |L7.252|
;;;347                 case 1 ://
;;;348                    err = ble_cmd("AT+ENTM\r\n","+ENTM:OK", 500 );//err = ble_cmd("AT+PASS?\r\n","+PASS:", 500 ); //JC-G6201
000036  f44f72fa          MOV      r2,#0x1f4
00003a  a138              ADR      r1,|L7.284|
00003c  a03a              ADR      r0,|L7.296|
00003e  f7fffffe          BL       ble_cmd
000042  4604              MOV      r4,r0
;;;349    //                if( err )
;;;350    //                {
;;;351    //                    i=0;
;;;352    //                }
;;;353                    i=0;
000044  2500              MOVS     r5,#0
;;;354                    break;
000046  e059              B        |L7.252|
;;;355                 case 2 ://设置名称
;;;356                    sprintf( TEM, "AT+NAME=%s\r\n", Ble.Name );
000048  4a3a              LDR      r2,|L7.308|
00004a  a13b              ADR      r1,|L7.312|
00004c  4668              MOV      r0,sp
00004e  f7fffffe          BL       __2sprintf
;;;357                    err = ble_cmd( TEM, Ble.Name, 1000 ); //err = ble_cmd( TEM, "+NAME:JC-G6201", 1000 ); //
000052  f44f727a          MOV      r2,#0x3e8
000056  4937              LDR      r1,|L7.308|
000058  4668              MOV      r0,sp
00005a  f7fffffe          BL       ble_cmd
00005e  4604              MOV      r4,r0
;;;358                    if( err )
000060  b10c              CBZ      r4,|L7.102|
;;;359                    {
;;;360                        i++;
000062  1c68              ADDS     r0,r5,#1
000064  b2c5              UXTB     r5,r0
                  |L7.102|
;;;361                    }
;;;362                    break;
000066  e049              B        |L7.252|
;;;363                 case 3 ://设置UUID
;;;364                    err = ble_cmd("AT+UUID=AA0000fee700001000800000805f9b34fb\r\n","DATA:0000FEE7", 1000 ); //0000fee7-0000-1000-8000-00805f9b34fb
000068  f44f727a          MOV      r2,#0x3e8
00006c  a136              ADR      r1,|L7.328|
00006e  a03a              ADR      r0,|L7.344|
000070  f7fffffe          BL       ble_cmd
000074  4604              MOV      r4,r0
;;;365                    if( err )
000076  b10c              CBZ      r4,|L7.124|
;;;366                    {
;;;367                        i++;
000078  1c68              ADDS     r0,r5,#1
00007a  b2c5              UXTB     r5,r0
                  |L7.124|
;;;368                    }
;;;369                    break;
00007c  e03e              B        |L7.252|
;;;370                 case 4 ://设置UUID r
;;;371                    err = ble_cmd("AT+UUID=BB000036f600001000800000805f9b34fb\r\n","DATA:000036F6", 1000 ); //000036f6-0000-1000-8000-00805f9b34fb
00007e  f44f727a          MOV      r2,#0x3e8
000082  a141              ADR      r1,|L7.392|
000084  a044              ADR      r0,|L7.408|
000086  f7fffffe          BL       ble_cmd
00008a  4604              MOV      r4,r0
;;;372                    
;;;373                    if( err )
00008c  b10c              CBZ      r4,|L7.146|
;;;374                    {
;;;375                        i++;
00008e  1c68              ADDS     r0,r5,#1
000090  b2c5              UXTB     r5,r0
                  |L7.146|
;;;376                    }
;;;377                    break;
000092  e033              B        |L7.252|
;;;378                 case 5 ://设置UUID w
;;;379                    err = ble_cmd("AT+UUID=CC000036f500001000800000805f9b34fb\r\n","DATA:000036F5", 1000 ); //000036f5-0000-1000-8000-00805f9b34fb
000094  f44f727a          MOV      r2,#0x3e8
000098  a14b              ADR      r1,|L7.456|
00009a  a04f              ADR      r0,|L7.472|
00009c  f7fffffe          BL       ble_cmd
0000a0  4604              MOV      r4,r0
;;;380                    if( err )
0000a2  b10c              CBZ      r4,|L7.168|
;;;381                    {
;;;382                        i++;
0000a4  1c68              ADDS     r0,r5,#1
0000a6  b2c5              UXTB     r5,r0
                  |L7.168|
;;;383                    }
;;;384                    break;
0000a8  e028              B        |L7.252|
;;;385                    
;;;386                 case 6 ://查询MAC地址 +MAC:9CA52512DD8E
;;;387                    ble_get_mac( Ble.Mac, 3000 );//err = ble_cmd("AT+MAC?\r\n","+MAC:", 1000 ); //
0000aa  f64031b8          MOV      r1,#0xbb8
0000ae  4821              LDR      r0,|L7.308|
0000b0  380d              SUBS     r0,r0,#0xd
0000b2  f7fffffe          BL       ble_get_mac
;;;388                    if( err )
0000b6  b10c              CBZ      r4,|L7.188|
;;;389                    {
;;;390                        i++;
0000b8  1c68              ADDS     r0,r5,#1
0000ba  b2c5              UXTB     r5,r0
                  |L7.188|
;;;391                    }
;;;392                    break;
0000bc  e01e              B        |L7.252|
;;;393    //             case 7://设为从机模式 设置完从机模块会复位，退出命令模式
;;;394    //                err = ble_cmd("AT+MODE=S\r\n","+MODE:Slave", 1000 ); //
;;;395    //                if( err )
;;;396    //                {
;;;397    //                    i++;
;;;398    //                }
;;;399    //                break; AT+HIBERNATE
;;;400                case 7://低功耗模式设置 
;;;401                    
;;;402                    err = ble_cmd("AT+AUTOSLEEP=OFF,4\r\n","AUTO:OFF\r\n", 1000 ); //取消自动睡眠模式
0000be  f44f727a          MOV      r2,#0x3e8
0000c2  a151              ADR      r1,|L7.520|
0000c4  a053              ADR      r0,|L7.532|
0000c6  f7fffffe          BL       ble_cmd
0000ca  4604              MOV      r4,r0
;;;403                    //err = ble_cmd("AT+AUTOSLEEP=ON,5\r\n","AUTO:ON\r\n", 1000 ); //自动睡眠模式 2.5mA
;;;404                    //err = ble_cmd("AT+DEEPSLEEP\r\n","+DEEPSLEEP:OK\r\n", 1000 ); //深度睡眠模式 0.39mA
;;;405                    //err = ble_cmd("AT+HIBERNATE\r\n","OK\r\n", 1000 ); //休眠模式 <60uA
;;;406                    if( err )
0000cc  b11c              CBZ      r4,|L7.214|
;;;407                    {
;;;408                        i++;
0000ce  1c68              ADDS     r0,r5,#1
0000d0  b2c5              UXTB     r5,r0
;;;409                        return 1;
0000d2  2001              MOVS     r0,#1
                  |L7.212|
;;;410                    }
;;;411                    
;;;412                    break; 
;;;413                case 8 ://
;;;414                    err = ble_cmd("AT+ENTM\r\n","+ENTM:OK", 500 );
;;;415                    if( err )
;;;416                    {
;;;417                        return 1;
;;;418                    }
;;;419                    break;
;;;420                 
;;;421                 default :
;;;422                    vTaskDelay( 5000 ); 
;;;423                    i = 0;
;;;424                    break;
;;;425            }
;;;426            
;;;427            if( !err ) vTaskDelay( 3000 ); 
;;;428        }
;;;429        
;;;430    }
0000d4  bd3e              POP      {r1-r5,pc}
                  |L7.214|
0000d6  e011              B        |L7.252|
0000d8  f44f72fa          MOV      r2,#0x1f4             ;414
0000dc  a10f              ADR      r1,|L7.284|
0000de  a012              ADR      r0,|L7.296|
0000e0  f7fffffe          BL       ble_cmd
0000e4  4604              MOV      r4,r0                 ;414
0000e6  b10c              CBZ      r4,|L7.236|
0000e8  2001              MOVS     r0,#1                 ;417
0000ea  e7f3              B        |L7.212|
                  |L7.236|
0000ec  e006              B        |L7.252|
0000ee  e7ff              B        |L7.240|
                  |L7.240|
0000f0  f2413088          MOV      r0,#0x1388            ;422
0000f4  f7fffffe          BL       vTaskDelay
0000f8  2500              MOVS     r5,#0                 ;423
0000fa  bf00              NOP                            ;424
                  |L7.252|
0000fc  bf00              NOP                            ;346
0000fe  b91c              CBNZ     r4,|L7.264|
000100  f64030b8          MOV      r0,#0xbb8             ;427
000104  f7fffffe          BL       vTaskDelay
                  |L7.264|
000108  e77d              B        |L7.6|
;;;431    
                          ENDP

00010a  0000              DCW      0x0000
                  |L7.268|
00010c  612b6f6b          DCB      "a+ok",0
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
                  |L7.276|
000114  2b2b2b61          DCB      "+++a",0
000118  00      
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L7.284|
00011c  2b454e54          DCB      "+ENTM:OK",0
000120  4d3a4f4b
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0
                  |L7.296|
000128  41542b45          DCB      "AT+ENTM\r\n",0
00012c  4e544d0d
000130  0a00    
000132  00                DCB      0
000133  00                DCB      0
                  |L7.308|
                          DCD      Ble+0x14
                  |L7.312|
000138  41542b4e          DCB      "AT+NAME=%s\r\n",0
00013c  414d453d
000140  25730d0a
000144  00      
000145  00                DCB      0
000146  00                DCB      0
000147  00                DCB      0
                  |L7.328|
000148  44415441          DCB      "DATA:0000FEE7",0
00014c  3a303030
000150  30464545
000154  3700    
000156  00                DCB      0
000157  00                DCB      0
                  |L7.344|
000158  41542b55          DCB      "AT+UUID=AA0000fee700001000800000805f9b34fb\r\n",0
00015c  5549443d
000160  41413030
000164  30306665
000168  65373030
00016c  30303130
000170  30303830
000174  30303030
000178  38303566
00017c  39623334
000180  66620d0a
000184  00      
000185  00                DCB      0
000186  00                DCB      0
000187  00                DCB      0
                  |L7.392|
000188  44415441          DCB      "DATA:000036F6",0
00018c  3a303030
000190  30333646
000194  3600    
000196  00                DCB      0
000197  00                DCB      0
                  |L7.408|
000198  41542b55          DCB      "AT+UUID=BB000036f600001000800000805f9b34fb\r\n",0
00019c  5549443d
0001a0  42423030
0001a4  30303336
0001a8  66363030
0001ac  30303130
0001b0  30303830
0001b4  30303030
0001b8  38303566
0001bc  39623334
0001c0  66620d0a
0001c4  00      
0001c5  00                DCB      0
0001c6  00                DCB      0
0001c7  00                DCB      0
                  |L7.456|
0001c8  44415441          DCB      "DATA:000036F5",0
0001cc  3a303030
0001d0  30333646
0001d4  3500    
0001d6  00                DCB      0
0001d7  00                DCB      0
                  |L7.472|
0001d8  41542b55          DCB      "AT+UUID=CC000036f500001000800000805f9b34fb\r\n",0
0001dc  5549443d
0001e0  43433030
0001e4  30303336
0001e8  66353030
0001ec  30303130
0001f0  30303830
0001f4  30303030
0001f8  38303566
0001fc  39623334
000200  66620d0a
000204  00      
000205  00                DCB      0
000206  00                DCB      0
000207  00                DCB      0
                  |L7.520|
000208  4155544f          DCB      "AUTO:OFF\r\n",0
00020c  3a4f4646
000210  0d0a00  
000213  00                DCB      0
                  |L7.532|
000214  41542b41          DCB      "AT+AUTOSLEEP=OFF,4\r\n",0
000218  55544f53
00021c  4c454550
000220  3d4f4646
000224  2c340d0a
000228  00      
000229  00                DCB      0
00022a  00                DCB      0
00022b  00                DCB      0

                          AREA ||i.BLE_Pares||, CODE, READONLY, ALIGN=1

                  BLE_Pares PROC
;;;640    */
;;;641    uint8_t BLE_Pares( uint8_t *msg, uint8_t len )
000000  4602              MOV      r2,r0
;;;642    {
;;;643    //    uint8_t i, n, err, TEM[10], KEY_TEM[16];
;;;644    //    
;;;645    //    i=0;
;;;646    //    n=0;
;;;647    //    err = 0;
;;;648    //    
;;;649    //    if( ble_find_one_meg( msg, BLE_GET_TOKEN, len ) )//获取令牌
;;;650    //    {
;;;651    //        debug_usr("BLE_GET_TOKEN\r\n");
;;;652    //        
;;;653    //        ble_get_token( Ble.Token );//随机获取令牌
;;;654    //        
;;;655    //        //生成回应帧
;;;656    //        *( msg + i++) = (uint8_t)( BLE_ACK_TOKEN >> 8 ); //命令编号
;;;657    //        *( msg + i++) = (uint8_t)( BLE_ACK_TOKEN ); //命令编号
;;;658    //        *( msg + i++) = 0x04; //LEN 后续有效字节数
;;;659    //        for( n=0; n<4; n++ ) //token
;;;660    //        {
;;;661    //            *( msg + i++ ) = Ble.Token[ n ];
;;;662    //        }
;;;663    //        *( msg + i++) = 0x01; //芯片类型
;;;664    //        *( msg + i++) = 0x01; //版本号
;;;665    //        *( msg + i++) = 0x00; //版本号
;;;666    //        *( msg + i++) = 0x00; //IDL
;;;667    //        *( msg + i++) = 0x00; //IDH
;;;668    //        *( msg + i++) = !Lock.state.bit.lock; //STA 是锁的开关状态
;;;669    //        *( msg + i++) = 0x00; //CNT 总的开锁次数
;;;670    //        *( msg + i++) = 0x00; //CNT
;;;671    //        *( msg + i++) = 0x00; //
;;;672    //        
;;;673    //    }else
;;;674    //    if( ble_find_one_meg( msg, BLE_SET_NAME, len ) ) //修改广播名称
;;;675    //    {
;;;676    //        debug_usr("BLE_SET_NAME\r\n");
;;;677    //        
;;;678    //        Ble.lg.bit.reset = 1; //回应后，模块复位
;;;679    //        if( ble_check_token( msg+11, Ble.Token ) == 0 ) //校验令牌
;;;680    //        {
;;;681    //            return 0; //校验失败
;;;682    //        }
;;;683    //        
;;;684    //        if( *( msg + 2 )>8 ) *( msg + 2 ) = 8; //长度不能超过8
;;;685    //            
;;;686    //        for( n=0; n<*( msg + 2 ); n++ ) //得到广播名称
;;;687    //        {
;;;688    //            Ble.Name[ n ] = *( msg + 3 + n );
;;;689    //        }
;;;690    //        
;;;691    //        for( ;n<9; n++ ) //后面清零
;;;692    //        {
;;;693    //            Ble.Name[ n ] = 0x00;
;;;694    //        }
;;;695    //        
;;;696    //        for( n=0; n<9; n++ ) //得到广播名称
;;;697    //        {
;;;698    //            data_saved.data.NAME[n] = Ble.Name[ n ];
;;;699    //        }
;;;700    //        
;;;701    //        //save
;;;702    //        SaveToFlash();
;;;703    //        
;;;704    //        //生成回应帧
;;;705    //        *( msg + i++) = (uint8_t)( BLE_ACK_NAME >> 8 ); //命令编号
;;;706    //        *( msg + i++) = (uint8_t)( BLE_ACK_NAME ); //命令编号
;;;707    //        *( msg + i++) = 0x01; //LEN 后续有效字节数
;;;708    //        *( msg + i++) = err; //修改结果 00 成功 01 失败
;;;709    //        
;;;710    //        for( ; i<16; ) //无效数据
;;;711    //        {
;;;712    //            *( msg + i++ ) = 0;
;;;713    //        }
;;;714    //    }else
;;;715    //    if( ble_find_one_meg( msg, BLE_GET_POWER, len ) ) //获取电量
;;;716    //    {
;;;717    //        debug_usr("BLE_GET_POWER\r\n");
;;;718    //        
;;;719    //        if( ble_check_token( msg+4, Ble.Token ) == 0 ) //校验令牌
;;;720    //        {
;;;721    //            return 0; //校验失败
;;;722    //        }
;;;723    //        
;;;724    //        //生成回应帧
;;;725    //        *( msg + i++) = (uint8_t)( BLE_ACK_POWER >> 8 ); //命令编号
;;;726    //        *( msg + i++) = (uint8_t)( BLE_ACK_POWER ); //命令编号
;;;727    //        *( msg + i++) = 0x01; //LEN 后续有效字节数
;;;728    //        *( msg + i++) = Lock.power_percent; //电池电量百分比 0~100
;;;729    //        
;;;730    //        for( ; i<16; ) //无效数据
;;;731    //        {
;;;732    //            *( msg + i++ ) = 0;
;;;733    //        }
;;;734    //    }else
;;;735    //    if( ble_find_one_meg( msg, BLE_UNLOCK, len ) ) //开锁
;;;736    //    {
;;;737    //        debug_usr("BLE_UNLOCK\r\n");
;;;738    //        
;;;739    //        if( ble_check_token( msg+9, Ble.Token ) == 0 ) //校验令牌
;;;740    //        {
;;;741    //            return 0; //校验失败
;;;742    //        }
;;;743    //        
;;;744    //        if( ble_check_pwd( msg+3, data_saved.data.PWD ) == 0 ) //校验密码
;;;745    //        {
;;;746    //            return 0; //校验失败
;;;747    //        }
;;;748    //        
;;;749    //        //生成回应帧
;;;750    //        *( msg + i++) = (uint8_t)( BLE_ACK_UNLOCK >> 8 ); //命令编号
;;;751    //        *( msg + i++) = (uint8_t)( BLE_ACK_UNLOCK ); //命令编号
;;;752    //        *( msg + i++) = 0x01; //LEN 后续有效字节数
;;;753    //        
;;;754    //        //开锁
;;;755    //        err = lock_unlock( );
;;;756    //        
;;;757    //        *( msg + i++) = !err; //状态返回 00 表示开锁成功 //01 表示开锁失败 和开锁函数实际返回值相反 //Lock.state.bit.lock; //
;;;758    //        
;;;759    //        for( ; i<16; ) //无效数据
;;;760    //        {
;;;761    //            *( msg + i++ ) = 0;
;;;762    //        }
;;;763    //    }else
;;;764    //    if( ble_find_one_meg( msg, BLE_LOCK, len ) ) //关锁
;;;765    //    {
;;;766    //        debug_usr("BLE_LOCK\r\n");
;;;767    //        
;;;768    //        if( ble_check_token( msg+4, Ble.Token ) == 0 ) //校验令牌
;;;769    //        {
;;;770    //            return 0; //校验失败
;;;771    //        }
;;;772    //        
;;;773    //        //生成回应帧
;;;774    //        *( msg + i++) = (uint8_t)( BLE_ACK_LOCK >> 8 ); //命令编号
;;;775    //        *( msg + i++) = (uint8_t)( BLE_ACK_LOCK ); //命令编号
;;;776    //        *( msg + i++) = 0x01; //LEN 后续有效字节数
;;;777    //        
;;;778    //        //关锁
;;;779    //        err = lock_lock( );
;;;780    //        
;;;781    //        *( msg + i++) = !err; //状态返回 00 表示开锁成功 //01 表示开锁失败 和关锁函数实际返回值相反 //!Lock.state.bit.lock; //
;;;782    //        
;;;783    //        for( ; i<16; ) //无效数据
;;;784    //        {
;;;785    //            *( msg + i++ ) = 0;
;;;786    //        }
;;;787    //    }else
;;;788    //    if( ble_find_one_meg( msg, BLE_GET_STA, len ) ) //查询锁状态
;;;789    //    {
;;;790    //        debug_usr("BLE_GET_STA\r\n");
;;;791    //        
;;;792    //        if( ble_check_token( msg+4, Ble.Token ) == 0 ) //校验令牌
;;;793    //        {
;;;794    //            return 0; //校验失败
;;;795    //        }
;;;796    //        
;;;797    //        //生成回应帧
;;;798    //        *( msg + i++) = (uint8_t)( BLE_ACK_STA >> 8 ); //命令编号
;;;799    //        *( msg + i++) = (uint8_t)( BLE_ACK_STA ); //命令编号
;;;800    //        *( msg + i++) = 0x01; //LEN 后续有效字节数
;;;801    //        *( msg + i++) = !Lock.state.bit.lock; //STA 为锁状态， 00 表示开启状态， 01 表示关闭状态。 这里与锁的协议相反
;;;802    //        
;;;803    //        for( ; i<16; ) //无效数据
;;;804    //        {
;;;805    //            *( msg + i++ ) = 0;
;;;806    //        }
;;;807    //    }else
;;;808    //    if( ble_find_one_meg( msg, BLE_OLD_PWD, len ) ) //修改密码，旧密码
;;;809    //    {
;;;810    //        debug_usr("BLE_OLD_PWD\r\n");
;;;811    //        
;;;812    //        if( !Ble.lg.bit.pwd ) //从未接收过旧密码
;;;813    //        {
;;;814    //            if( ble_check_token( msg+9, Ble.Token ) == 0 ) //校验令牌
;;;815    //            {
;;;816    //                return 0; //校验失败
;;;817    //            }
;;;818    //            for( n=0; n<6; n++ ) //得到旧密码
;;;819    //            {
;;;820    //                TEM[n] = *( msg + 3 + i );
;;;821    //            }
;;;822    //            
;;;823    //            err = hexncmp( data_saved.data.PWD, TEM, 6 );
;;;824    //            if( !err )
;;;825    //            {
;;;826    //                Ble.lg.bit.pwd = 1;
;;;827    //                debug_usr("old pwd is correct.\r\n");
;;;828    //            }else
;;;829    //            {
;;;830    //                debug_usr("old pwd is incorrect.\r\n");
;;;831    //            }
;;;832    //        }else //已经接收过旧密码，重复接收错误，舍弃
;;;833    //        {
;;;834    //            Ble.lg.bit.pwd = 0;
;;;835    //        }
;;;836    //        
;;;837    //        
;;;838    //        //应加入超时处理
;;;839    //        //...
;;;840    //        
;;;841    //        return 0;//此命令无需返回
;;;842    //    }else
;;;843    //    if( ble_find_one_meg( msg, BLE_NEW_PWD, len ) ) //修改密码，新密码
;;;844    //    {
;;;845    //        debug_usr("BLE_NEW_PWD\r\n");
;;;846    //        
;;;847    //        if( Ble.lg.bit.pwd ) //旧密码校验成功
;;;848    //        {
;;;849    //            if( ble_check_token( msg+9, Ble.Token ) == 0 ) //校验令牌
;;;850    //            {
;;;851    //                return 0; //校验失败
;;;852    //            }
;;;853    //            
;;;854    //            for( n=0; n<6; n++ ) //得到新密码
;;;855    //            {
;;;856    //                TEM[n] = *( msg + 3 + n );
;;;857    //            }
;;;858    //            
;;;859    //            Ble.lg.bit.pwd = 0;
;;;860    //            for( n=0; n<6; n++ ) //得到旧密码
;;;861    //            {
;;;862    //                data_saved.data.PWD[ n ] = TEM[n];
;;;863    //            }
;;;864    //            
;;;865    //            //save
;;;866    //            SaveToFlash();
;;;867    //            
;;;868    //            err = 0;//成功
;;;869    //            debug_usr("new pwd is setted.\r\n");
;;;870    //        }else //旧密码校验失败
;;;871    //        {
;;;872    //            err = 1;
;;;873    //            debug_usr("new pwd is error.\r\n");
;;;874    //        }
;;;875    //        
;;;876    //        //生成回应帧
;;;877    //        *( msg + i++) = (uint8_t)( BLE_ACK_PWD >> 8 ); //命令编号
;;;878    //        *( msg + i++) = (uint8_t)( BLE_ACK_PWD ); //命令编号
;;;879    //        *( msg + i++) = 0x01; //LEN 后续有效字节数
;;;880    //        *( msg + i++) = err; //修改结果 00 成功 01 失败
;;;881    //        
;;;882    //        for( ; i<16; ) //无效数据
;;;883    //        {
;;;884    //            *( msg + i++ ) = 0;
;;;885    //        }
;;;886    //    }else
;;;887    //    if( ble_find_one_meg( msg, BLE_SET_KEYL, len ) ) //修改秘钥，新密钥前 8 个字节
;;;888    //    {
;;;889    //        if( !Ble.lg.bit.key ) //从未接收过新秘钥前8个字节
;;;890    //        {
;;;891    //            if( ble_check_token( msg+11, Ble.Token ) == 0 ) //校验令牌
;;;892    //            {
;;;893    //                return 0; //校验失败
;;;894    //            }
;;;895    //            for( n=0; n<8; n++ ) //得到新秘钥
;;;896    //            {
;;;897    //                KEY_TEM[ n ]  = *( msg + 3 + n );
;;;898    //            }
;;;899    //            
;;;900    //            Ble.lg.bit.key = 1;
;;;901    //        
;;;902    //            //应加入超时处理
;;;903    //            //...
;;;904    //        }else //接收过新秘钥前8个字节，重复接收错误，舍弃
;;;905    //        {
;;;906    //            Ble.lg.bit.key = 0;
;;;907    //        }
;;;908    //        return 0;//此命令无需返回
;;;909    //    }else
;;;910    //    if( ble_find_one_meg( msg, BLE_SET_KEYH, len ) ) //修改秘钥，新密钥后 8 个字节
;;;911    //    {
;;;912    //        if( Ble.lg.bit.key ) //得到新秘钥前8个字节
;;;913    //        {
;;;914    //            Ble.lg.bit.key = 0;
;;;915    //            
;;;916    //            if( ble_check_token( msg+11, Ble.Token ) == 0 ) //校验令牌
;;;917    //            {
;;;918    //                return 0; //校验失败
;;;919    //            }
;;;920    //            
;;;921    //            for( n=0; n<8; n++ ) //得到新秘钥后 8 个字节
;;;922    //            {
;;;923    //                KEY_TEM[ 8+n ]  = *( msg + 3 + n );
;;;924    //            }
;;;925    //            
;;;926    //            for( n=0; n<16; n++ ) //得到新秘钥后 8 个字节
;;;927    //            {
;;;928    //                data_saved.data.KEY[ n ]  = KEY_TEM[n];
;;;929    //            }
;;;930    //            //save
;;;931    //            SaveToFlash();
;;;932    //            err = 0;
;;;933    //            debug_usr("new key is setted.\r\n");
;;;934    //            
;;;935    //        }else //旧密码校验失败
;;;936    //        {
;;;937    //            err = 1;
;;;938    //            debug_usr("new key is error.\r\n");
;;;939    //        }
;;;940    //        
;;;941    //        //生成回应帧
;;;942    //        *( msg + i++) = (uint8_t)( BLE_ACK_KEY >> 8 ); //命令编号
;;;943    //        *( msg + i++) = (uint8_t)( BLE_ACK_KEY ); //命令编号
;;;944    //        *( msg + i++) = 0x01; //LEN 后续有效字节数
;;;945    //        *( msg + i++) = err; //修改结果 00 成功 01 失败
;;;946    //        
;;;947    //        for( ; i<16; ) //无效数据
;;;948    //        {
;;;949    //            *( msg + i++ ) = 0;
;;;950    //        }
;;;951    //    }
;;;952    ////    else
;;;953    ////    if( ble_find_one_meg( msg, BLE_REPORT_STA, len ) )//上报状态 
;;;954    ////    {
;;;955    ////        ;
;;;956    ////    }
;;;957    //    
;;;958    //    if( i ) //发送回应帧
;;;959    //    {
;;;960    //        BLE_Send( msg, i);
;;;961    //        
;;;962    //        for(n=0;n<i;n++) 
;;;963    //        {
;;;964    //            comSendCharHex( LOCAL_COM, msg[n] );
;;;965    //            comSendChar( LOCAL_COM, ' ' );
;;;966    //        }
;;;967    //        comSendBuf( LOCAL_COM, "\r\n", 2 );
;;;968    //    }
;;;969    //    
;;;970    //    if( Ble.lg.bit.reset ) //更改广播名等命令，回应后，模块复位
;;;971    //    {
;;;972    //        Ble.lg.bit.reset = 0;
;;;973    //        vTaskDelay( pdMS_TO_TICKS(2000) );
;;;974    //        NVIC_SystemReset();//系统复位
;;;975    //    }
;;;976        
;;;977        return 1;//return i;
000002  2001              MOVS     r0,#1
;;;978    }
000004  4770              BX       lr
;;;979    
                          ENDP


                          AREA ||i.BLE_ReportState||, CODE, READONLY, ALIGN=2

                  BLE_ReportState PROC
;;;979    
;;;980    uint8_t BLE_ReportState( void )
000000  b510              PUSH     {r4,lr}
;;;981    {
;;;982        uint8_t i;
;;;983        
;;;984        i=0;
000002  2400              MOVS     r4,#0
;;;985        
;;;986        //生成回应帧
;;;987        BLE_TxBuf[ i++ ] = (uint8_t)( BLE_REPORT_STA >> 8 ); //命令编号
000004  2205              MOVS     r2,#5
000006  4621              MOV      r1,r4
000008  1c64              ADDS     r4,r4,#1
00000a  480f              LDR      r0,|L9.72|
00000c  5442              STRB     r2,[r0,r1]
;;;988        BLE_TxBuf[ i++ ] = (uint8_t)( BLE_REPORT_STA ) + 1; //命令编号
00000e  2209              MOVS     r2,#9
000010  4621              MOV      r1,r4
000012  1c64              ADDS     r4,r4,#1
000014  5442              STRB     r2,[r0,r1]
;;;989        BLE_TxBuf[ i++ ] = 0x01; //LEN 后续有效字节数
000016  2201              MOVS     r2,#1
000018  4621              MOV      r1,r4
00001a  1c64              ADDS     r4,r4,#1
00001c  5442              STRB     r2,[r0,r1]
;;;990        BLE_TxBuf[ i++ ] = 0;//!Lock.state.bit.lock; //STA 为锁状态， 00 表示开启状态， 01 表示关闭状态。
00001e  2200              MOVS     r2,#0
000020  4621              MOV      r1,r4
000022  1c64              ADDS     r4,r4,#1
000024  5442              STRB     r2,[r0,r1]
;;;991        
;;;992        for( ; i<16; i++ ) //无效数据
000026  e007              B        |L9.56|
                  |L9.40|
;;;993        {
;;;994            BLE_TxBuf[ i++ ] = 0;
000028  2200              MOVS     r2,#0
00002a  4620              MOV      r0,r4
00002c  1c61              ADDS     r1,r4,#1
00002e  b2cc              UXTB     r4,r1
000030  4905              LDR      r1,|L9.72|
000032  540a              STRB     r2,[r1,r0]
000034  1c60              ADDS     r0,r4,#1              ;992
000036  b2c4              UXTB     r4,r0                 ;992
                  |L9.56|
000038  2c10              CMP      r4,#0x10              ;992
00003a  dbf5              BLT      |L9.40|
;;;995        }
;;;996        
;;;997        BLE_Send( BLE_TxBuf, i);
00003c  4621              MOV      r1,r4
00003e  4802              LDR      r0,|L9.72|
000040  f7fffffe          BL       BLE_Send
;;;998            
;;;999        return i;
000044  4620              MOV      r0,r4
;;;1000   }
000046  bd10              POP      {r4,pc}
;;;1001   
                          ENDP

                  |L9.72|
                          DCD      BLE_TxBuf

                          AREA ||i.BLE_Send||, CODE, READONLY, ALIGN=1

                  BLE_Send PROC
;;;619    
;;;620    uint8_t BLE_Send( uint8_t *msg, uint8_t len )
000000  b570              PUSH     {r4-r6,lr}
;;;621    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;622        uint8_t err;
;;;623        
;;;624        err = 0;
000006  2600              MOVS     r6,#0
;;;625        
;;;626        //加密
;;;627        
;;;628        comSendBuf( BLE_COM, msg, len);
000008  462a              MOV      r2,r5
00000a  4621              MOV      r1,r4
00000c  2003              MOVS     r0,#3
00000e  f7fffffe          BL       comSendBuf
;;;629        
;;;630        return err;
000012  4630              MOV      r0,r6
;;;631    }
000014  bd70              POP      {r4-r6,pc}
;;;632    
                          ENDP


                          AREA ||i.BLE_Sleep||, CODE, READONLY, ALIGN=2

                  BLE_Sleep PROC
;;;128    
;;;129    uint8_t BLE_Sleep( void )
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
;;;131        uint8_t i, err;
;;;132        //char TEM[ 10 ];
;;;133        i=0;
000002  2500              MOVS     r5,#0
;;;134        
;;;135        while( 1 )
000004  e057              B        |L11.182|
                  |L11.6|
;;;136        {
;;;137            vTaskDelay( 1 );
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       vTaskDelay
;;;138    //        SoftWdtFed( vTaskOtg_ID );
;;;139            
;;;140            switch( i )
00000c  b135              CBZ      r5,|L11.28|
00000e  2d01              CMP      r5,#1
000010  d010              BEQ      |L11.52|
000012  2d02              CMP      r5,#2
000014  d01a              BEQ      |L11.76|
000016  2d03              CMP      r5,#3
000018  d141              BNE      |L11.158|
00001a  e022              B        |L11.98|
                  |L11.28|
;;;141            {
;;;142                case 0 ://
;;;143                    err = ble_cmd("+++a","a+ok", 500 );
00001c  f44f72fa          MOV      r2,#0x1f4
000020  a125              ADR      r1,|L11.184|
000022  a027              ADR      r0,|L11.192|
000024  f7fffffe          BL       ble_cmd
000028  4604              MOV      r4,r0
;;;144                    if( err )
00002a  b10c              CBZ      r4,|L11.48|
;;;145                    {
;;;146                        i = 2;
00002c  2502              MOVS     r5,#2
00002e  e000              B        |L11.50|
                  |L11.48|
;;;147                    }else
;;;148                    {
;;;149                        i = 1;
000030  2501              MOVS     r5,#1
                  |L11.50|
;;;150                    }
;;;151                    break;
000032  e03a              B        |L11.170|
                  |L11.52|
;;;152                 case 1 ://
;;;153                    err = ble_cmd("AT+ENTM\r\n","+ENTM:OK", 500 );//
000034  f44f72fa          MOV      r2,#0x1f4
000038  a123              ADR      r1,|L11.200|
00003a  a026              ADR      r0,|L11.212|
00003c  f7fffffe          BL       ble_cmd
000040  4604              MOV      r4,r0
;;;154                    
;;;155                    if( err )
000042  b10c              CBZ      r4,|L11.72|
;;;156                    {
;;;157                        i = 0;
000044  2500              MOVS     r5,#0
000046  e000              B        |L11.74|
                  |L11.72|
;;;158                    }else
;;;159                    {
;;;160                        i = 3;
000048  2503              MOVS     r5,#3
                  |L11.74|
;;;161                    }
;;;162                    break;
00004a  e02e              B        |L11.170|
                  |L11.76|
;;;163                case 2://低功耗模式设置 
;;;164                    
;;;165                    //err = ble_cmd("AT+AUTOSLEEP=ON,4\r\n","AUTO:ON\r\n", 1000 ); //自动睡眠模式 2.5mA
;;;166                    //err = ble_cmd("AT+DEEPSLEEP\r\n","+DEEPSLEEP:OK\r\n", 1000 ); //深度睡眠模式 0.39mA
;;;167                    err = ble_cmd("AT+HIBERNATE\r\n","OK\r\n", 1000 ); //休眠模式 <60uA
00004c  f44f727a          MOV      r2,#0x3e8
000050  a123              ADR      r1,|L11.224|
000052  a025              ADR      r0,|L11.232|
000054  f7fffffe          BL       ble_cmd
000058  4604              MOV      r4,r0
;;;168                    if( err )
00005a  b10c              CBZ      r4,|L11.96|
;;;169                    {
;;;170                        return 1;
00005c  2001              MOVS     r0,#1
;;;171                    }
;;;172                    
;;;173                    break; 
;;;174                 case 3 ://
;;;175                    if( !Ble.state.bit.link ) //如果蓝牙没有激活
;;;176                    {
;;;177                        Ble.state.bit.go_to_wake = 0;
;;;178                        Ble.state.bit.sleep = 0;
;;;179                        BLE_WakeUp( );
;;;180                        Ble.state.bit.wake = 1;
;;;181                    }else
;;;182                    {
;;;183                        BLE_HwReset( );
;;;184                    }
;;;185                    i = 0;
;;;186                    break;
;;;187                 default :
;;;188                    vTaskDelay( 1000 ); 
;;;189                    i = 0;
;;;190                    break;
;;;191            }
;;;192            
;;;193            if( !err ) vTaskDelay( 3000 ); 
;;;194        }
;;;195        
;;;196    }
00005e  bd70              POP      {r4-r6,pc}
                  |L11.96|
000060  e023              B        |L11.170|
                  |L11.98|
000062  4825              LDR      r0,|L11.248|
000064  7800              LDRB     r0,[r0,#0]            ;175  ; Ble
000066  f0000001          AND      r0,r0,#1              ;175
00006a  b9a0              CBNZ     r0,|L11.150|
00006c  4822              LDR      r0,|L11.248|
00006e  7800              LDRB     r0,[r0,#0]            ;177  ; Ble
000070  f0200020          BIC      r0,r0,#0x20           ;177
000074  4920              LDR      r1,|L11.248|
000076  7008              STRB     r0,[r1,#0]            ;177
000078  4608              MOV      r0,r1                 ;178
00007a  7800              LDRB     r0,[r0,#0]            ;178  ; Ble
00007c  f0200004          BIC      r0,r0,#4              ;178
000080  7008              STRB     r0,[r1,#0]            ;178
000082  f7fffffe          BL       BLE_WakeUp
000086  481c              LDR      r0,|L11.248|
000088  7800              LDRB     r0,[r0,#0]            ;180  ; Ble
00008a  f0200008          BIC      r0,r0,#8              ;180
00008e  3008              ADDS     r0,r0,#8              ;180
000090  4919              LDR      r1,|L11.248|
000092  7008              STRB     r0,[r1,#0]            ;180
000094  e001              B        |L11.154|
                  |L11.150|
000096  f7fffffe          BL       BLE_HwReset
                  |L11.154|
00009a  2500              MOVS     r5,#0                 ;185
00009c  e005              B        |L11.170|
                  |L11.158|
00009e  f44f707a          MOV      r0,#0x3e8             ;188
0000a2  f7fffffe          BL       vTaskDelay
0000a6  2500              MOVS     r5,#0                 ;189
0000a8  bf00              NOP                            ;190
                  |L11.170|
0000aa  bf00              NOP                            ;151
0000ac  b91c              CBNZ     r4,|L11.182|
0000ae  f64030b8          MOV      r0,#0xbb8             ;193
0000b2  f7fffffe          BL       vTaskDelay
                  |L11.182|
0000b6  e7a6              B        |L11.6|
;;;197    
                          ENDP

                  |L11.184|
0000b8  612b6f6b          DCB      "a+ok",0
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L11.192|
0000c0  2b2b2b61          DCB      "+++a",0
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L11.200|
0000c8  2b454e54          DCB      "+ENTM:OK",0
0000cc  4d3a4f4b
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L11.212|
0000d4  41542b45          DCB      "AT+ENTM\r\n",0
0000d8  4e544d0d
0000dc  0a00    
0000de  00                DCB      0
0000df  00                DCB      0
                  |L11.224|
0000e0  4f4b0d0a          DCB      "OK\r\n",0
0000e4  00      
0000e5  00                DCB      0
0000e6  00                DCB      0
0000e7  00                DCB      0
                  |L11.232|
0000e8  41542b48          DCB      "AT+HIBERNATE\r\n",0
0000ec  49424552
0000f0  4e415445
0000f4  0d0a00  
0000f7  00                DCB      0
                  |L11.248|
                          DCD      Ble

                          AREA ||i.BLE_VarInit||, CODE, READONLY, ALIGN=2

                  BLE_VarInit PROC
;;;198    
;;;199    void BLE_VarInit(void)
000000  2000              MOVS     r0,#0
;;;200    {
;;;201        Ble.lg.all = 0;
000002  4901              LDR      r1,|L12.8|
000004  7048              STRB     r0,[r1,#1]
;;;202    }
000006  4770              BX       lr
;;;203    
                          ENDP

                  |L12.8|
                          DCD      Ble

                          AREA ||i.BLE_WakeUp||, CODE, READONLY, ALIGN=2

                  BLE_WakeUp PROC
;;;116    
;;;117    void BLE_WakeUp(void)
000000  b510              PUSH     {r4,lr}
;;;118    {
;;;119        debug_ble("Ble WakeUp!\r\n");
000002  a00b              ADR      r0,|L13.48|
000004  f7fffffe          BL       debug_ble
;;;120        
;;;121        GPIO_PORT_BLE_RESET->BRR = GPIO_PIN_BLE_WAKE;//拉低电平>1s 有效，
000008  2080              MOVS     r0,#0x80
00000a  490d              LDR      r1,|L13.64|
00000c  6008              STR      r0,[r1,#0]
;;;122        vTaskDelay(pdMS_TO_TICKS(1500));
00000e  f24050dc          MOV      r0,#0x5dc
000012  f7fffffe          BL       vTaskDelay
;;;123        GPIO_PORT_BLE_RESET->BSRR = GPIO_PIN_BLE_WAKE;//再拉高
000016  2080              MOVS     r0,#0x80
000018  4909              LDR      r1,|L13.64|
00001a  1f09              SUBS     r1,r1,#4
00001c  6008              STR      r0,[r1,#0]
;;;124        vTaskDelay(pdMS_TO_TICKS(100));
00001e  2064              MOVS     r0,#0x64
000020  f7fffffe          BL       vTaskDelay
;;;125        ble_wait_ack( "Wake UP\r\n", 2000 );
000024  f44f61fa          MOV      r1,#0x7d0
000028  a006              ADR      r0,|L13.68|
00002a  f7fffffe          BL       ble_wait_ack
;;;126        
;;;127    }
00002e  bd10              POP      {r4,pc}
;;;128    
                          ENDP

                  |L13.48|
000030  426c6520          DCB      "Ble WakeUp!\r\n",0
000034  57616b65
000038  5570210d
00003c  0a00    
00003e  00                DCB      0
00003f  00                DCB      0
                  |L13.64|
                          DCD      0x40010c14
                  |L13.68|
000044  57616b65          DCB      "Wake UP\r\n",0
000048  2055500d
00004c  0a00    
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.ble_check_pwd||, CODE, READONLY, ALIGN=1

                  ble_check_pwd PROC
;;;591    
;;;592    uint8_t ble_check_pwd( uint8_t *buf, uint8_t *pwd )
000000  b510              PUSH     {r4,lr}
;;;593    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;594        uint8_t i;
;;;595        
;;;596        for( i=0; i<6; i++ )
000006  2100              MOVS     r1,#0
000008  e007              B        |L14.26|
                  |L14.10|
;;;597        {
;;;598            if( *(buf+i) != *(pwd+i) ) return 0;
00000a  5c50              LDRB     r0,[r2,r1]
00000c  5c5c              LDRB     r4,[r3,r1]
00000e  42a0              CMP      r0,r4
000010  d001              BEQ      |L14.22|
000012  2000              MOVS     r0,#0
                  |L14.20|
;;;599        }
;;;600        
;;;601        return 1;
;;;602    }
000014  bd10              POP      {r4,pc}
                  |L14.22|
000016  1c48              ADDS     r0,r1,#1              ;596
000018  b2c1              UXTB     r1,r0                 ;596
                  |L14.26|
00001a  2906              CMP      r1,#6                 ;596
00001c  dbf5              BLT      |L14.10|
00001e  2001              MOVS     r0,#1                 ;601
000020  e7f8              B        |L14.20|
;;;603    
                          ENDP


                          AREA ||i.ble_check_token||, CODE, READONLY, ALIGN=1

                  ble_check_token PROC
;;;579    //uint8_t CheckToken( uint8_t *buf, uint16_t hex16, uint8_t len )
;;;580    uint8_t ble_check_token( uint8_t *buf, uint8_t *token )
000000  b510              PUSH     {r4,lr}
;;;581    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;582        uint8_t i;
;;;583        
;;;584        for( i=0; i<4; i++ )
000006  2100              MOVS     r1,#0
000008  e007              B        |L15.26|
                  |L15.10|
;;;585        {
;;;586            if( *(buf+i) != *(token+i) ) return 0;
00000a  5c50              LDRB     r0,[r2,r1]
00000c  5c5c              LDRB     r4,[r3,r1]
00000e  42a0              CMP      r0,r4
000010  d001              BEQ      |L15.22|
000012  2000              MOVS     r0,#0
                  |L15.20|
;;;587        }
;;;588        
;;;589        return 1;
;;;590    }
000014  bd10              POP      {r4,pc}
                  |L15.22|
000016  1c48              ADDS     r0,r1,#1              ;584
000018  b2c1              UXTB     r1,r0                 ;584
                  |L15.26|
00001a  2904              CMP      r1,#4                 ;584
00001c  dbf5              BLT      |L15.10|
00001e  2001              MOVS     r0,#1                 ;589
000020  e7f8              B        |L15.20|
;;;591    
                          ENDP


                          AREA ||i.ble_cmd||, CODE, READONLY, ALIGN=2

                  ble_cmd PROC
;;;238    
;;;239    static uint8_t ble_cmd(char *cmd, char *ack, uint16_t t)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;240    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;241        uint8_t err, qn=1;
00000a  f04f0801          MOV      r8,#1
;;;242        char *add;
;;;243    
;;;244        comSendBuf( BLE_COM, (uint8_t *)cmd, strlen(cmd) );
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       strlen
000014  fa1ffa80          UXTH     r10,r0
000018  4652              MOV      r2,r10
00001a  4631              MOV      r1,r6
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       comSendBuf
;;;245        
;;;246        debug_ble("%s\r\n",cmd);
000022  4631              MOV      r1,r6
000024  a019              ADR      r0,|L16.140|
000026  f7fffffe          BL       debug_ble
;;;247        
;;;248        qn=t/100;
00002a  2064              MOVS     r0,#0x64
00002c  fb97f0f0          SDIV     r0,r7,r0
000030  f00008ff          AND      r8,r0,#0xff
;;;249        
;;;250        while( qn )
000034  e025              B        |L16.130|
                  |L16.54|
;;;251        {
;;;252            vTaskDelay( 10 );
000036  200a              MOVS     r0,#0xa
000038  f7fffffe          BL       vTaskDelay
;;;253            err = comGetALine( BLE_COM, BLE_RxBuf );
00003c  4915              LDR      r1,|L16.148|
00003e  2003              MOVS     r0,#3
000040  f7fffffe          BL       comGetALine
000044  4604              MOV      r4,r0
;;;254            if( err ) //成功接收
000046  b1bc              CBZ      r4,|L16.120|
;;;255        	{
;;;256        	    debug_ble("%s",BLE_RxBuf);
000048  4912              LDR      r1,|L16.148|
00004a  a013              ADR      r0,|L16.152|
00004c  f7fffffe          BL       debug_ble
;;;257        	    add = strstr( (char *)BLE_RxBuf, ack );
000050  4649              MOV      r1,r9
000052  4810              LDR      r0,|L16.148|
000054  f7fffffe          BL       strstr
000058  4605              MOV      r5,r0
;;;258                if( add )
00005a  b12d              CBZ      r5,|L16.104|
;;;259                {
;;;260                    comClearRxFifo( BLE_COM );
00005c  2003              MOVS     r0,#3
00005e  f7fffffe          BL       comClearRxFifo
;;;261                    return 1;
000062  2001              MOVS     r0,#1
                  |L16.100|
;;;262                }else
;;;263                {
;;;264                   qn--;
;;;265                   vTaskDelay(pdMS_TO_TICKS(100));
;;;266                }
;;;267        	}
;;;268        	else
;;;269        	{
;;;270        	    qn=0;
;;;271        	    debug_ble("[Timeout.Try again.]\r\n");
;;;272        	}
;;;273        }
;;;274    
;;;275        return 0;
;;;276    }
000064  e8bd87f0          POP      {r4-r10,pc}
                  |L16.104|
000068  f1a80001          SUB      r0,r8,#1              ;264
00006c  f00008ff          AND      r8,r0,#0xff           ;264
000070  2064              MOVS     r0,#0x64              ;265
000072  f7fffffe          BL       vTaskDelay
000076  e004              B        |L16.130|
                  |L16.120|
000078  f04f0800          MOV      r8,#0                 ;270
00007c  a007              ADR      r0,|L16.156|
00007e  f7fffffe          BL       debug_ble
                  |L16.130|
000082  f1b80f00          CMP      r8,#0                 ;250
000086  d1d6              BNE      |L16.54|
000088  2000              MOVS     r0,#0                 ;275
00008a  e7eb              B        |L16.100|
;;;277    
                          ENDP

                  |L16.140|
00008c  25730d0a          DCB      "%s\r\n",0
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L16.148|
                          DCD      BLE_RxBuf
                  |L16.152|
000098  257300            DCB      "%s",0
00009b  00                DCB      0
                  |L16.156|
00009c  5b54696d          DCB      "[Timeout.Try again.]\r\n",0
0000a0  656f7574
0000a4  2e547279
0000a8  20616761
0000ac  696e2e5d
0000b0  0d0a00  
0000b3  00                DCB      0

                          AREA ||i.ble_find_one_meg||, CODE, READONLY, ALIGN=1

                  ble_find_one_meg PROC
;;;545    //uint8_t FindOneMeg( uint8_t *buf, uint16_t hex16, uint8_t len )
;;;546    uint8_t ble_find_one_meg( uint8_t *buf, uint16_t hex16, uint8_t len )
000000  b5f0              PUSH     {r4-r7,lr}
;;;547    {
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
;;;548        uint8_t i=0, k=0, n=0;
000006  2100              MOVS     r1,#0
000008  2400              MOVS     r4,#0
00000a  2700              MOVS     r7,#0
;;;549        
;;;550        uint16_t tem16;
;;;551        
;;;552        for( i=0; i<len; )
00000c  bf00              NOP      
00000e  e00c              B        |L17.42|
                  |L17.16|
;;;553        {
;;;554            tem16 = ( ( (uint16_t)(*( buf + i ) ) << 8 ) )+ *( buf + i + 1 );
000010  1858              ADDS     r0,r3,r1
000012  7840              LDRB     r0,[r0,#1]
000014  f813c001          LDRB     r12,[r3,r1]
000018  eb00200c          ADD      r0,r0,r12,LSL #8
00001c  b286              UXTH     r6,r0
;;;555            if( tem16 == hex16 )
00001e  42ae              CMP      r6,r5
000020  d101              BNE      |L17.38|
;;;556            {
;;;557                n = 1;
000022  2701              MOVS     r7,#1
;;;558                break;
000024  e003              B        |L17.46|
                  |L17.38|
;;;559            }else
;;;560            {
;;;561                i++;
000026  1c48              ADDS     r0,r1,#1
000028  b2c1              UXTB     r1,r0
                  |L17.42|
00002a  4291              CMP      r1,r2                 ;552
00002c  dbf0              BLT      |L17.16|
                  |L17.46|
00002e  bf00              NOP                            ;558
;;;562            }
;;;563        }
;;;564        
;;;565         
;;;566        if( len-i < 8 ) return 0; //剩下长度不够一条数据(8字节),或没有找到数据
000030  1a50              SUBS     r0,r2,r1
000032  2808              CMP      r0,#8
000034  da01              BGE      |L17.58|
000036  2000              MOVS     r0,#0
                  |L17.56|
;;;567        
;;;568        if( i ) //如果数据不是从头开始，平移到开头
;;;569        {
;;;570            for( k=0; k<8; k++ )
;;;571            {
;;;572                *( buf + i ) = *( buf + i + k);
;;;573            }
;;;574        }    
;;;575        
;;;576        return n;
;;;577    }
000038  bdf0              POP      {r4-r7,pc}
                  |L17.58|
00003a  b141              CBZ      r1,|L17.78|
00003c  2400              MOVS     r4,#0                 ;570
00003e  e004              B        |L17.74|
                  |L17.64|
000040  1858              ADDS     r0,r3,r1              ;572
000042  5d00              LDRB     r0,[r0,r4]            ;572
000044  5458              STRB     r0,[r3,r1]            ;572
000046  1c60              ADDS     r0,r4,#1              ;570
000048  b2c4              UXTB     r4,r0                 ;570
                  |L17.74|
00004a  2c08              CMP      r4,#8                 ;570
00004c  dbf8              BLT      |L17.64|
                  |L17.78|
00004e  4638              MOV      r0,r7                 ;576
000050  e7f2              B        |L17.56|
;;;578    
                          ENDP


                          AREA ||i.ble_get_mac||, CODE, READONLY, ALIGN=2

                  ble_get_mac PROC
;;;277    
;;;278    uint8_t ble_get_mac( uint8_t *mac, uint16_t t)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;279    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;280        uint8_t err, qn=1, i;
000008  f04f0901          MOV      r9,#1
;;;281        char *add;
;;;282        
;;;283        //BaseType_t xResult;
;;;284        //err = ble_cmd("AT+MAC?\r\n","+MAC:", 1000 ); // +MAC:9CA52512DD8E
;;;285        comSendBuf( BLE_COM, "AT+MAC?\r\n", strlen("AT+MAC?\r\n") );
00000c  2209              MOVS     r2,#9
00000e  a121              ADR      r1,|L18.148|
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       comSendBuf
;;;286        
;;;287        debug_ble("%s\r\n","AT+MAC?\r\n");
000016  a11f              ADR      r1,|L18.148|
000018  a021              ADR      r0,|L18.160|
00001a  f7fffffe          BL       debug_ble
;;;288        
;;;289        qn=t/100;
00001e  2064              MOVS     r0,#0x64
000020  fb98f0f0          SDIV     r0,r8,r0
000024  f00009ff          AND      r9,r0,#0xff
;;;290        
;;;291        while( qn )
000028  e02e              B        |L18.136|
                  |L18.42|
;;;292        {
;;;293            vTaskDelay( 10 );
00002a  200a              MOVS     r0,#0xa
00002c  f7fffffe          BL       vTaskDelay
;;;294            err = comGetALine( BLE_COM, BLE_RxBuf );
000030  491d              LDR      r1,|L18.168|
000032  2003              MOVS     r0,#3
000034  f7fffffe          BL       comGetALine
000038  4606              MOV      r6,r0
;;;295            if( err ) //成功接收
00003a  b306              CBZ      r6,|L18.126|
;;;296        	{
;;;297        	    debug_ble("%s",BLE_RxBuf);
00003c  491a              LDR      r1,|L18.168|
00003e  a01b              ADR      r0,|L18.172|
000040  f7fffffe          BL       debug_ble
;;;298        	    add = strstr( (char *)BLE_RxBuf, "+MAC:" );
000044  a11a              ADR      r1,|L18.176|
000046  4818              LDR      r0,|L18.168|
000048  f7fffffe          BL       strstr
00004c  4605              MOV      r5,r0
;;;299                if( add )
00004e  b175              CBZ      r5,|L18.110|
;;;300                {
;;;301                    for( i=0; i<12; i++ )
000050  2400              MOVS     r4,#0
000052  e004              B        |L18.94|
                  |L18.84|
;;;302                    {
;;;303                        *(mac+i) = *(add+5+i);
000054  1d68              ADDS     r0,r5,#5
000056  5d00              LDRB     r0,[r0,r4]
000058  5538              STRB     r0,[r7,r4]
00005a  1c60              ADDS     r0,r4,#1              ;301
00005c  b2c4              UXTB     r4,r0                 ;301
                  |L18.94|
00005e  2c0c              CMP      r4,#0xc               ;301
000060  dbf8              BLT      |L18.84|
;;;304                    }
;;;305                    comClearRxFifo( BLE_COM );
000062  2003              MOVS     r0,#3
000064  f7fffffe          BL       comClearRxFifo
;;;306                    return 1;
000068  2001              MOVS     r0,#1
                  |L18.106|
;;;307                }else
;;;308                {
;;;309                   qn--;
;;;310                   vTaskDelay(pdMS_TO_TICKS(100));
;;;311                }
;;;312        	}
;;;313        	else
;;;314        	{
;;;315        	    qn=0;
;;;316        	    debug_ble("[Timeout.Try again.]\r\n");
;;;317        	}
;;;318        }
;;;319    
;;;320        return 0;
;;;321    }
00006a  e8bd87f0          POP      {r4-r10,pc}
                  |L18.110|
00006e  f1a90001          SUB      r0,r9,#1              ;309
000072  f00009ff          AND      r9,r0,#0xff           ;309
000076  2064              MOVS     r0,#0x64              ;310
000078  f7fffffe          BL       vTaskDelay
00007c  e004              B        |L18.136|
                  |L18.126|
00007e  f04f0900          MOV      r9,#0                 ;315
000082  a00d              ADR      r0,|L18.184|
000084  f7fffffe          BL       debug_ble
                  |L18.136|
000088  f1b90f00          CMP      r9,#0                 ;291
00008c  d1cd              BNE      |L18.42|
00008e  2000              MOVS     r0,#0                 ;320
000090  e7eb              B        |L18.106|
;;;322    
                          ENDP

000092  0000              DCW      0x0000
                  |L18.148|
000094  41542b4d          DCB      "AT+MAC?\r\n",0
000098  41433f0d
00009c  0a00    
00009e  00                DCB      0
00009f  00                DCB      0
                  |L18.160|
0000a0  25730d0a          DCB      "%s\r\n",0
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L18.168|
                          DCD      BLE_RxBuf
                  |L18.172|
0000ac  257300            DCB      "%s",0
0000af  00                DCB      0
                  |L18.176|
0000b0  2b4d4143          DCB      "+MAC:",0
0000b4  3a00    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L18.184|
0000b8  5b54696d          DCB      "[Timeout.Try again.]\r\n",0
0000bc  656f7574
0000c0  2e547279
0000c4  20616761
0000c8  696e2e5d
0000cc  0d0a00  
0000cf  00                DCB      0

                          AREA ||i.ble_get_token||, CODE, READONLY, ALIGN=2

                  ble_get_token PROC
;;;43     }
;;;44     void ble_get_token( uint8_t *number )
000000  b570              PUSH     {r4-r6,lr}
;;;45     {
000002  4604              MOV      r4,r0
;;;46         uint8_t i;
;;;47         //if( strlen(number) != 5 ) return; //内存溢出检测
;;;48         uint16_t tem16;
;;;49         tem16 = FilterTem.Buf[ 1 ]; //以ADC缓存中的数值为种子
000004  480d              LDR      r0,|L19.60|
000006  8886              LDRH     r6,[r0,#4]
;;;50         
;;;51         for(i=0; i<4; i++)
000008  2500              MOVS     r5,#0
00000a  e00d              B        |L19.40|
                  |L19.12|
;;;52         {
;;;53             
;;;54             srand( tem16 );//srand(g_usAdcValue);//
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       srand
;;;55             number[i] = ( rand() % 10 ) + 0x30; //生成0―10内的随机整数, 并转成asc码
000012  f7fffffe          BL       rand
000016  210a              MOVS     r1,#0xa
000018  fb90f2f1          SDIV     r2,r0,r1
00001c  fb010012          MLS      r0,r1,r2,r0
000020  3030              ADDS     r0,r0,#0x30
000022  5560              STRB     r0,[r4,r5]
000024  1c68              ADDS     r0,r5,#1              ;51
000026  b2c5              UXTB     r5,r0                 ;51
                  |L19.40|
000028  2d04              CMP      r5,#4                 ;51
00002a  dbef              BLT      |L19.12|
;;;56         }
;;;57         number[4] = 0;
00002c  2000              MOVS     r0,#0
00002e  7120              STRB     r0,[r4,#4]
;;;58         debug_usr("token:%s\r\n", number);
000030  4621              MOV      r1,r4
000032  a003              ADR      r0,|L19.64|
000034  f7fffffe          BL       debug_usr
;;;59     }
000038  bd70              POP      {r4-r6,pc}
;;;60     
                          ENDP

00003a  0000              DCW      0x0000
                  |L19.60|
                          DCD      FilterTem
                  |L19.64|
000040  746f6b65          DCB      "token:%s\r\n",0
000044  6e3a2573
000048  0d0a00  
00004b  00                DCB      0

                          AREA ||i.ble_wait_ack||, CODE, READONLY, ALIGN=2

                  ble_wait_ack PROC
;;;203    
;;;204    static uint8_t ble_wait_ack( char *ack, uint16_t t)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;205    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;206        uint8_t err, qn=1;
000008  f04f0801          MOV      r8,#1
;;;207        char  *add;
;;;208        
;;;209        qn=t/100;
00000c  2064              MOVS     r0,#0x64
00000e  fb97f0f0          SDIV     r0,r7,r0
000012  f00008ff          AND      r8,r0,#0xff
;;;210        
;;;211        while( qn )
000016  e022              B        |L20.94|
                  |L20.24|
;;;212        {
;;;213            err = comGetALine( BLE_COM, BLE_RxBuf );
000018  4913              LDR      r1,|L20.104|
00001a  2003              MOVS     r0,#3
00001c  f7fffffe          BL       comGetALine
000020  4604              MOV      r4,r0
;;;214            if( err ) //成功接收
000022  b1bc              CBZ      r4,|L20.84|
;;;215        	{
;;;216        	    debug_ble("%s",BLE_RxBuf);
000024  4910              LDR      r1,|L20.104|
000026  a011              ADR      r0,|L20.108|
000028  f7fffffe          BL       debug_ble
;;;217        	    
;;;218        	    add = strstr( (char*)BLE_RxBuf, ack );
00002c  4631              MOV      r1,r6
00002e  480e              LDR      r0,|L20.104|
000030  f7fffffe          BL       strstr
000034  4605              MOV      r5,r0
;;;219                if( add )
000036  b12d              CBZ      r5,|L20.68|
;;;220                {
;;;221                    comClearRxFifo( BLE_COM );
000038  2003              MOVS     r0,#3
00003a  f7fffffe          BL       comClearRxFifo
;;;222                    return 1;
00003e  2001              MOVS     r0,#1
                  |L20.64|
;;;223                }else
;;;224                {
;;;225                   qn--;
;;;226                   vTaskDelay(pdMS_TO_TICKS(100));
;;;227                }
;;;228        	}
;;;229        	else
;;;230        	{
;;;231        	    qn=0;
;;;232        	    debug_ble("[Timeout.Try again.]\r\n");
;;;233        	}
;;;234        }
;;;235    
;;;236        return 0;
;;;237    }
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L20.68|
000044  f1a80001          SUB      r0,r8,#1              ;225
000048  f00008ff          AND      r8,r0,#0xff           ;225
00004c  2064              MOVS     r0,#0x64              ;226
00004e  f7fffffe          BL       vTaskDelay
000052  e004              B        |L20.94|
                  |L20.84|
000054  f04f0800          MOV      r8,#0                 ;231
000058  a005              ADR      r0,|L20.112|
00005a  f7fffffe          BL       debug_ble
                  |L20.94|
00005e  f1b80f00          CMP      r8,#0                 ;211
000062  d1d9              BNE      |L20.24|
000064  2000              MOVS     r0,#0                 ;236
000066  e7eb              B        |L20.64|
;;;238    
                          ENDP

                  |L20.104|
                          DCD      BLE_RxBuf
                  |L20.108|
00006c  257300            DCB      "%s",0
00006f  00                DCB      0
                  |L20.112|
000070  5b54696d          DCB      "[Timeout.Try again.]\r\n",0
000074  656f7574
000078  2e547279
00007c  20616761
000080  696e2e5d
000084  0d0a00  
000087  00                DCB      0

                          AREA ||i.hexncmp||, CODE, READONLY, ALIGN=1

                  hexncmp PROC
;;;61     
;;;62     uint8_t hexncmp( uint8_t *s1, uint8_t *s2, uint8_t n )
000000  b530              PUSH     {r4,r5,lr}
;;;63     {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;64         uint8_t i;
;;;65         
;;;66         for(i=0; i<n; i++)
000006  2100              MOVS     r1,#0
000008  e007              B        |L21.26|
                  |L21.10|
;;;67         {
;;;68             if( *(s1+i) != *(s2+i) ) return 1;
00000a  5c58              LDRB     r0,[r3,r1]
00000c  5c65              LDRB     r5,[r4,r1]
00000e  42a8              CMP      r0,r5
000010  d001              BEQ      |L21.22|
000012  2001              MOVS     r0,#1
                  |L21.20|
;;;69         }
;;;70         
;;;71         return 0;
;;;72     }
000014  bd30              POP      {r4,r5,pc}
                  |L21.22|
000016  1c48              ADDS     r0,r1,#1              ;66
000018  b2c1              UXTB     r1,r0                 ;66
                  |L21.26|
00001a  4291              CMP      r1,r2                 ;66
00001c  dbf5              BLT      |L21.10|
00001e  2000              MOVS     r0,#0                 ;71
000020  e7f8              B        |L21.20|
;;;73     void BLE_IoInit(void)
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  BLE_TxBuf
                          %        100
                  BLE_RxBuf
                          %        100
                  Ble
                          %        30

                          AREA ||.data||, DATA, ALIGN=0

                  ble_state_tem
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_ble.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_ble_c_63fd190a____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_ble_c_63fd190a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_ble_c_63fd190a____REVSH|
#line 128
|__asm___9_bsp_ble_c_63fd190a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
