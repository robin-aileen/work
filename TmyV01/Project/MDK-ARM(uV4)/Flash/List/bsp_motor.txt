; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_motor.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_motor.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app -I..\..\User\lcd\inc -I..\..\User\hx711 -I.\RTE\_Flash -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=526 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_motor.crf ..\..\User\app\bsp_motor.c]
                          THUMB

                          AREA ||i.MOTOR_ClrStep||, CODE, READONLY, ALIGN=2

                  MOTOR_ClrStep PROC
;;;236    
;;;237    void MOTOR_ClrStep( void )
000000  2000              MOVS     r0,#0
;;;238    {
;;;239        Motor.counter_step = 0;
000002  4901              LDR      r1,|L1.8|
000004  6048              STR      r0,[r1,#4]  ; Motor
;;;240    }
000006  4770              BX       lr
;;;241    
                          ENDP

                  |L1.8|
                          DCD      Motor

                          AREA ||i.MOTOR_Init||, CODE, READONLY, ALIGN=2

                  MOTOR_Init PROC
;;;195    
;;;196    void MOTOR_Init( uint32_t Cycle )
000000  b510              PUSH     {r4,lr}
;;;197    {
000002  4604              MOV      r4,r0
;;;198        //MOTOR_SPEED_18[]={1000,100,30,10};
;;;199        Motor.max_step = MAX_STEP_18ML;
000004  4805              LDR      r0,|L2.28|
000006  4906              LDR      r1,|L2.32|
000008  6088              STR      r0,[r1,#8]  ; Motor
;;;200        motor_dir_init( );
00000a  f7fffffe          BL       motor_dir_init
;;;201        motor_pul_init(Cycle);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       motor_pul_init
;;;202        
;;;203        Motor.timer_t_pulse = 0;
000014  2000              MOVS     r0,#0
000016  4902              LDR      r1,|L2.32|
000018  6188              STR      r0,[r1,#0x18]  ; Motor
;;;204    }
00001a  bd10              POP      {r4,pc}
;;;205    
                          ENDP

                  |L2.28|
                          DCD      0x0003b97e
                  |L2.32|
                          DCD      Motor

                          AREA ||i.MOTOR_SetDir||, CODE, READONLY, ALIGN=2

                  MOTOR_SetDir PROC
;;;205    
;;;206    void MOTOR_SetDir( uint8_t dir )
000000  b510              PUSH     {r4,lr}
;;;207    {
000002  4604              MOV      r4,r0
;;;208        Motor.state.bit.dir = dir;
000004  4810              LDR      r0,|L3.72|
000006  7880              LDRB     r0,[r0,#2]  ; Motor
000008  f3640000          BFI      r0,r4,#0,#1
00000c  490e              LDR      r1,|L3.72|
00000e  7088              STRB     r0,[r1,#2]
;;;209        MOTOR_DIR( dir );
000010  b12c              CBZ      r4,|L3.30|
000012  f44f5180          MOV      r1,#0x1000
000016  480d              LDR      r0,|L3.76|
000018  f7fffffe          BL       GPIO_SetBits
00001c  e004              B        |L3.40|
                  |L3.30|
00001e  f44f5180          MOV      r1,#0x1000
000022  480a              LDR      r0,|L3.76|
000024  f7fffffe          BL       GPIO_ResetBits
                  |L3.40|
;;;210        vTaskDelay(100);
000028  2064              MOVS     r0,#0x64
00002a  f7fffffe          BL       vTaskDelay
;;;211        if( dir ) SetTextValue(0,18,"下降");
00002e  b12c              CBZ      r4,|L3.60|
000030  a207              ADR      r2,|L3.80|
000032  2112              MOVS     r1,#0x12
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       SetTextValue
00003a  e004              B        |L3.70|
                  |L3.60|
;;;212        else SetTextValue(0,18,"上升");
00003c  a206              ADR      r2,|L3.88|
00003e  2112              MOVS     r1,#0x12
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       SetTextValue
                  |L3.70|
;;;213    }
000046  bd10              POP      {r4,pc}
;;;214    
                          ENDP

                  |L3.72|
                          DCD      Motor
                  |L3.76|
                          DCD      0x40010800
                  |L3.80|
000050  cfc2bdb5          DCB      207,194,189,181,0
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L3.88|
000058  c9cfc9fd          DCB      201,207,201,253,0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.MOTOR_SetSpeed||, CODE, READONLY, ALIGN=2

                  MOTOR_SetSpeed PROC
;;;150    
;;;151    void MOTOR_SetSpeed(uint32_t speed)
000000  b538              PUSH     {r3-r5,lr}
;;;152    {
000002  4604              MOV      r4,r0
;;;153        uint32_t Cycle;
;;;154        Cycle = speed;//MOTOR_SPEED_CYCLE[ MOTOR_SPEED_INDEX[Motor.gear][speed-1] ];//Cycle = MOTOR_SPEED[Motor.gear][speed-1];
000004  4625              MOV      r5,r4
;;;155        TIM_SetAutoreload(TIM1,Cycle-1);
000006  1e68              SUBS     r0,r5,#1
000008  b281              UXTH     r1,r0
00000a  4811              LDR      r0,|L4.80|
00000c  f7fffffe          BL       TIM_SetAutoreload
;;;156    	TIM_SetCompare4(TIM1,Cycle/2-1);
000010  2001              MOVS     r0,#1
000012  ebc00055          RSB      r0,r0,r5,LSR #1
000016  b281              UXTH     r1,r0
000018  480d              LDR      r0,|L4.80|
00001a  f7fffffe          BL       TIM_SetCompare4
;;;157        TIM_SetCounter(TIM1,Cycle/2-1);
00001e  2001              MOVS     r0,#1
000020  ebc00055          RSB      r0,r0,r5,LSR #1
000024  b281              UXTH     r1,r0
000026  480a              LDR      r0,|L4.80|
000028  f7fffffe          BL       TIM_SetCounter
;;;158        
;;;159        MOTOR_Start( );
00002c  f7fffffe          BL       MOTOR_Start
;;;160        
;;;161        Motor.state.bit.t_pulse = 1;
000030  4808              LDR      r0,|L4.84|
000032  7880              LDRB     r0,[r0,#2]  ; Motor
000034  f0200040          BIC      r0,r0,#0x40
000038  3040              ADDS     r0,r0,#0x40
00003a  4906              LDR      r1,|L4.84|
00003c  7088              STRB     r0,[r1,#2]
;;;162        SetTextInt32(0, 17, Cycle, 0, 1);
00003e  2001              MOVS     r0,#1
000040  2300              MOVS     r3,#0
000042  462a              MOV      r2,r5
000044  2111              MOVS     r1,#0x11
000046  9000              STR      r0,[sp,#0]
000048  4618              MOV      r0,r3
00004a  f7fffffe          BL       SetTextInt32
;;;163        
;;;164    }
00004e  bd38              POP      {r3-r5,pc}
;;;165    //void MOTOR_SetSpeed(uint32_t speed)
                          ENDP

                  |L4.80|
                          DCD      0x40012c00
                  |L4.84|
                          DCD      Motor

                          AREA ||i.MOTOR_Start||, CODE, READONLY, ALIGN=2

                  MOTOR_Start PROC
;;;224    
;;;225    void MOTOR_Start( void )
000000  b510              PUSH     {r4,lr}
;;;226    {
;;;227        Motor.state.bit.move = 1;
000002  4806              LDR      r0,|L5.28|
000004  7880              LDRB     r0,[r0,#2]  ; Motor
000006  f0200008          BIC      r0,r0,#8
00000a  3008              ADDS     r0,r0,#8
00000c  4903              LDR      r1,|L5.28|
00000e  7088              STRB     r0,[r1,#2]
;;;228    	TIM_Cmd(TIM1,ENABLE);;
000010  2101              MOVS     r1,#1
000012  4803              LDR      r0,|L5.32|
000014  f7fffffe          BL       TIM_Cmd
;;;229    }
000018  bd10              POP      {r4,pc}
;;;230    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      Motor
                  |L5.32|
                          DCD      0x40012c00

                          AREA ||i.MOTOR_Stop||, CODE, READONLY, ALIGN=2

                  MOTOR_Stop PROC
;;;230    
;;;231    void MOTOR_Stop( void )
000000  b510              PUSH     {r4,lr}
;;;232    {
;;;233        Motor.state.bit.move = 0;
000002  4805              LDR      r0,|L6.24|
000004  7880              LDRB     r0,[r0,#2]  ; Motor
000006  f0200008          BIC      r0,r0,#8
00000a  4903              LDR      r1,|L6.24|
00000c  7088              STRB     r0,[r1,#2]
;;;234        TIM_Cmd(TIM1, DISABLE);
00000e  2100              MOVS     r1,#0
000010  4802              LDR      r0,|L6.28|
000012  f7fffffe          BL       TIM_Cmd
;;;235    }
000016  bd10              POP      {r4,pc}
;;;236    
                          ENDP

                  |L6.24|
                          DCD      Motor
                  |L6.28|
                          DCD      0x40012c00

                          AREA ||i.Pulse_outputT1T2||, CODE, READONLY, ALIGN=1

                  Pulse_outputT1T2 PROC
;;;116    }
;;;117    void Pulse_outputT1T2(uint32_t Cycle,uint32_t PulseNum)
000000  b570              PUSH     {r4-r6,lr}
;;;118    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;119    //    TIM2_config(PulseNum);
;;;120    //    TIM_Cmd(TIM2, ENABLE);
;;;121    //    TIM_ClearITPendingBit(TIM2,TIM_IT_Update);
;;;122    //    TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);
;;;123        TIM1_config(Cycle);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       TIM1_config
;;;124        
;;;125        //TIM_Cmd(TIM1, ENABLE);
;;;126        //TIM_CtrlPWMOutputs(TIM1, ENABLE);   //高级定时器一定要加上，主输出使能
;;;127    }
00000c  bd70              POP      {r4-r6,pc}
;;;128    
                          ENDP


                          AREA ||i.TIM1_UP_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM1_UP_IRQHandler PROC
;;;241    
;;;242    void TIM1_UP_IRQHandler(void) 
000000  b510              PUSH     {r4,lr}
;;;243    { 
;;;244        if (TIM_GetITStatus(TIM1, TIM_IT_Update) != RESET)     // TIM_IT_CC1
000002  2101              MOVS     r1,#1
000004  4810              LDR      r0,|L8.72|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b1e0              CBZ      r0,|L8.70|
;;;245        { 
;;;246            TIM_ClearITPendingBit(TIM1, TIM_IT_Update); // 清除中断标志位
00000c  2101              MOVS     r1,#1
00000e  480e              LDR      r0,|L8.72|
000010  f7fffffe          BL       TIM_ClearITPendingBit
;;;247            if( Motor.state.bit.dir == UP )
000014  480d              LDR      r0,|L8.76|
000016  7880              LDRB     r0,[r0,#2]  ; Motor
000018  f0000001          AND      r0,r0,#1
00001c  b958              CBNZ     r0,|L8.54|
;;;248            {
;;;249                if( Motor.counter_step < Motor.max_step ) Motor.counter_step++;
00001e  480b              LDR      r0,|L8.76|
000020  6840              LDR      r0,[r0,#4]  ; Motor
000022  490a              LDR      r1,|L8.76|
000024  6889              LDR      r1,[r1,#8]  ; Motor
000026  4288              CMP      r0,r1
000028  d20d              BCS      |L8.70|
00002a  4808              LDR      r0,|L8.76|
00002c  6840              LDR      r0,[r0,#4]  ; Motor
00002e  1c40              ADDS     r0,r0,#1
000030  4906              LDR      r1,|L8.76|
000032  6048              STR      r0,[r1,#4]  ; Motor
000034  e007              B        |L8.70|
                  |L8.54|
;;;250            }else
;;;251            {
;;;252                if( Motor.counter_step ) Motor.counter_step--;
000036  4805              LDR      r0,|L8.76|
000038  6840              LDR      r0,[r0,#4]  ; Motor
00003a  b120              CBZ      r0,|L8.70|
00003c  4803              LDR      r0,|L8.76|
00003e  6840              LDR      r0,[r0,#4]  ; Motor
000040  1e40              SUBS     r0,r0,#1
000042  4902              LDR      r1,|L8.76|
000044  6048              STR      r0,[r1,#4]  ; Motor
                  |L8.70|
;;;253            }
;;;254        }
;;;255    }
000046  bd10              POP      {r4,pc}
;;;256    
                          ENDP

                  |L8.72|
                          DCD      0x40012c00
                  |L8.76|
                          DCD      Motor

                          AREA ||i.TIM1_config||, CODE, READONLY, ALIGN=2

                  TIM1_config PROC
;;;39     /***定时器1主模式***/
;;;40     void TIM1_config(uint32_t Cycle)
000000  b510              PUSH     {r4,lr}
;;;41     {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
;;;42         GPIO_InitTypeDef GPIO_InitStructure;
;;;43         TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;44         TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;45         NVIC_InitTypeDef NVIC_InitStructure;
;;;46         
;;;47         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_TIM1 , ENABLE); 
000006  2101              MOVS     r1,#1
000008  f6400004          MOV      r0,#0x804
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;48     
;;;49         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;                   //TIM1_CH4 PA11 //GPIO_Pin_9; //TIM1_CH2 PA9
000010  f44f6000          MOV      r0,#0x800
000014  f8ad0024          STRH     r0,[sp,#0x24]
;;;50         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;             //复用推挽输出
000018  2018              MOVS     r0,#0x18
00001a  f88d0027          STRB     r0,[sp,#0x27]
;;;51         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001e  2003              MOVS     r0,#3
000020  f88d0026          STRB     r0,[sp,#0x26]
;;;52         GPIO_Init(GPIOA, &GPIO_InitStructure);
000024  a909              ADD      r1,sp,#0x24
000026  4826              LDR      r0,|L9.192|
000028  f7fffffe          BL       GPIO_Init
;;;53     
;;;54         TIM_TimeBaseStructure.TIM_Period = Cycle-1;                                                   
00002c  1e60              SUBS     r0,r4,#1
00002e  b280              UXTH     r0,r0
000030  f8ad001c          STRH     r0,[sp,#0x1c]
;;;55         TIM_TimeBaseStructure.TIM_Prescaler =71;                    //设置用来作为TIMx时钟频率除数的预分频值                                                     
000034  2047              MOVS     r0,#0x47
000036  f8ad0018          STRH     r0,[sp,#0x18]
;;;56         TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;     //设置时钟分割：TDTS= Tck_tim            
00003a  2000              MOVS     r0,#0
00003c  f8ad001e          STRH     r0,[sp,#0x1e]
;;;57         TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; //TIM向上计数模式
000040  f8ad001a          STRH     r0,[sp,#0x1a]
;;;58         TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;            //重复计数，一定要=0！！！
000044  f88d0020          STRB     r0,[sp,#0x20]
;;;59         TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);                                       
000048  a906              ADD      r1,sp,#0x18
00004a  481e              LDR      r0,|L9.196|
00004c  f7fffffe          BL       TIM_TimeBaseInit
;;;60     
;;;61         TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;          //选择定时器模式：TIM脉冲宽度调制模式1       
000050  2060              MOVS     r0,#0x60
000052  f8ad0008          STRH     r0,[sp,#8]
;;;62         TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能
000056  2001              MOVS     r0,#1
000058  f8ad000a          STRH     r0,[sp,#0xa]
;;;63         TIM_OCInitStructure.TIM_Pulse = Cycle/2-1;                    //设置待装入捕获寄存器的脉冲值                                   
00005c  ebc00054          RSB      r0,r0,r4,LSR #1
000060  b280              UXTH     r0,r0
000062  f8ad000e          STRH     r0,[sp,#0xe]
;;;64         TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;      //输出极性       
000066  2002              MOVS     r0,#2
000068  f8ad0010          STRH     r0,[sp,#0x10]
;;;65     
;;;66         TIM_OC4Init(TIM1, &TIM_OCInitStructure);  
00006c  a902              ADD      r1,sp,#8
00006e  4815              LDR      r0,|L9.196|
000070  f7fffffe          BL       TIM_OC4Init
;;;67         
;;;68     //    TIM_SelectMasterSlaveMode(TIM1, TIM_MasterSlaveMode_Enable);
;;;69     //    TIM_SelectOutputTrigger(TIM1, TIM_TRGOSource_Update);
;;;70     //    
;;;71     //
;;;72     ////    TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
;;;73     ////    TIM_ARRPreloadConfig(TIM1, ENABLE);    
;;;74         
;;;75         TIM_ARRPreloadConfig(TIM1,ENABLE);
000074  2101              MOVS     r1,#1
000076  4813              LDR      r0,|L9.196|
000078  f7fffffe          BL       TIM_ARRPreloadConfig
;;;76         TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
00007c  2108              MOVS     r1,#8
00007e  4811              LDR      r0,|L9.196|
000080  f7fffffe          BL       TIM_OC4PreloadConfig
;;;77         TIM_CtrlPWMOutputs(TIM1, ENABLE);   //高级定时器一定要加上，主输出使能
000084  2101              MOVS     r1,#1
000086  480f              LDR      r0,|L9.196|
000088  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;78         
;;;79         TIM_Cmd(TIM1, DISABLE);
00008c  2100              MOVS     r1,#0
00008e  480d              LDR      r0,|L9.196|
000090  f7fffffe          BL       TIM_Cmd
;;;80         //TIM_ARRPreloadConfig(TIM1,DISABLE);
;;;81         //TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Disable);
;;;82         
;;;83          //使能指定的TIM中断
;;;84         TIM_ITConfig(TIM1, TIM_IT_Update, ENABLE);
000094  2201              MOVS     r2,#1
000096  4611              MOV      r1,r2
000098  480a              LDR      r0,|L9.196|
00009a  f7fffffe          BL       TIM_ITConfig
;;;85     
;;;86         NVIC_InitStructure.NVIC_IRQChannel = TIM1_UP_IRQn;       
00009e  2019              MOVS     r0,#0x19
0000a0  f88d0004          STRB     r0,[sp,#4]
;;;87         NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
0000a4  2000              MOVS     r0,#0
0000a6  f88d0005          STRB     r0,[sp,#5]
;;;88         NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;     
0000aa  f88d0006          STRB     r0,[sp,#6]
;;;89         NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 
0000ae  2001              MOVS     r0,#1
0000b0  f88d0007          STRB     r0,[sp,#7]
;;;90         NVIC_Init(&NVIC_InitStructure);
0000b4  a801              ADD      r0,sp,#4
0000b6  f7fffffe          BL       NVIC_Init
;;;91                                                                          
;;;92     }
0000ba  b00a              ADD      sp,sp,#0x28
0000bc  bd10              POP      {r4,pc}
;;;93     /***定时器2从模式***/
                          ENDP

0000be  0000              DCW      0x0000
                  |L9.192|
                          DCD      0x40010800
                  |L9.196|
                          DCD      0x40012c00

                          AREA ||i.TIM2_config||, CODE, READONLY, ALIGN=1

                  TIM2_config PROC
;;;93     /***定时器2从模式***/
;;;94     void TIM2_config(uint32_t PulseNum)
000000  b51f              PUSH     {r0-r4,lr}
;;;95     {
000002  4604              MOV      r4,r0
;;;96         TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;97         NVIC_InitTypeDef NVIC_InitStructure; 
;;;98         RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;99     
;;;100        TIM_TimeBaseStructure.TIM_Period = 4800-1;//100000-1; //100ms
00000c  f24120bf          MOV      r0,#0x12bf
000010  f8ad0008          STRH     r0,[sp,#8]
;;;101        TIM_TimeBaseStructure.TIM_Prescaler = 10000-1;//71;    
000014  f242700f          MOV      r0,#0x270f
000018  f8ad0004          STRH     r0,[sp,#4]
;;;102        TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;     
00001c  2000              MOVS     r0,#0
00001e  f8ad000a          STRH     r0,[sp,#0xa]
;;;103        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
000022  f8ad0006          STRH     r0,[sp,#6]
;;;104        TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);  
000026  a901              ADD      r1,sp,#4
000028  f04f4080          MOV      r0,#0x40000000
00002c  f7fffffe          BL       TIM_TimeBaseInit
;;;105           
;;;106        TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);
000030  2201              MOVS     r2,#1
000032  4611              MOV      r1,r2
000034  0790              LSLS     r0,r2,#30
000036  f7fffffe          BL       TIM_ITConfig
;;;107        //使能TIM定时器
;;;108        TIM_Cmd(TIM2, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  0788              LSLS     r0,r1,#30
00003e  f7fffffe          BL       TIM_Cmd
;;;109        
;;;110       // NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);
;;;111        NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;        
000042  201c              MOVS     r0,#0x1c
000044  f88d0000          STRB     r0,[sp,#0]
;;;112        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000048  2000              MOVS     r0,#0
00004a  f88d0001          STRB     r0,[sp,#1]
;;;113        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;     
00004e  f88d0002          STRB     r0,[sp,#2]
;;;114        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 
000052  2001              MOVS     r0,#1
000054  f88d0003          STRB     r0,[sp,#3]
;;;115        NVIC_Init(&NVIC_InitStructure);
000058  4668              MOV      r0,sp
00005a  f7fffffe          BL       NVIC_Init
;;;116    }
00005e  bd1f              POP      {r0-r4,pc}
;;;117    void Pulse_outputT1T2(uint32_t Cycle,uint32_t PulseNum)
                          ENDP


                          AREA ||i.motor_dir_init||, CODE, READONLY, ALIGN=2

                  motor_dir_init PROC
;;;176    
;;;177    void motor_dir_init( void )
000000  b508              PUSH     {r3,lr}
;;;178    {
;;;179        GPIO_InitTypeDef GPIO_InitStructure; //定义一个GPIO_InitTypeDef类型的结构体
;;;180    
;;;181    	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA, ENABLE); //开启GPIOA的外设时钟
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;182        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; //选择要控制的GPIOA引脚
00000a  f44f5080          MOV      r0,#0x1000
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;183        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //设置引脚模式为通用推挽输出
000012  2010              MOVS     r0,#0x10
000014  f88d0003          STRB     r0,[sp,#3]
;;;184        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //设置引脚速率为50MHz
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;185        GPIO_Init(GPIOA, &GPIO_InitStructure); //调用库函数，初始化GPIOB  
00001e  4669              MOV      r1,sp
000020  4804              LDR      r0,|L11.52|
000022  f7fffffe          BL       GPIO_Init
;;;186        
;;;187        MOTOR_DIR( UP );//关闭所有
000026  f44f5180          MOV      r1,#0x1000
00002a  4802              LDR      r0,|L11.52|
00002c  f7fffffe          BL       GPIO_ResetBits
;;;188    }
000030  bd08              POP      {r3,pc}
;;;189    
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      0x40010800

                          AREA ||i.motor_pul_init||, CODE, READONLY, ALIGN=1

                  motor_pul_init PROC
;;;189    
;;;190    void motor_pul_init(uint32_t Cycle)
000000  b510              PUSH     {r4,lr}
;;;191    {
000002  4604              MOV      r4,r0
;;;192        TIM1_config(Cycle);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       TIM1_config
;;;193        //TIM2_config( 100000 );
;;;194    }
00000a  bd10              POP      {r4,pc}
;;;195    
                          ENDP


                          AREA ||i.pulse_set_f||, CODE, READONLY, ALIGN=2

                  pulse_set_f PROC
;;;143    
;;;144    void pulse_set_f(uint32_t Cycle)
000000  b510              PUSH     {r4,lr}
;;;145    {
000002  4604              MOV      r4,r0
;;;146        TIM_SetAutoreload(TIM1,Cycle-1);
000004  1e60              SUBS     r0,r4,#1
000006  b281              UXTH     r1,r0
000008  4808              LDR      r0,|L13.44|
00000a  f7fffffe          BL       TIM_SetAutoreload
;;;147    	TIM_SetCompare4(TIM1,Cycle/2-1);
00000e  2001              MOVS     r0,#1
000010  ebc00054          RSB      r0,r0,r4,LSR #1
000014  b281              UXTH     r1,r0
000016  4805              LDR      r0,|L13.44|
000018  f7fffffe          BL       TIM_SetCompare4
;;;148        TIM_SetCounter(TIM1,Cycle/2-1);
00001c  2001              MOVS     r0,#1
00001e  ebc00054          RSB      r0,r0,r4,LSR #1
000022  b281              UXTH     r1,r0
000024  4801              LDR      r0,|L13.44|
000026  f7fffffe          BL       TIM_SetCounter
;;;149    }
00002a  bd10              POP      {r4,pc}
;;;150    
                          ENDP

                  |L13.44|
                          DCD      0x40012c00

                          AREA ||i.pulse_start||, CODE, READONLY, ALIGN=2

                  pulse_start PROC
;;;129    
;;;130    void pulse_start( void )
000000  b510              PUSH     {r4,lr}
;;;131    {
;;;132    //	TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);
;;;133    //    TIM_ARRPreloadConfig(TIM1,ENABLE);
;;;134    	TIM_Cmd(TIM1,ENABLE);;
000002  2101              MOVS     r1,#1
000004  4801              LDR      r0,|L14.12|
000006  f7fffffe          BL       TIM_Cmd
;;;135    }
00000a  bd10              POP      {r4,pc}
;;;136    
                          ENDP

                  |L14.12|
                          DCD      0x40012c00

                          AREA ||i.pulse_stop||, CODE, READONLY, ALIGN=1

                  pulse_stop PROC
;;;136    
;;;137    void pulse_stop( void )
000000  4770              BX       lr
;;;138    {
;;;139    //	TIM_Cmd(TIM1, DISABLE);
;;;140    //    TIM_ARRPreloadConfig(TIM1,DISABLE);
;;;141    //    TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Disable);//TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Disable);
;;;142    }
;;;143    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Motor
                          %        28

                          AREA ||.data||, DATA, ALIGN=1

                  BEEP_TIMER
000000  00c80064          DCW      0x00c8,0x0064
000004  00320021          DCW      0x0032,0x0021
000008  00110014          DCW      0x0011,0x0014
00000c  00140000          DCW      0x0014,0x0000
                  MOTOR_SPEED_DISPLAY
000010  c2fdc2fd          DCB      0xc2,0xfd,0xc2,0xfd
000014  cbd92020          DCB      0xcb,0xd9,0x20,0x20
000018  00c2fdcb          DCB      0x00,0xc2,0xfd,0xcb
00001c  d9202020          DCB      0xd9,0x20,0x20,0x20
000020  2000d6d0          DCB      0x20,0x00,0xd6,0xd0
000024  cbd92020          DCB      0xcb,0xd9,0x20,0x20
000028  202000bf          DCB      0x20,0x20,0x00,0xbf
00002c  eccbd920          DCB      0xec,0xcb,0xd9,0x20
000030  20202000          DCB      0x20,0x20,0x20,0x00
000034  d7eebfec          DCB      0xd7,0xee,0xbf,0xec
000038  cbd92000          DCB      0xcb,0xd9,0x20,0x00
00003c  00d7d4b6          DCB      0x00,0xd7,0xd4,0xb6
000040  afc5c5bf          DCB      0xaf,0xc5,0xc5,0xbf
000044  d500bbd8          DCB      0xd5,0x00,0xbb,0xd8
000048  cefc2020          DCB      0xce,0xfc,0x20,0x20
00004c  202000b6          DCB      0x20,0x20,0x00,0xb6
000050  a5b8cbbc          DCB      0xa5,0xb8,0xcb,0xbc
000054  ecb2e900          DCB      0xec,0xb2,0xe9,0x00
                  MOTOR_SPEED_CYCLE
000058  0b030581          DCW      0x0b03,0x0581
00005c  025900f8          DCW      0x0259,0x00f8
000060  003e0086          DCW      0x003e,0x0086
000064  00860026          DCW      0x0086,0x0026
                  MOTOR_SPEED_INDEX
000068  00000000          DCW      0x0000,0x0000
00006c  00000001          DCW      0x0000,0x0001
000070  00010001          DCW      0x0001,0x0001
000074  00010002          DCW      0x0001,0x0002
000078  00030000          DCW      0x0003,0x0000
00007c  00030004          DCW      0x0003,0x0004
                  DIS_PLAY
000080  c2fdc2fd          DCB      0xc2,0xfd,0xc2,0xfd
000084  cbd900c2          DCB      0xcb,0xd9,0x00,0xc2
000088  fdc2fdcb          DCB      0xfd,0xc2,0xfd,0xcb
00008c  d900c2fd          DCB      0xd9,0x00,0xc2,0xfd
000090  c2fdcbd9          DCB      0xc2,0xfd,0xcb,0xd9
000094  00c2fdcb          DCB      0x00,0xc2,0xfd,0xcb
000098  d9202000          DCB      0xd9,0x20,0x20,0x00
00009c  c2fdcbd9          DCB      0xc2,0xfd,0xcb,0xd9
0000a0  202000c2          DCB      0x20,0x20,0x00,0xc2
0000a4  fdcbd920          DCB      0xfd,0xcb,0xd9,0x20
0000a8  2000c2fd          DCB      0x20,0x00,0xc2,0xfd
0000ac  cbd92020          DCB      0xcb,0xd9,0x20,0x20
0000b0  00d6d0cb          DCB      0x00,0xd6,0xd0,0xcb
0000b4  d9202000          DCB      0xd9,0x20,0x20,0x00
0000b8  bfeccbd9          DCB      0xbf,0xec,0xcb,0xd9
0000bc  202000c2          DCB      0x20,0x20,0x00,0xc2
0000c0  fdc2fdcb          DCB      0xfd,0xc2,0xfd,0xcb
0000c4  d900bfec          DCB      0xd9,0x00,0xbf,0xec
0000c8  cbd92020          DCB      0xcb,0xd9,0x20,0x20
0000cc  00d7eebf          DCB      0x00,0xd7,0xee,0xbf
0000d0  eccbd900          DCB      0xec,0xcb,0xd9,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\bsp_motor.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_motor_c_09168d08____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_motor_c_09168d08____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_motor_c_09168d08____REVSH|
#line 128
|__asm___11_bsp_motor_c_09168d08____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
