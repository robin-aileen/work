; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\main.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app -I..\..\User\lcd\inc -I..\..\User\hx711 -ID:\MyDoc\MyPrj\MyGitPrj\TmyV01\Project\MDK-ARM(uV4)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\main.crf ..\..\User\main.c]
                          THUMB

                          AREA ||i.AppTaskCreate||, CODE, READONLY, ALIGN=2

                  AppTaskCreate PROC
;;;1133   */
;;;1134   static void AppTaskCreate (void)
000000  b51f              PUSH     {r0-r4,lr}
;;;1135   {
;;;1136   //    xTaskCreate( vTaskTaskUserIF,   	/* 任务函数  */
;;;1137   //                 "vTaskUserIF",     	/* 任务名    */
;;;1138   //                 512,               	/* 任务栈大小，单位word，也就是4字节 */
;;;1139   //                 NULL,              	/* 任务参数  */
;;;1140   //                 1,                 	/* 任务优先级*/
;;;1141   //                 &xHandleTaskUserIF );  /* 任务句柄  */
;;;1142   //	
;;;1143   //	
;;;1144   
;;;1145   
;;;1146   	xTaskCreate( vTaskLCD,    		/* 任务函数  */
000002  2000              MOVS     r0,#0
000004  4a14              LDR      r2,|L1.88|
000006  2304              MOVS     r3,#4
000008  e9cd2001          STRD     r2,r0,[sp,#4]
00000c  9300              STR      r3,[sp,#0]
00000e  9003              STR      r0,[sp,#0xc]
000010  4603              MOV      r3,r0
000012  f44f7200          MOV      r2,#0x200
000016  a111              ADR      r1,|L1.92|
000018  4813              LDR      r0,|L1.104|
00001a  f7fffffe          BL       xTaskGenericCreate
;;;1147                    "vTaskLCD",  		/* 任务名    */
;;;1148                    STKSIZE_TaskLCD,         		/* 任务栈大小，单位word，也就是4字节 */
;;;1149                    NULL,        		/* 任务参数  */
;;;1150                    PRIO_TaskLCD,      /* 任务优先级*/
;;;1151                    &xHandleTaskLCD ); /* 任务句柄  */
;;;1152   	
;;;1153   	xTaskCreate( vTaskMotorCtrl,     		/* 任务函数  */
00001e  2000              MOVS     r0,#0
000020  4a12              LDR      r2,|L1.108|
000022  2303              MOVS     r3,#3
000024  e9cd2001          STRD     r2,r0,[sp,#4]
000028  9300              STR      r3,[sp,#0]
00002a  9003              STR      r0,[sp,#0xc]
00002c  4603              MOV      r3,r0
00002e  f44f7200          MOV      r2,#0x200
000032  a10f              ADR      r1,|L1.112|
000034  4812              LDR      r0,|L1.128|
000036  f7fffffe          BL       xTaskGenericCreate
;;;1154                    "vTaskMotorCtrl",   		/* 任务名    */
;;;1155                    STKSIZE_TaskMotorCtrl,     /* 任务栈大小，单位word，也就是4字节 */
;;;1156                    NULL,           		    /* 任务参数  */
;;;1157                    PRIO_TaskMotorCtrl,        /* 任务优先级*/
;;;1158                    &xHandleTaskMotorCtrl );  /* 任务句柄  */
;;;1159   	
;;;1160       xTaskCreate( vTaskSensor,     		    /* 任务函数  */
00003a  2000              MOVS     r0,#0
00003c  4a11              LDR      r2,|L1.132|
00003e  2301              MOVS     r3,#1
000040  e9cd2001          STRD     r2,r0,[sp,#4]
000044  9300              STR      r3,[sp,#0]
000046  9003              STR      r0,[sp,#0xc]
000048  4603              MOV      r3,r0
00004a  2280              MOVS     r2,#0x80
00004c  a10e              ADR      r1,|L1.136|
00004e  4811              LDR      r0,|L1.148|
000050  f7fffffe          BL       xTaskGenericCreate
;;;1161                    "vTaskSensor",   		    /* 任务名    */
;;;1162                    STKSIZE_TaskSensor,        /* 任务栈大小，单位word，也就是4字节 */
;;;1163                    NULL,           		    /* 任务参数  */
;;;1164                    PRIO_TaskSensor,           /* 任务优先级*/
;;;1165                    &xHandleTaskSensor );      /* 任务句柄  */
;;;1166   }
000054  bd1f              POP      {r0-r4,pc}
;;;1167   
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      xHandleTaskLCD
                  |L1.92|
00005c  76546173          DCB      "vTaskLCD",0
000060  6b4c4344
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L1.104|
                          DCD      vTaskLCD
                  |L1.108|
                          DCD      xHandleTaskMotorCtrl
                  |L1.112|
000070  76546173          DCB      "vTaskMotorCtrl",0
000074  6b4d6f74
000078  6f724374
00007c  726c00  
00007f  00                DCB      0
                  |L1.128|
                          DCD      vTaskMotorCtrl
                  |L1.132|
                          DCD      xHandleTaskSensor
                  |L1.136|
000088  76546173          DCB      "vTaskSensor",0
00008c  6b53656e
000090  736f7200
                  |L1.148|
                          DCD      vTaskSensor

                          AREA ||i.P_GetMsgFromUart||, CODE, READONLY, ALIGN=1

                  P_GetMsgFromUart PROC
;;;63     
;;;64     uint16_t P_GetMsgFromUart(COM_PORT_E _ucPort, uint8_t *msg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;65     {
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
;;;66     	uint16_t i=0;
000006  2400              MOVS     r4,#0
;;;67         uint8_t tem8=0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;68         uint32_t tem32 = 0;
00000c  2600              MOVS     r6,#0
;;;69         
;;;70         if( comGetLen(_ucPort) > 3 ) //收接收数据
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       comGetLen
000014  2803              CMP      r0,#3
000016  dd28              BLE      |L2.106|
;;;71         {
;;;72             while( comGetLen(_ucPort) )
000018  e022              B        |L2.96|
                  |L2.26|
;;;73             {
;;;74                 comGetChar(_ucPort, &tem8);
00001a  4669              MOV      r1,sp
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       comGetChar
;;;75                 if( i == 0 )
000022  b954              CBNZ     r4,|L2.58|
;;;76                 {
;;;77                     if( tem8 == 0xEE ) 
000024  f89d0000          LDRB     r0,[sp,#0]
000028  28ee              CMP      r0,#0xee
00002a  d116              BNE      |L2.90|
;;;78                     {
;;;79                         *( msg + i++ ) = tem8;
00002c  f89d2000          LDRB     r2,[sp,#0]
000030  4620              MOV      r0,r4
000032  1c61              ADDS     r1,r4,#1
000034  b28c              UXTH     r4,r1
000036  542a              STRB     r2,[r5,r0]
000038  e00f              B        |L2.90|
                  |L2.58|
;;;80                     }
;;;81                 }else
;;;82                 {
;;;83                     *( msg + i++ ) = tem8;
00003a  f89d2000          LDRB     r2,[sp,#0]
00003e  4620              MOV      r0,r4
000040  1c61              ADDS     r1,r4,#1
000042  b28c              UXTH     r4,r1
000044  542a              STRB     r2,[r5,r0]
;;;84                     
;;;85                     tem32 = ((tem32<<8)|tem8);                           //拼接最后4个字节，组成一个32位整数
000046  f89d0000          LDRB     r0,[sp,#0]
00004a  ea402606          ORR      r6,r0,r6,LSL #8
;;;86                     if( tem32 == 0xFFFCFFFF )
00004e  f46f3040          MVN      r0,#0x30000
000052  4286              CMP      r6,r0
000054  d101              BNE      |L2.90|
;;;87                     {
;;;88                         return i;
000056  4620              MOV      r0,r4
                  |L2.88|
;;;89                     }
;;;90     //                if( i > 13 )
;;;91     //                {
;;;92     //                    if( tem8 == 0xFF ) 
;;;93     //                    {
;;;94     //                        return i;
;;;95     //                    }else
;;;96     //                    {
;;;97     //                        return 0;
;;;98     //                    }
;;;99     //                }
;;;100                }
;;;101                vTaskDelay(pdMS_TO_TICKS(1));
;;;102            }
;;;103        }
;;;104        return 0;
;;;105    }
000058  bdf8              POP      {r3-r7,pc}
                  |L2.90|
00005a  2001              MOVS     r0,#1                 ;101
00005c  f7fffffe          BL       vTaskDelay
                  |L2.96|
000060  4638              MOV      r0,r7                 ;72
000062  f7fffffe          BL       comGetLen
000066  2800              CMP      r0,#0                 ;72
000068  d1d7              BNE      |L2.26|
                  |L2.106|
00006a  2000              MOVS     r0,#0                 ;104
00006c  e7f4              B        |L2.88|
;;;106    
                          ENDP


                          AREA ||i.TMY_ParaInit||, CODE, READONLY, ALIGN=2

                  TMY_ParaInit PROC
;;;107    //默认参数
;;;108    void TMY_ParaInit( void )
000000  4811              LDR      r0,|L3.72|
;;;109    {
;;;110    	//步进电机初始化
;;;111        //方向
;;;112    	Motor.state.bit.dir = UP;
000002  7880              LDRB     r0,[r0,#2]  ; Motor
000004  f0200001          BIC      r0,r0,#1
000008  490f              LDR      r1,|L3.72|
00000a  7088              STRB     r0,[r1,#2]
;;;113        //速度
;;;114    	Motor.speed = SLOW;
00000c  2001              MOVS     r0,#1
00000e  7008              STRB     r0,[r1,#0]
;;;115    	Motor.gear = GEAR_SLOW_NORMAL_FAST; //慢中快速，默认有效
000010  2002              MOVS     r0,#2
000012  7048              STRB     r0,[r1,#1]
;;;116        //SetTextValue(0, 16,"停止\x00");
;;;117        
;;;118        //频率
;;;119        //SetTextValue(0, 17,"0");
;;;120        
;;;121    	Motor.max_step = MAX_STEP_18ML; //最大步数
000014  480d              LDR      r0,|L3.76|
000016  6088              STR      r0,[r1,#8]  ; Motor
;;;122    	Motor.counter_step = 0; //步数
000018  2000              MOVS     r0,#0
00001a  6048              STR      r0,[r1,#4]  ; Motor
;;;123    	
;;;124    	//其它初始化
;;;125    	Tmy.pressure = 0; //压力
00001c  490c              LDR      r1,|L3.80|
00001e  60c8              STR      r0,[r1,#0xc]  ; Tmy
;;;126    	Tmy.power_percent = 100; //电量
000020  2064              MOVS     r0,#0x64
000022  7208              STRB     r0,[r1,#8]
;;;127    	
;;;128        Tmy.Key.zdpk = 1; //自动排空，默认有效
000024  4608              MOV      r0,r1
000026  7940              LDRB     r0,[r0,#5]  ; Tmy
000028  f0200002          BIC      r0,r0,#2
00002c  1c80              ADDS     r0,r0,#2
00002e  7148              STRB     r0,[r1,#5]
;;;129        Tmy.Key.hx = 1; //回吸，默认有效
000030  4608              MOV      r0,r1
000032  7940              LDRB     r0,[r0,#5]  ; Tmy
000034  f0200001          BIC      r0,r0,#1
000038  1c40              ADDS     r0,r0,#1
00003a  7148              STRB     r0,[r1,#5]
;;;130        Tmy.Key.zh = 0; //1.8ml，默认有效
00003c  4608              MOV      r0,r1
00003e  7940              LDRB     r0,[r0,#5]  ; Tmy
000040  f0200008          BIC      r0,r0,#8
000044  7148              STRB     r0,[r1,#5]
;;;131    }
000046  4770              BX       lr
;;;132    
                          ENDP

                  |L3.72|
                          DCD      Motor
                  |L3.76|
                          DCD      0x0003b97e
                  |L3.80|
                          DCD      Tmy

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;167    */
;;;168    int main(void)
000000  2001              MOVS     r0,#1
000002  f3808810          MSR      PRIMASK,r0
000006  bf00              NOP      
;;;169    {
;;;170    	/* 
;;;171    	  在启动调度前，为了防止初始化STM32外设时有中断服务程序执行，这里禁止全局中断(除了NMI和HardFault)。
;;;172    	  这样做的好处是：
;;;173    	  1. 防止执行的中断服务程序中有FreeRTOS的API函数。
;;;174    	  2. 保证系统正常启动，不受别的中断影响。
;;;175    	  3. 关于是否关闭全局中断，大家根据自己的实际情况设置即可。
;;;176    	  在移植文件port.c中的函数prvStartFirstTask中会重新开启全局中断。通过指令cpsie i开启，__set_PRIMASK(1)
;;;177    	  和cpsie i是等效的。
;;;178         */
;;;179    	__set_PRIMASK(1);  
;;;180    	
;;;181    	/* 硬件初始化 */
;;;182    	bsp_Init(); 
000008  f7fffffe          BL       bsp_Init
;;;183    	debug_en( 1 );
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       debug_en
;;;184    	
;;;185    	TMY_ParaInit();
000012  f7fffffe          BL       TMY_ParaInit
;;;186    	start_set();
000016  f7fffffe          BL       start_set
;;;187    	
;;;188    	/* 创建任务 */
;;;189    	AppTaskCreate();
00001a  f7fffffe          BL       AppTaskCreate
;;;190    	
;;;191        /* 启动调度，开始执行任务 */
;;;192        vTaskStartScheduler();
00001e  f7fffffe          BL       vTaskStartScheduler
;;;193    
;;;194    	/* 
;;;195    	  如果系统正常启动是不会运行到这里的，运行到这里极有可能是用于定时器任务或者空闲任务的
;;;196    	  heap空间不足造成创建失败，此要加大FreeRTOSConfig.h文件中定义的heap大小：
;;;197    	  #define configTOTAL_HEAP_SIZE	      ( ( size_t ) ( 17 * 1024 ) )
;;;198    	*/
;;;199    	while(1);
000022  bf00              NOP      
                  |L4.36|
000024  e7fe              B        |L4.36|
;;;200    }
;;;201    
                          ENDP


                          AREA ||i.start_set||, CODE, READONLY, ALIGN=2

                  start_set PROC
;;;133    
;;;134    void start_set( void )
000000  b510              PUSH     {r4,lr}
;;;135    {
;;;136        if(RCC_GetFlagStatus(RCC_FLAG_PORRST))
000002  207b              MOVS     r0,#0x7b
000004  f7fffffe          BL       RCC_GetFlagStatus
000008  b118              CBZ      r0,|L5.18|
;;;137        {
;;;138            debug_usr("power reset:");//上电重启
00000a  a00d              ADR      r0,|L5.64|
00000c  f7fffffe          BL       debug_usr
000010  e002              B        |L5.24|
                  |L5.18|
;;;139        }else
;;;140        {
;;;141            debug_usr("other reset:");//软重启
000012  a00f              ADR      r0,|L5.80|
000014  f7fffffe          BL       debug_usr
                  |L5.24|
;;;142        }
;;;143        
;;;144        //debug_usr("%d %d\r\n", data_saved.data.n_reset, data_saved.data.n_error);//
;;;145        
;;;146        RCC->CSR|=0X1000000    ; //清除中断标示
000018  4811              LDR      r0,|L5.96|
00001a  6a40              LDR      r0,[r0,#0x24]
00001c  f0407080          ORR      r0,r0,#0x1000000
000020  490f              LDR      r1,|L5.96|
000022  6248              STR      r0,[r1,#0x24]
;;;147        
;;;148        //debug_usr("Train num : %02x%02x max_room_n:%d\r\n", Train.TrainNum[0], Train.TrainNum[1], Train.max_room_n );
;;;149        //printf("Train num : %02x%02x max_room_n:%d\r\n", Train.TrainNum[0], Train.TrainNum[1], Train.max_room_n );
;;;150        
;;;151        debug_usr("************************************\r\n");
000024  a00f              ADR      r0,|L5.100|
000026  f7fffffe          BL       debug_usr
;;;152        debug_usr("          推麻仪 IV型\r\n\r\n");
00002a  a018              ADR      r0,|L5.140|
00002c  f7fffffe          BL       debug_usr
;;;153        debug_usr("Version : %s\r\n", HW_VER);
000030  a11d              ADR      r1,|L5.168|
000032  a01f              ADR      r0,|L5.176|
000034  f7fffffe          BL       debug_usr
;;;154        //printf("ID : %c%d - %02d\r\n", Train.TrainType, ( ( ( (uint16_t)Train.TrainNum[0]) << 8 ) + Train.TrainNum[1]), Train.max_room_n );
;;;155        //printf("ID : %02x%02x - %d\r\n", Train.TrainNum[0], Train.TrainNum[1], Train.max_room_n );
;;;156        
;;;157        printf("************************************\r\n");
000038  a00a              ADR      r0,|L5.100|
00003a  f7fffffe          BL       __2printf
;;;158    }
00003e  bd10              POP      {r4,pc}
;;;159    
                          ENDP

                  |L5.64|
000040  706f7765          DCB      "power reset:",0
000044  72207265
000048  7365743a
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L5.80|
000050  6f746865          DCB      "other reset:",0
000054  72207265
000058  7365743a
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0
                  |L5.96|
                          DCD      0x40021000
                  |L5.100|
000064  2a2a2a2a          DCB      "************************************\r\n",0
000068  2a2a2a2a
00006c  2a2a2a2a
000070  2a2a2a2a
000074  2a2a2a2a
000078  2a2a2a2a
00007c  2a2a2a2a
000080  2a2a2a2a
000084  2a2a2a2a
000088  0d0a00  
00008b  00                DCB      0
                  |L5.140|
00008c  20202020          DCB      "          ",205,198,194,233,210,199," IV",208,205,"\r\n"
000090  20202020
000094  2020cdc6
000098  c2e9d2c7
00009c  204956d0
0000a0  cd0d0a  
0000a3  0d0a00            DCB      "\r\n",0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L5.168|
0000a8  56312e30          DCB      "V1.0.0",0
0000ac  2e3000  
0000af  00                DCB      0
                  |L5.176|
0000b0  56657273          DCB      "Version : %s\r\n",0
0000b4  696f6e20
0000b8  3a202573
0000bc  0d0a00  
0000bf  00                DCB      0

                          AREA ||i.vTaskLCD||, CODE, READONLY, ALIGN=2

                  vTaskLCD PROC
;;;363    */
;;;364    static void vTaskLCD(void *pvParameters)
000000  f7fffffe          BL       ULCD_Init
;;;365    {      
;;;366    //    uint8_t err, tem8;
;;;367        
;;;368        ULCD_Init();
;;;369        printf( "vTaskLCD\r\n" );
000004  a006              ADR      r0,|L6.32|
000006  f7fffffe          BL       __2printf
;;;370        bsp_LedOff(1);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       bsp_LedOff
;;;371        
;;;372        //vTaskDelay(pdMS_TO_TICKS(10000));
;;;373        
;;;374        //LCD_ParaInit( );
;;;375        
;;;376        while(1)
000010  e004              B        |L6.28|
                  |L6.18|
;;;377        {
;;;378            vTaskDelay(1);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       vTaskDelay
;;;379            ULCD_Task();
000018  f7fffffe          BL       ULCD_Task
                  |L6.28|
00001c  e7f9              B        |L6.18|
;;;380            
;;;381    //        if( lg_lcd_init == 1 )
;;;382    //        {
;;;383    //            //SetBuzzer(100);
;;;384    //            lg_lcd_init = 2;
;;;385    //            LCD_ParaInit();
;;;386    //            Tmy.State.bit.InitPara = 1;
;;;387    //        }
;;;388            
;;;389        }
;;;390    }
;;;391    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
000020  76546173          DCB      "vTaskLCD\r\n",0
000024  6b4c4344
000028  0d0a00  
00002b  00                DCB      0

                          AREA ||i.vTaskMotorCtrl||, CODE, READONLY, ALIGN=2

                  vTaskMotorCtrl PROC
;;;401    
;;;402    static void vTaskMotorCtrl(void *pvParameters)
000000  b508              PUSH     {r3,lr}
;;;403    {
;;;404        uint8_t key_v, tem8;
;;;405        //uint8_t  key_state, key_state_c;
;;;406        uint8_t count_init_down;
;;;407        
;;;408        uint8_t dg_sta_c;
;;;409        uint8_t lg_zdgy = 0;//自动给药抬起标志，不回吸
000002  f04f0800          MOV      r8,#0
;;;410    	
;;;411        MOTOR_Init( 1000 );
000006  f44f707a          MOV      r0,#0x3e8
00000a  f7fffffe          BL       MOTOR_Init
;;;412        key_v = 0;
00000e  2600              MOVS     r6,#0
;;;413        MOTOR_SetDir( UP );
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       MOTOR_SetDir
;;;414        
;;;415        Motor.max_hx_step = 31495;
000016  f6473007          MOV      r0,#0x7b07
00001a  49fe              LDR      r1,|L7.1044|
00001c  6108              STR      r0,[r1,#0x10]  ; Motor
;;;416        
;;;417        count_init_down = 0;
00001e  2700              MOVS     r7,#0
;;;418        dev_sta = DEV_INIT;
000020  2000              MOVS     r0,#0
000022  49fd              LDR      r1,|L7.1048|
000024  7008              STRB     r0,[r1,#0]
;;;419        dg_sta = DG_INIT;
000026  2001              MOVS     r0,#1
000028  49fc              LDR      r1,|L7.1052|
00002a  7008              STRB     r0,[r1,#0]
;;;420        
;;;421        while(1)
00002c  e3bc              B        |L7.1960|
                  |L7.46|
;;;422        {
;;;423            vTaskDelay(2);
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       vTaskDelay
;;;424    		
;;;425    		key_v = bsp_GetKey();
000034  f7fffffe          BL       bsp_GetKey
000038  4606              MOV      r6,r0
;;;426            
;;;427            switch( key_v ) //
00003a  2e19              CMP      r6,#0x19
00003c  d002              BEQ      |L7.68|
00003e  2e1a              CMP      r6,#0x1a
000040  d164              BNE      |L7.268|
000042  e044              B        |L7.206|
                  |L7.68|
;;;428    		{
;;;429    		    case PEDAL_DOWN : //踩下脚踏，电机运行
;;;430    			
;;;431    				timer_pedal_up = 0;
000044  2000              MOVS     r0,#0
000046  49f6              LDR      r1,|L7.1056|
000048  7008              STRB     r0,[r1,#0]
;;;432    		        
;;;433    				if( dg_sta == DG_UP ) //顶杆上升期间
00004a  48f4              LDR      r0,|L7.1052|
00004c  7800              LDRB     r0,[r0,#0]  ; dg_sta
00004e  2806              CMP      r0,#6
000050  d13c              BNE      |L7.204|
;;;434    		        {   
;;;435    					//自动给药情况下，踩下脚踏，不做任何动作，等到抬起再停止
;;;436    					if( Tmy.State.bit.zdgy )
000052  48f4              LDR      r0,|L7.1060|
000054  7980              LDRB     r0,[r0,#6]  ; Tmy
000056  f3c01080          UBFX     r0,r0,#6,#1
00005a  b170              CBZ      r0,|L7.122|
;;;437    					{
;;;438    					    timer_pedal_down = 1;
00005c  2001              MOVS     r0,#1
00005e  49f2              LDR      r1,|L7.1064|
000060  7008              STRB     r0,[r1,#0]
;;;439    					    Tmy.State.bit.zdgy = 0; //取消自动给药
000062  48f0              LDR      r0,|L7.1060|
000064  7980              LDRB     r0,[r0,#6]  ; Tmy
000066  f0200040          BIC      r0,r0,#0x40
00006a  49ee              LDR      r1,|L7.1060|
00006c  7188              STRB     r0,[r1,#6]
;;;440    					    //播放语音:自动给药取消？
;;;441    					    SetTextValue(0,26,"自动给药取消");
00006e  a2ef              ADR      r2,|L7.1068|
000070  211a              MOVS     r1,#0x1a
000072  2000              MOVS     r0,#0
000074  f7fffffe          BL       SetTextValue
000078  e028              B        |L7.204|
                  |L7.122|
;;;442    					    
;;;443    					}else //非自动给药
;;;444    					{
;;;445        					timer_pedal_down = 1;
00007a  2001              MOVS     r0,#1
00007c  49ea              LDR      r1,|L7.1064|
00007e  7008              STRB     r0,[r1,#0]
;;;446        					//Tmy.State.bit.zdgy = 0;//取消自动给药
;;;447        					
;;;448            	            Motor.speed++;
000080  48e4              LDR      r0,|L7.1044|
000082  7800              LDRB     r0,[r0,#0]  ; Motor
000084  1c40              ADDS     r0,r0,#1
000086  49e3              LDR      r1,|L7.1044|
000088  7008              STRB     r0,[r1,#0]
;;;449            	            if( Motor.speed > 3 ) 
00008a  4608              MOV      r0,r1
00008c  7800              LDRB     r0,[r0,#0]  ; Motor
00008e  2803              CMP      r0,#3
000090  dd01              BLE      |L7.150|
;;;450            	            {
;;;451            	                Motor.speed = 1;
000092  2001              MOVS     r0,#1
000094  7008              STRB     r0,[r1,#0]
                  |L7.150|
;;;452            	            }
;;;453            	            
;;;454            	            tem8 = MOTOR_SPEED_INDEX[Motor.gear][Motor.speed-1];
000096  48df              LDR      r0,|L7.1044|
000098  7840              LDRB     r0,[r0,#1]  ; Motor
00009a  eb000040          ADD      r0,r0,r0,LSL #1
00009e  49e7              LDR      r1,|L7.1084|
0000a0  eb010140          ADD      r1,r1,r0,LSL #1
0000a4  48db              LDR      r0,|L7.1044|
0000a6  7800              LDRB     r0,[r0,#0]  ; Motor
0000a8  1e40              SUBS     r0,r0,#1
0000aa  f8115010          LDRB     r5,[r1,r0,LSL #1]
;;;455            	            Tmy.speed = tem8;
0000ae  48dd              LDR      r0,|L7.1060|
0000b0  7105              STRB     r5,[r0,#4]
;;;456            	             
;;;457            	            MOTOR_SetSpeed( MOTOR_SPEED_CYCLE[tem8] ); //设置电机速度
0000b2  49e3              LDR      r1,|L7.1088|
0000b4  f8310015          LDRH     r0,[r1,r5,LSL #1]
0000b8  f7fffffe          BL       MOTOR_SetSpeed
;;;458            	            SetTextValue(0, 16, &MOTOR_SPEED_DISPLAY[tem8][0]); 
0000bc  eb0500c5          ADD      r0,r5,r5,LSL #3
0000c0  49e0              LDR      r1,|L7.1092|
0000c2  1842              ADDS     r2,r0,r1
0000c4  2110              MOVS     r1,#0x10
0000c6  2000              MOVS     r0,#0
0000c8  f7fffffe          BL       SetTextValue
                  |L7.204|
;;;459            	            //SetTextInt32(0, 17, MOTOR_SPEED_CYCLE[tem8], 0, 1);
;;;460            	            //Tmy.work_state = STA_MOVE;
;;;461    					}
;;;462    		        }
;;;463    		        
;;;464    		        break;
0000cc  e01f              B        |L7.270|
                  |L7.206|
;;;465    		    case PEDAL_UP : //抬起脚踏
;;;466    			
;;;467    				timer_pedal_down = 0;
0000ce  2000              MOVS     r0,#0
0000d0  49d5              LDR      r1,|L7.1064|
0000d2  7008              STRB     r0,[r1,#0]
;;;468    				
;;;469    		        if( dg_sta == DG_UP ) //顶杆上升期间
0000d4  48d1              LDR      r0,|L7.1052|
0000d6  7800              LDRB     r0,[r0,#0]  ; dg_sta
0000d8  2806              CMP      r0,#6
0000da  d116              BNE      |L7.266|
;;;470    		        {
;;;471    					if( Tmy.State.bit.zdgy ) //自动给药
0000dc  48d1              LDR      r0,|L7.1060|
0000de  7980              LDRB     r0,[r0,#6]  ; Tmy
0000e0  f3c01080          UBFX     r0,r0,#6,#1
0000e4  b988              CBNZ     r0,|L7.266|
;;;472        		        {
;;;473    						;//自动给药
;;;474    					}else //非自动给药
;;;475    					{
;;;476    						//Motor.speed = 0;
;;;477    						MOTOR_Stop(); //电机停止
0000e6  f7fffffe          BL       MOTOR_Stop
;;;478    						timer_pedal_up = 1;//启动脚踏抬起计时
0000ea  2001              MOVS     r0,#1
0000ec  49cc              LDR      r1,|L7.1056|
0000ee  7008              STRB     r0,[r1,#0]
;;;479    						
;;;480    						SetTextValue(0, 16,"停止\x00");
0000f0  a2d5              ADR      r2,|L7.1096|
0000f2  2110              MOVS     r1,#0x10
0000f4  2000              MOVS     r0,#0
0000f6  f7fffffe          BL       SetTextValue
;;;481    						SetTextInt32(0, 17, 0, 0, 1);
0000fa  2001              MOVS     r0,#1
0000fc  2300              MOVS     r3,#0
0000fe  461a              MOV      r2,r3
000100  2111              MOVS     r1,#0x11
000102  9000              STR      r0,[sp,#0]
000104  4618              MOV      r0,r3
000106  f7fffffe          BL       SetTextInt32
                  |L7.266|
;;;482    						//Tmy.work_state = STA_IDLE;
;;;483    					}
;;;484        	        }
;;;485    	            break;
00010a  e000              B        |L7.270|
                  |L7.268|
;;;486    //		    case ZERO_UNDETECT : //
;;;487    //		        Motor.state.bit.zero = 0;
;;;488    //		        SetTextValue(0,18,"未触底");
;;;489    //		        break;
;;;490    //	        case ZERO_DETECT : //
;;;491    //	            Motor.state.bit.zero = 1;
;;;492    //		        MOTOR_Stop();
;;;493    //		        Motor.counter_step = 0;
;;;494    //		        SetTextValue(0,18,"已触底");
;;;495    //		    case SYRINGE_UNDETECT : //
;;;496    ////		        Motor.state.bit.zero = 0;
;;;497    //		        //SetTextValue(0,18,"1.8ml");
;;;498    //		        break;
;;;499    //	        case SYRINGE_DETECT : //
;;;500    ////	            Motor.state.bit.zero = 1;
;;;501    ////		        MOTOR_Stop();
;;;502    ////		        Motor.counter_step = 0;
;;;503    //		        //SetTextValue(0,18,"2.2ml");
;;;504    //		        break;
;;;505    //	             
;;;506    		    default : break;
00010c  bf00              NOP      
                  |L7.270|
00010e  bf00              NOP                            ;464
;;;507    		}
;;;508            
;;;509    		if( dg_sta == DG_UP ) //顶杆上升期间
000110  48c2              LDR      r0,|L7.1052|
000112  7800              LDRB     r0,[r0,#0]  ; dg_sta
000114  2806              CMP      r0,#6
000116  d165              BNE      |L7.484|
;;;510    		{
;;;511    			// if( timer_pedal_up > DLY_PEDAL_UP_MOTOR_STOP ) //抬起脚踏时间大于 DLY_PEDAL_UP_MOTOR_STOP 秒
;;;512    			// {
;;;513    				// timer_pedal_up = 0;
;;;514    				// Motor.speed = 0; //恢复速度
;;;515    				// if( Tmy.Key.hx )//&& (!Motor.state.bit.dir) )//回吸模式有效 Motor.state.bit.dir
;;;516    				// {
;;;517    					// if(!lg_zdgy) //非自动给药
;;;518    					// {
;;;519    						// lg_zdgy = 0;//自动给药抬起标志，取消
;;;520    						// if( ( Tmy.speed == SLOWEST )   //慢慢速
;;;521    						 // || ( Tmy.speed == SLOW    ) ) //常慢速
;;;522    						// {
;;;523    							// Motor.counter_hx_step = Motor.counter_step - Motor.max_hx_step;
;;;524    							// dg_sta = DG_HX_DOWN;//
;;;525    						// }
;;;526    					// }
;;;527    				// }
;;;528    			// }
;;;529    			//回吸判断
;;;530    			if( ( Tmy.speed == SLOWEST )   //慢慢速
000118  48c2              LDR      r0,|L7.1060|
00011a  7900              LDRB     r0,[r0,#4]  ; Tmy
00011c  b118              CBZ      r0,|L7.294|
;;;531    			 || ( Tmy.speed == SLOW    ) ) //常慢速
00011e  48c1              LDR      r0,|L7.1060|
000120  7900              LDRB     r0,[r0,#4]  ; Tmy
000122  2801              CMP      r0,#1
000124  d125              BNE      |L7.370|
                  |L7.294|
;;;532    			{
;;;533    				if( timer_pedal_up > DLY_PEDAL_UP_MOTOR_STOP ) //抬起脚踏时间大于 DLY_PEDAL_UP_MOTOR_STOP 秒
000126  48be              LDR      r0,|L7.1056|
000128  7800              LDRB     r0,[r0,#0]  ; timer_pedal_up
00012a  2802              CMP      r0,#2
00012c  dd21              BLE      |L7.370|
;;;534    				{
;;;535    					timer_pedal_up = 0;
00012e  2000              MOVS     r0,#0
000130  49bb              LDR      r1,|L7.1056|
000132  7008              STRB     r0,[r1,#0]
;;;536    					Motor.speed = 0; //恢复速度
000134  49b7              LDR      r1,|L7.1044|
000136  7008              STRB     r0,[r1,#0]
;;;537    					if( Tmy.Key.hx ) //回吸模式有效
000138  48ba              LDR      r0,|L7.1060|
00013a  7940              LDRB     r0,[r0,#5]  ; Tmy
00013c  f0000001          AND      r0,r0,#1
000140  b1b8              CBZ      r0,|L7.370|
;;;538    					{
;;;539    						if(!lg_zdgy) //非自动给药
000142  f1b80f00          CMP      r8,#0
000146  d114              BNE      |L7.370|
;;;540    						{
;;;541    							lg_zdgy = 0;//自动给药抬起标志，取消
000148  f04f0800          MOV      r8,#0
;;;542    							
;;;543    							//判断回吸距离，此处可判断大于STEP_HX_ENABLE距离才可以回吸，STEP_HX_ENABLE默认0
;;;544    							if( Motor.counter_step > ( Motor.max_hx_step + STEP_HX_ENABLE ) ) //有效距离
00014c  4608              MOV      r0,r1
00014e  6841              LDR      r1,[r0,#4]  ; Motor
000150  6900              LDR      r0,[r0,#0x10]  ; Motor
000152  4281              CMP      r1,r0
000154  d907              BLS      |L7.358|
;;;545    							{
;;;546    								Motor.counter_hx_step = Motor.counter_step - Motor.max_hx_step; 
000156  48af              LDR      r0,|L7.1044|
000158  6840              LDR      r0,[r0,#4]  ; Motor
00015a  49ae              LDR      r1,|L7.1044|
00015c  6909              LDR      r1,[r1,#0x10]  ; Motor
00015e  1a40              SUBS     r0,r0,r1
000160  49ac              LDR      r1,|L7.1044|
000162  60c8              STR      r0,[r1,#0xc]  ; Motor
000164  e002              B        |L7.364|
                  |L7.358|
;;;547    							}else //判断回吸距离不够的情况，最低触底
;;;548    							{
;;;549    								Motor.counter_hx_step = 0;
000166  2000              MOVS     r0,#0
000168  49aa              LDR      r1,|L7.1044|
00016a  60c8              STR      r0,[r1,#0xc]  ; Motor
                  |L7.364|
;;;550    							}
;;;551    							dg_sta = DG_HX_DOWN;//进入回吸
00016c  200b              MOVS     r0,#0xb
00016e  49ab              LDR      r1,|L7.1052|
000170  7008              STRB     r0,[r1,#0]
                  |L7.370|
;;;552    						}
;;;553    					}
;;;554    				}
;;;555    			}
;;;556    			
;;;557    			//自动给药判断
;;;558    			if( ( Tmy.speed == SLOWEST )   //慢慢速
000172  48ac              LDR      r0,|L7.1060|
000174  7900              LDRB     r0,[r0,#4]  ; Tmy
000176  b118              CBZ      r0,|L7.384|
;;;559    			 || ( Tmy.speed == SLOW    ) ) //常慢速
000178  48aa              LDR      r0,|L7.1060|
00017a  7900              LDRB     r0,[r0,#4]  ; Tmy
00017c  2801              CMP      r0,#1
00017e  d131              BNE      |L7.484|
                  |L7.384|
;;;560    			{
;;;561    				if( ( !Tmy.State.bit.zdgy ) && ( timer_pedal_down > TIME_ZDGY_ENABLE ) ) //踩下脚踏时间大于TIME_CRUISE_START秒
000180  48a8              LDR      r0,|L7.1060|
000182  7980              LDRB     r0,[r0,#6]  ; Tmy
000184  f3c01080          UBFX     r0,r0,#6,#1
000188  b9a0              CBNZ     r0,|L7.436|
00018a  48a7              LDR      r0,|L7.1064|
00018c  7800              LDRB     r0,[r0,#0]  ; timer_pedal_down
00018e  2805              CMP      r0,#5
000190  dd10              BLE      |L7.436|
;;;562    				{
;;;563    					Tmy.State.bit.zdgy = 1; //进入自动给药
000192  48a4              LDR      r0,|L7.1060|
000194  7980              LDRB     r0,[r0,#6]  ; Tmy
000196  f0200040          BIC      r0,r0,#0x40
00019a  3040              ADDS     r0,r0,#0x40
00019c  49a1              LDR      r1,|L7.1060|
00019e  7188              STRB     r0,[r1,#6]
;;;564    					SetTextValue(0,26,"自动给药...");
0001a0  a2ab              ADR      r2,|L7.1104|
0001a2  211a              MOVS     r1,#0x1a
0001a4  2000              MOVS     r0,#0
0001a6  f7fffffe          BL       SetTextValue
;;;565    					PlayMusic("a:/sounds/zdgy.mp3"); ////播放语音:自动给药
0001aa  a0ac              ADR      r0,|L7.1116|
0001ac  f7fffffe          BL       PlayMusic
;;;566    					//如果2秒内，抬脚，自动给药
;;;567    					//如果2秒内，没有抬脚，不进自动给药
;;;568    					lg_zdgy = 1;//自动给药抬起标志，不回吸
0001b0  f04f0801          MOV      r8,#1
                  |L7.436|
;;;569    				}
;;;570    				
;;;571    				if( ( Tmy.State.bit.zdgy ) && ( timer_pedal_down > TIME_ZDGY_CANCLE ) ) //踩下脚踏时间大于5秒
0001b4  489b              LDR      r0,|L7.1060|
0001b6  7980              LDRB     r0,[r0,#6]  ; Tmy
0001b8  f3c01080          UBFX     r0,r0,#6,#1
0001bc  b190              CBZ      r0,|L7.484|
0001be  489a              LDR      r0,|L7.1064|
0001c0  7800              LDRB     r0,[r0,#0]  ; timer_pedal_down
0001c2  2807              CMP      r0,#7
0001c4  dd0e              BLE      |L7.484|
;;;572    				{
;;;573    					Tmy.State.bit.zdgy = 0;//取消自动给药
0001c6  4897              LDR      r0,|L7.1060|
0001c8  7980              LDRB     r0,[r0,#6]  ; Tmy
0001ca  f0200040          BIC      r0,r0,#0x40
0001ce  4995              LDR      r1,|L7.1060|
0001d0  7188              STRB     r0,[r1,#6]
;;;574    					timer_pedal_down = 0;
0001d2  2000              MOVS     r0,#0
0001d4  4994              LDR      r1,|L7.1064|
0001d6  7008              STRB     r0,[r1,#0]
;;;575    					SetTextValue(0,26,"自动给药取消");
0001d8  a294              ADR      r2,|L7.1068|
0001da  211a              MOVS     r1,#0x1a
0001dc  f7fffffe          BL       SetTextValue
;;;576    					//播放语音:自动给药取消xxx
;;;577    					//如果2秒内，抬脚，自动给药
;;;578    					//如果2秒内，没有抬脚，不进自动给药
;;;579    					lg_zdgy = 0;//自动给药抬起标志，取消
0001e0  f04f0800          MOV      r8,#0
                  |L7.484|
;;;580    				}
;;;581    			}
;;;582    		}
;;;583    		
;;;584    		//紧急制动功能有待完善
;;;585    //		if( Tmy.Key.jjzd ) //紧急制动
;;;586    //		{
;;;587    //			MOTOR_Stop();//步进电机停止
;;;588    //			Tmy.Motor.state = MOTOR_STOP;//更改步进电机状态
;;;589    //			dg_sta = DG_STOP;
;;;590    //		}
;;;591    		
;;;592            switch( dg_sta )
0001e4  488d              LDR      r0,|L7.1052|
0001e6  7800              LDRB     r0,[r0,#0]  ; dg_sta
0001e8  2810              CMP      r0,#0x10
0001ea  d27c              BCS      |L7.742|
0001ec  e8dff000          TBB      [pc,r0]
0001f0  c8082a4d          DCB      0xc8,0x08,0x2a,0x4d
0001f4  fd9ffcfb          DCB      0xfd,0x9f,0xfc,0xfb
0001f8  e4faf9f8          DCB      0xe4,0xfa,0xf9,0xf8
0001fc  7b7bf7f6          DCB      0x7b,0x7b,0xf7,0xf6
;;;593            {
;;;594                case DG_INIT : //上电，参数初始化
;;;595                    if( dg_sta_c != dg_sta )
000200  4886              LDR      r0,|L7.1052|
000202  7800              LDRB     r0,[r0,#0]  ; dg_sta
000204  4284              CMP      r4,r0
000206  d001              BEQ      |L7.524|
;;;596                    {
;;;597                        dg_sta_c = dg_sta;
000208  4884              LDR      r0,|L7.1052|
00020a  7804              LDRB     r4,[r0,#0]  ; dg_sta
                  |L7.524|
;;;598                        //SetTextValue(0,26,"初始化...");
;;;599                    }
;;;600                    
;;;601                    if( !Tmy.State.bit.InitPara ) //参数尚未初始化
00020c  4885              LDR      r0,|L7.1060|
00020e  7980              LDRB     r0,[r0,#6]  ; Tmy
000210  f0000001          AND      r0,r0,#1
000214  b968              CBNZ     r0,|L7.562|
;;;602                    {
;;;603                        if( lg_lcd_init == 1 )
000216  4896              LDR      r0,|L7.1136|
000218  7800              LDRB     r0,[r0,#0]  ; lg_lcd_init
00021a  2801              CMP      r0,#1
00021c  d111              BNE      |L7.578|
;;;604                        {
;;;605                            //lg_lcd_init = 2;
;;;606                            LCD_ParaInit();
00021e  f7fffffe          BL       LCD_ParaInit
;;;607                            Tmy.State.bit.InitPara = 1;
000222  4880              LDR      r0,|L7.1060|
000224  7980              LDRB     r0,[r0,#6]  ; Tmy
000226  f0200001          BIC      r0,r0,#1
00022a  1c40              ADDS     r0,r0,#1
00022c  497d              LDR      r1,|L7.1060|
00022e  7188              STRB     r0,[r1,#6]
000230  e007              B        |L7.578|
                  |L7.562|
;;;608                        }
;;;609                        //Tmy.State.bit.InitPara = 1;
;;;610                    }else //参数初始化完成
;;;611                    {
;;;612                        SetTextValue(0,26,"LCD初始化完成。");
000232  a290              ADR      r2,|L7.1140|
000234  211a              MOVS     r1,#0x1a
000236  2000              MOVS     r0,#0
000238  f7fffffe          BL       SetTextValue
;;;613                        dg_sta = DG_INIT_DOWN;//顶杆归零
00023c  2003              MOVS     r0,#3
00023e  4977              LDR      r1,|L7.1052|
000240  7008              STRB     r0,[r1,#0]
                  |L7.578|
;;;614                    }
;;;615                    
;;;616                    break;
000242  e2b0              B        |L7.1958|
;;;617                
;;;618                case DG_INIT_UP : //上电初始化过程，顶杆不在零位，先归零，然后再先上升一小段再归零
;;;619                    
;;;620                    if( dg_sta_c != dg_sta )
000244  4875              LDR      r0,|L7.1052|
000246  7800              LDRB     r0,[r0,#0]  ; dg_sta
000248  4284              CMP      r4,r0
00024a  d006              BEQ      |L7.602|
;;;621                    {
;;;622                        dg_sta_c = dg_sta;
00024c  4873              LDR      r0,|L7.1052|
00024e  7804              LDRB     r4,[r0,#0]  ; dg_sta
;;;623                        SetTextValue(0,26,"检测归零传感器,上升...");
000250  a28c              ADR      r2,|L7.1156|
000252  211a              MOVS     r1,#0x1a
000254  2000              MOVS     r0,#0
000256  f7fffffe          BL       SetTextValue
                  |L7.602|
;;;624                    }
;;;625                    
;;;626                    if( !Tmy.Sensor.bit.bottom )//检测离开底部
00025a  4872              LDR      r0,|L7.1060|
00025c  79c0              LDRB     r0,[r0,#7]  ; Tmy
00025e  f0000001          AND      r0,r0,#1
000262  b910              CBNZ     r0,|L7.618|
;;;627                    {
;;;628                        dg_sta = DG_INIT_DOWN;//再次复位
000264  2003              MOVS     r0,#3
000266  496d              LDR      r1,|L7.1052|
000268  7008              STRB     r0,[r1,#0]
                  |L7.618|
;;;629                    }
;;;630                    
;;;631                    if( Tmy.Motor.state != MOTOR_UP ) //步进电机不是在上升
00026a  486e              LDR      r0,|L7.1060|
00026c  7800              LDRB     r0,[r0,#0]  ; Tmy
00026e  2801              CMP      r0,#1
000270  d00a              BEQ      |L7.648|
;;;632                    {
;;;633                        MOTOR_Stop();//步进电机停止
000272  f7fffffe          BL       MOTOR_Stop
;;;634                        MOTOR_SetDir( UP );//方向上升
000276  2000              MOVS     r0,#0
000278  f7fffffe          BL       MOTOR_SetDir
;;;635                        MOTOR_SetSpeed( CYCLE_HX ); //设置电机速度 XXX
00027c  2086              MOVS     r0,#0x86
00027e  f7fffffe          BL       MOTOR_SetSpeed
;;;636                        Tmy.Motor.state = MOTOR_UP;//更改步进电机状态
000282  2001              MOVS     r0,#1
000284  4967              LDR      r1,|L7.1060|
000286  7008              STRB     r0,[r1,#0]
                  |L7.648|
;;;637                    }else //步进电机在上升
;;;638                    {
;;;639    //                    if( key_v == PEDAL_UP )//检测到脚踏抬起
;;;640    //                    {
;;;641    //                        dg_sta = DG_STOP;//停止
;;;642    //                    }
;;;643                    }
;;;644                    
;;;645                    break;
000288  e28d              B        |L7.1958|
;;;646                case DG_INIT_DOWN : //上电初始化过程，顶杆不在零位，先归零，然后再先上升一小段再归零
;;;647                    
;;;648                    if( dg_sta_c != dg_sta )
00028a  4864              LDR      r0,|L7.1052|
00028c  7800              LDRB     r0,[r0,#0]  ; dg_sta
00028e  4284              CMP      r4,r0
000290  d006              BEQ      |L7.672|
;;;649                    {
;;;650                        dg_sta_c = dg_sta;
000292  4862              LDR      r0,|L7.1052|
000294  7804              LDRB     r4,[r0,#0]  ; dg_sta
;;;651                        SetTextValue(0,26,"顶杆归零...");
000296  a281              ADR      r2,|L7.1180|
000298  211a              MOVS     r1,#0x1a
00029a  2000              MOVS     r0,#0
00029c  f7fffffe          BL       SetTextValue
                  |L7.672|
;;;652                    }
;;;653                    
;;;654                    if( key_v == ZERO_DETECT )//检测到触底
0002a0  2e1d              CMP      r6,#0x1d
0002a2  d10f              BNE      |L7.708|
;;;655                    {
;;;656                        Tmy.Sensor.bit.bottom = 1;
0002a4  485f              LDR      r0,|L7.1060|
0002a6  79c0              LDRB     r0,[r0,#7]  ; Tmy
0002a8  f0200001          BIC      r0,r0,#1
0002ac  1c40              ADDS     r0,r0,#1
0002ae  495d              LDR      r1,|L7.1060|
0002b0  71c8              STRB     r0,[r1,#7]
;;;657        		        MOTOR_Stop();
0002b2  f7fffffe          BL       MOTOR_Stop
;;;658        		        Motor.counter_step = 0;
0002b6  2000              MOVS     r0,#0
0002b8  4956              LDR      r1,|L7.1044|
0002ba  6048              STR      r0,[r1,#4]  ; Motor
;;;659        		        SetTextValue(0,18,"已触底");
0002bc  a27a              ADR      r2,|L7.1192|
0002be  2112              MOVS     r1,#0x12
0002c0  f7fffffe          BL       SetTextValue
                  |L7.708|
;;;660                    }
;;;661                    
;;;662                    if( Tmy.Sensor.bit.bottom )//到达底部
0002c4  4857              LDR      r0,|L7.1060|
0002c6  79c0              LDRB     r0,[r0,#7]  ; Tmy
0002c8  f0000001          AND      r0,r0,#1
0002cc  b1f8              CBZ      r0,|L7.782|
;;;663                    {
;;;664                        if( !count_init_down ) //第一次触底
0002ce  b95f              CBNZ     r7,|L7.744|
;;;665                        {
;;;666                            SetTextValue(0,26,"已触底");
0002d0  a275              ADR      r2,|L7.1192|
0002d2  211a              MOVS     r1,#0x1a
0002d4  2000              MOVS     r0,#0
0002d6  f7fffffe          BL       SetTextValue
;;;667                            count_init_down++;
0002da  1c78              ADDS     r0,r7,#1
0002dc  b2c7              UXTB     r7,r0
;;;668                            dg_sta = DG_INIT_UP;//上升一段
0002de  2002              MOVS     r0,#2
0002e0  494e              LDR      r1,|L7.1052|
0002e2  7008              STRB     r0,[r1,#0]
0002e4  e022              B        |L7.812|
                  |L7.742|
0002e6  e25d              B        |L7.1956|
                  |L7.744|
;;;669                        }else //第二次触底
;;;670                        {
;;;671                            SetBuzzer(100);
0002e8  2064              MOVS     r0,#0x64
0002ea  f7fffffe          BL       SetBuzzer
;;;672                            SetTextValue(0,26,"顶杆归零完成");
0002ee  a270              ADR      r2,|L7.1200|
0002f0  211a              MOVS     r1,#0x1a
0002f2  2000              MOVS     r0,#0
0002f4  f7fffffe          BL       SetTextValue
;;;673                            Tmy.State.bit.init = 1; //初始化完成
0002f8  484a              LDR      r0,|L7.1060|
0002fa  7980              LDRB     r0,[r0,#6]  ; Tmy
0002fc  f0200002          BIC      r0,r0,#2
000300  1c80              ADDS     r0,r0,#2
000302  4948              LDR      r1,|L7.1060|
000304  7188              STRB     r0,[r1,#6]
;;;674                            dg_sta = DG_STOP_BOT;//停在底部
000306  2005              MOVS     r0,#5
000308  4944              LDR      r1,|L7.1052|
00030a  7008              STRB     r0,[r1,#0]
00030c  e00e              B        |L7.812|
                  |L7.782|
;;;675                            //dev_sta = DEV_STANDBY;//设备待机  
;;;676                        }
;;;677                        
;;;678                    }else //未到达底部
;;;679                    {
;;;680                        if( Tmy.Motor.state != MOTOR_DOWN ) //步进电机不是在下降
00030e  4845              LDR      r0,|L7.1060|
000310  7800              LDRB     r0,[r0,#0]  ; Tmy
000312  2802              CMP      r0,#2
000314  d00a              BEQ      |L7.812|
;;;681                        {
;;;682                            MOTOR_Stop();//步进电机停止
000316  f7fffffe          BL       MOTOR_Stop
;;;683                            MOTOR_SetDir( DOWN );//方向下降
00031a  2001              MOVS     r0,#1
00031c  f7fffffe          BL       MOTOR_SetDir
;;;684                            MOTOR_SetSpeed( CYCLE_HX ); //设置电机速度 XXX
000320  2086              MOVS     r0,#0x86
000322  f7fffffe          BL       MOTOR_SetSpeed
;;;685                            Tmy.Motor.state = MOTOR_DOWN;//更改步进电机状态
000326  2002              MOVS     r0,#2
000328  493e              LDR      r1,|L7.1060|
00032a  7008              STRB     r0,[r1,#0]
                  |L7.812|
;;;686                        }else //步进电机在下降
;;;687                        {
;;;688        //                    if( key_v == PEDAL_UP )//检测到脚踏抬起
;;;689        //                    {
;;;690        //                        dg_sta = DG_STOP;//停止
;;;691        //                    }
;;;692                        }
;;;693                    }
;;;694                    break;
00032c  e23b              B        |L7.1958|
;;;695                
;;;696                case DG_STOP_BOT : //停留在底部
;;;697                    //触底步数归零
;;;698                    MOTOR_ClrStep( );
00032e  f7fffffe          BL       MOTOR_ClrStep
;;;699                    
;;;700                    if( dg_sta_c != dg_sta )
000332  483a              LDR      r0,|L7.1052|
000334  7800              LDRB     r0,[r0,#0]  ; dg_sta
000336  4284              CMP      r4,r0
000338  d006              BEQ      |L7.840|
;;;701                    {
;;;702                        dg_sta_c = dg_sta;
00033a  4838              LDR      r0,|L7.1052|
00033c  7804              LDRB     r4,[r0,#0]  ; dg_sta
;;;703                        SetTextValue(0,26,"触底待机");
00033e  a260              ADR      r2,|L7.1216|
000340  211a              MOVS     r1,#0x1a
000342  2000              MOVS     r0,#0
000344  f7fffffe          BL       SetTextValue
                  |L7.840|
;;;704                    }
;;;705                    
;;;706                    if( Tmy.Motor.state != MOTOR_STOP ) //步进电机在运行
000348  4836              LDR      r0,|L7.1060|
00034a  7800              LDRB     r0,[r0,#0]  ; Tmy
00034c  b148              CBZ      r0,|L7.866|
;;;707                    {
;;;708                        MOTOR_Stop();//步进电机停止
00034e  f7fffffe          BL       MOTOR_Stop
;;;709                        MOTOR_SetDir( UP );//方向上升
000352  2000              MOVS     r0,#0
000354  f7fffffe          BL       MOTOR_SetDir
;;;710                        Tmy.Motor.state = MOTOR_STOP;//更改步进电机状态
000358  2000              MOVS     r0,#0
00035a  4932              LDR      r1,|L7.1060|
00035c  7008              STRB     r0,[r1,#0]
;;;711                        MOTOR_ClrStep( ); //步数清零
00035e  f7fffffe          BL       MOTOR_ClrStep
                  |L7.866|
;;;712                    }
;;;713                    
;;;714                    if( key_v == PEDAL_DOWN ) //检测到踩脚踏
000362  2e19              CMP      r6,#0x19
000364  d10b              BNE      |L7.894|
;;;715                    {
;;;716                        if( Tmy.Key.zdpk ) //自动排空
000366  482f              LDR      r0,|L7.1060|
000368  7940              LDRB     r0,[r0,#5]  ; Tmy
00036a  f3c00040          UBFX     r0,r0,#1,#1
00036e  b118              CBZ      r0,|L7.888|
;;;717                        {
;;;718                           // SetTextValue(0,26,"自动排空...");
;;;719                            dg_sta = DG_ZDPK_UP;//顶杆上升
000370  2008              MOVS     r0,#8
000372  492a              LDR      r1,|L7.1052|
000374  7008              STRB     r0,[r1,#0]
000376  e002              B        |L7.894|
                  |L7.888|
;;;720                        }else
;;;721                        //if( dev_sta == DEV_RUN )//设备运行状态
;;;722                        {
;;;723                            //SetTextValue(0,26,"顶杆上升...");
;;;724                            dg_sta = DG_UP;//顶杆上升
000378  2006              MOVS     r0,#6
00037a  4928              LDR      r1,|L7.1052|
00037c  7008              STRB     r0,[r1,#0]
                  |L7.894|
;;;725                        }
;;;726                    }
;;;727    //                if(  )//顶杆检查按键按下
;;;728    //                {
;;;729    //                    if( dev_sta == DEV_FIX )//顶杆检查
;;;730    //                    {
;;;731    //                        dg_sta = DG_FIX_UP;//顶杆检查上升
;;;732    //                    }
;;;733    //                }
;;;734                    
;;;735    //                if( key_v == PEDAL_DOWN )//检测到脚踏按下
;;;736    //                {
;;;737    //                    if( dev_sta == DEV_RUN )//设备运行状态
;;;738    //                    {
;;;739    //                        dg_sta = DG_UP;//顶杆上升
;;;740    //                    }else
;;;741    //                    if( dev_sta == DEV_FIX )//顶杆检查
;;;742    //                    {
;;;743    //                        dg_sta = DG_FIX_UP;//顶杆检查上升
;;;744    //                    }
;;;745    //                }
;;;746    
;;;747                    break;
00037e  e212              B        |L7.1958|
;;;748                        
;;;749                case DG_STOP : //停止
;;;750                    
;;;751                    if( dg_sta_c != dg_sta )
000380  4826              LDR      r0,|L7.1052|
000382  7800              LDRB     r0,[r0,#0]  ; dg_sta
000384  4284              CMP      r4,r0
000386  d006              BEQ      |L7.918|
;;;752                    {
;;;753                        dg_sta_c = dg_sta;
000388  4824              LDR      r0,|L7.1052|
00038a  7804              LDRB     r4,[r0,#0]  ; dg_sta
;;;754                        SetTextValue(0,26,"待机");
00038c  a24d              ADR      r2,|L7.1220|
00038e  211a              MOVS     r1,#0x1a
000390  2000              MOVS     r0,#0
000392  f7fffffe          BL       SetTextValue
                  |L7.918|
;;;755                    }
;;;756                    
;;;757                    if( Tmy.Motor.state != MOTOR_STOP ) //步进电机在运行
000396  4823              LDR      r0,|L7.1060|
000398  7800              LDRB     r0,[r0,#0]  ; Tmy
00039a  b120              CBZ      r0,|L7.934|
;;;758                    {
;;;759                        MOTOR_Stop();//步进电机停止
00039c  f7fffffe          BL       MOTOR_Stop
;;;760                        //MOTOR_SetDir( UP );//方向上升
;;;761                        Tmy.Motor.state = MOTOR_STOP;//更改步进电机状态
0003a0  2000              MOVS     r0,#0
0003a2  4920              LDR      r1,|L7.1060|
0003a4  7008              STRB     r0,[r1,#0]
                  |L7.934|
;;;762                        //MOTOR_ClrStep( ); //步数清零
;;;763                    }
;;;764                    
;;;765                    if( key_v == PEDAL_DOWN )//检测到脚踏按下
0003a6  2e19              CMP      r6,#0x19
0003a8  d105              BNE      |L7.950|
;;;766                    {
;;;767                        //if( dev_sta == DEV_RUN )//设备运行状态
;;;768                        {
;;;769                            timer_pedal_down = 1; //开始脚踏按下计时
0003aa  2001              MOVS     r0,#1
0003ac  491e              LDR      r1,|L7.1064|
0003ae  7008              STRB     r0,[r1,#0]
;;;770                            dg_sta = DG_UP;//顶杆上升
0003b0  2006              MOVS     r0,#6
0003b2  491a              LDR      r1,|L7.1052|
0003b4  7008              STRB     r0,[r1,#0]
                  |L7.950|
;;;771                        }
;;;772                    }//else
;;;773    //                if( key_v == PEDAL_DOWN )//检测复位键按下
;;;774    //                {
;;;775    //                    if( )//设备运行状态
;;;776    //                    {
;;;777    //                        dg_sta = DG_RESET_DOWN;//复位下降
;;;778    //                    }
;;;779    //                    ;
;;;780    //                }
;;;781                    break;
0003b6  e1f6              B        |L7.1958|
;;;782                    
;;;783                case DG_ZDPK_UP : //自动排空
;;;784                    
;;;785                    if( dg_sta_c != dg_sta )
0003b8  4818              LDR      r0,|L7.1052|
0003ba  7800              LDRB     r0,[r0,#0]  ; dg_sta
0003bc  4284              CMP      r4,r0
0003be  d006              BEQ      |L7.974|
;;;786                    {
;;;787                        dg_sta_c = dg_sta;
0003c0  4816              LDR      r0,|L7.1052|
0003c2  7804              LDRB     r4,[r0,#0]  ; dg_sta
;;;788                        SetTextValue(0,26,"自动排空...");
0003c4  a241              ADR      r2,|L7.1228|
0003c6  211a              MOVS     r1,#0x1a
0003c8  2000              MOVS     r0,#0
0003ca  f7fffffe          BL       SetTextValue
                  |L7.974|
;;;789                    }
;;;790                    
;;;791                    if( Motor.counter_step > STEP_MAX_ZDPK ) //到达自动排空步数
0003ce  4811              LDR      r0,|L7.1044|
0003d0  6840              LDR      r0,[r0,#4]  ; Motor
0003d2  f6487189          MOV      r1,#0x8f89
0003d6  4288              CMP      r0,r1
0003d8  d90b              BLS      |L7.1010|
;;;792                    {
;;;793                        dg_sta = DG_STOP;//电机停止
0003da  e007              B        |L7.1004|
0003dc  e1c7              B        |L7.1902|
0003de  e1a5              B        |L7.1836|
0003e0  e13a              B        |L7.1624|
0003e2  e177              B        |L7.1748|
0003e4  e078              B        |L7.1240|
0003e6  e10e              B        |L7.1542|
0003e8  e08e              B        |L7.1288|
0003ea  e0d9              B        |L7.1440|
                  |L7.1004|
0003ec  2000              MOVS     r0,#0
0003ee  490b              LDR      r1,|L7.1052|
0003f0  7008              STRB     r0,[r1,#0]
                  |L7.1010|
;;;794                    }
;;;795                    
;;;796                    if( Tmy.Motor.state != MOTOR_UP ) //步进电机不是在上升
0003f2  480c              LDR      r0,|L7.1060|
0003f4  7800              LDRB     r0,[r0,#0]  ; Tmy
0003f6  2801              CMP      r0,#1
0003f8  d00a              BEQ      |L7.1040|
;;;797                    {
;;;798                        MOTOR_Stop();//步进电机停止
0003fa  f7fffffe          BL       MOTOR_Stop
;;;799                        MOTOR_SetDir( UP );//方向上升
0003fe  2000              MOVS     r0,#0
000400  f7fffffe          BL       MOTOR_SetDir
;;;800                        MOTOR_SetSpeed( CYCLE_ZDPK ); //设置电机速
000404  2086              MOVS     r0,#0x86
000406  f7fffffe          BL       MOTOR_SetSpeed
;;;801                        Tmy.Motor.state = MOTOR_UP;//更改步进电机状态
00040a  2001              MOVS     r0,#1
00040c  4905              LDR      r1,|L7.1060|
00040e  7008              STRB     r0,[r1,#0]
                  |L7.1040|
;;;802                    }else //步进电机在上升
;;;803                    {
;;;804                        ;
;;;805                    }
;;;806                    
;;;807                    break;
000410  e1c9              B        |L7.1958|
000412  0000              DCW      0x0000
                  |L7.1044|
                          DCD      Motor
                  |L7.1048|
                          DCD      dev_sta
                  |L7.1052|
                          DCD      dg_sta
                  |L7.1056|
                          DCD      timer_pedal_up
                  |L7.1060|
                          DCD      Tmy
                  |L7.1064|
                          DCD      timer_pedal_down
                  |L7.1068|
00042c  d7d4b6af          DCB      215,212,182,175,184,248,210,169,200,161,207,251,0
000430  b8f8d2a9
000434  c8a1cffb
000438  00      
000439  00                DCB      0
00043a  00                DCB      0
00043b  00                DCB      0
                  |L7.1084|
                          DCD      MOTOR_SPEED_INDEX
                  |L7.1088|
                          DCD      MOTOR_SPEED_CYCLE
                  |L7.1092|
                          DCD      MOTOR_SPEED_DISPLAY
                  |L7.1096|
000448  cda3d6b9          DCB      205,163,214,185,0
00044c  00      
00044d  00                DCB      0
00044e  00                DCB      0
00044f  00                DCB      0
                  |L7.1104|
000450  d7d4b6af          DCB      215,212,182,175,184,248,210,169,"...",0
000454  b8f8d2a9
000458  2e2e2e00
                  |L7.1116|
00045c  613a2f73          DCB      "a:/sounds/zdgy.mp3",0
000460  6f756e64
000464  732f7a64
000468  67792e6d
00046c  703300  
00046f  00                DCB      0
                  |L7.1136|
                          DCD      lg_lcd_init
                  |L7.1140|
000474  4c4344b3          DCB      "LCD",179,245,202,188,187,175,205,234,179,201,161,163,0
000478  f5cabcbb
00047c  afcdeab3
000480  c9a1a300
                  |L7.1156|
000484  bcecb2e2          DCB      188,236,178,226,185,233,193,227,180,171,184,208,198,247,","
000488  b9e9c1e3
00048c  b4abb8d0
000490  c6f72c  
000493  c9cfc9fd          DCB      201,207,201,253,"...",0
000497  2e2e2e00
00049b  00                DCB      0
                  |L7.1180|
00049c  b6a5b8cb          DCB      182,165,184,203,185,233,193,227,"...",0
0004a0  b9e9c1e3
0004a4  2e2e2e00
                  |L7.1192|
0004a8  d2d1b4a5          DCB      210,209,180,165,181,215,0
0004ac  b5d700  
0004af  00                DCB      0
                  |L7.1200|
0004b0  b6a5b8cb          DCB      182,165,184,203,185,233,193,227,205,234,179,201,0
0004b4  b9e9c1e3
0004b8  cdeab3c9
0004bc  00      
0004bd  00                DCB      0
0004be  00                DCB      0
0004bf  00                DCB      0
                  |L7.1216|
0004c0  b4a5b5d7          DCB      180,165,181,215
                  |L7.1220|
0004c4  b4fdbbfa          DCB      180,253,187,250,0
0004c8  00      
0004c9  00                DCB      0
0004ca  00                DCB      0
0004cb  00                DCB      0
                  |L7.1228|
0004cc  d7d4b6af          DCB      215,212,182,175,197,197,191,213,"...",0
0004d0  c5c5bfd5
0004d4  2e2e2e00
                  |L7.1240|
;;;808                
;;;809                case DG_ECPK_UP : //二次排空
;;;810                    
;;;811                    if( Motor.counter_step > STEP_MAX_ECPK ) //到达自动排空步数
0004d8  48b4              LDR      r0,|L7.1964|
0004da  6840              LDR      r0,[r0,#4]  ; Motor
0004dc  f5b05f4d          CMP      r0,#0x3340
0004e0  d902              BLS      |L7.1256|
;;;812                    {
;;;813                        dg_sta = DG_STOP;//电机停止
0004e2  2000              MOVS     r0,#0
0004e4  49b2              LDR      r1,|L7.1968|
0004e6  7008              STRB     r0,[r1,#0]
                  |L7.1256|
;;;814                    }
;;;815                    
;;;816                    if( Tmy.Motor.state != MOTOR_UP ) //步进电机不是在上升
0004e8  48b2              LDR      r0,|L7.1972|
0004ea  7800              LDRB     r0,[r0,#0]  ; Tmy
0004ec  2801              CMP      r0,#1
0004ee  d00a              BEQ      |L7.1286|
;;;817                    {
;;;818                        MOTOR_Stop();//步进电机停止
0004f0  f7fffffe          BL       MOTOR_Stop
;;;819                        MOTOR_SetDir( UP );//方向上升
0004f4  2000              MOVS     r0,#0
0004f6  f7fffffe          BL       MOTOR_SetDir
;;;820                        MOTOR_SetSpeed( CYCLE_ZDPK ); //设置电机速度 XXX
0004fa  2086              MOVS     r0,#0x86
0004fc  f7fffffe          BL       MOTOR_SetSpeed
;;;821                        Tmy.Motor.state = MOTOR_UP;//更改步进电机状态
000500  2001              MOVS     r0,#1
000502  49ac              LDR      r1,|L7.1972|
000504  7008              STRB     r0,[r1,#0]
                  |L7.1286|
;;;822                    }else //步进电机在上升
;;;823                    {
;;;824                        ;
;;;825                    }
;;;826                    
;;;827                    break;
000506  e14e              B        |L7.1958|
                  |L7.1288|
;;;828                    
;;;829                case DG_UP : //顶杆上升
;;;830                    
;;;831                    if( dg_sta_c != dg_sta )
000508  48a9              LDR      r0,|L7.1968|
00050a  7800              LDRB     r0,[r0,#0]  ; dg_sta
00050c  4284              CMP      r4,r0
00050e  d006              BEQ      |L7.1310|
;;;832                    {
;;;833                        dg_sta_c = dg_sta;
000510  48a7              LDR      r0,|L7.1968|
000512  7804              LDRB     r4,[r0,#0]  ; dg_sta
;;;834                        SetTextValue(0,26,"顶杆上升...");
000514  a2a8              ADR      r2,|L7.1976|
000516  211a              MOVS     r1,#0x1a
000518  2000              MOVS     r0,#0
00051a  f7fffffe          BL       SetTextValue
                  |L7.1310|
;;;835                    }
;;;836                    
;;;837                    if( ( Motor.counter_step >= Motor.max_step ) //到达顶部
00051e  48a3              LDR      r0,|L7.1964|
000520  6840              LDR      r0,[r0,#4]  ; Motor
000522  49a2              LDR      r1,|L7.1964|
000524  6889              LDR      r1,[r1,#8]  ; Motor
000526  4288              CMP      r0,r1
000528  d204              BCS      |L7.1332|
;;;838                     || ( Tmy.Sensor.bit.top ) )
00052a  48a2              LDR      r0,|L7.1972|
00052c  79c0              LDRB     r0,[r0,#7]  ; Tmy
00052e  f3c00040          UBFX     r0,r0,#1,#1
000532  b128              CBZ      r0,|L7.1344|
                  |L7.1332|
;;;839                    {
;;;840                        MOTOR_Stop();//这个是冗余操作，多一次保护
000534  f7fffffe          BL       MOTOR_Stop
;;;841                        dg_sta = DG_STOP_TOP;//停留在顶部
000538  2004              MOVS     r0,#4
00053a  499d              LDR      r1,|L7.1968|
00053c  7008              STRB     r0,[r1,#0]
00053e  e02e              B        |L7.1438|
                  |L7.1344|
;;;842                    }else
;;;843                    {
;;;844                        if( Tmy.Motor.state != MOTOR_UP ) //步进电机未上升
000540  489c              LDR      r0,|L7.1972|
000542  7800              LDRB     r0,[r0,#0]  ; Tmy
000544  2801              CMP      r0,#1
000546  d02a              BEQ      |L7.1438|
;;;845                        {
;;;846                            Motor.speed = 1;
000548  2001              MOVS     r0,#1
00054a  4998              LDR      r1,|L7.1964|
00054c  7008              STRB     r0,[r1,#0]
;;;847                            tem8 = MOTOR_SPEED_INDEX[Motor.gear][Motor.speed-1];
00054e  4608              MOV      r0,r1
000550  7840              LDRB     r0,[r0,#1]  ; Motor
000552  eb000040          ADD      r0,r0,r0,LSL #1
000556  499b              LDR      r1,|L7.1988|
000558  eb010140          ADD      r1,r1,r0,LSL #1
00055c  4893              LDR      r0,|L7.1964|
00055e  7800              LDRB     r0,[r0,#0]  ; Motor
000560  1e40              SUBS     r0,r0,#1
000562  f8115010          LDRB     r5,[r1,r0,LSL #1]
;;;848            	            Tmy.speed = tem8;
000566  4893              LDR      r0,|L7.1972|
000568  7105              STRB     r5,[r0,#4]
;;;849            	             
;;;850            	            MOTOR_SetSpeed( MOTOR_SPEED_CYCLE[tem8] ); //设置电机速度
00056a  4997              LDR      r1,|L7.1992|
00056c  f8310015          LDRH     r0,[r1,r5,LSL #1]
000570  f7fffffe          BL       MOTOR_SetSpeed
;;;851            	            SetTextValue(0, 16, &MOTOR_SPEED_DISPLAY[tem8][0]); 
000574  eb0500c5          ADD      r0,r5,r5,LSL #3
000578  4994              LDR      r1,|L7.1996|
00057a  1842              ADDS     r2,r0,r1
00057c  2110              MOVS     r1,#0x10
00057e  2000              MOVS     r0,#0
000580  f7fffffe          BL       SetTextValue
;;;852        	            
;;;853                            MOTOR_Stop(); //电机暂停
000584  f7fffffe          BL       MOTOR_Stop
;;;854                            MOTOR_SetDir( UP ); //设置电机方向
000588  2000              MOVS     r0,#0
00058a  f7fffffe          BL       MOTOR_SetDir
;;;855                            MOTOR_SetSpeed( MOTOR_SPEED_CYCLE[tem8] ); //设置电机速度，运行
00058e  498e              LDR      r1,|L7.1992|
000590  f8310015          LDRH     r0,[r1,r5,LSL #1]
000594  f7fffffe          BL       MOTOR_SetSpeed
;;;856                            
;;;857                            //SetTextValue(0,18,"顶杆检查上升"); //更新提示
;;;858                        
;;;859                            Tmy.Motor.state = MOTOR_UP;//
000598  2001              MOVS     r0,#1
00059a  4986              LDR      r1,|L7.1972|
00059c  7008              STRB     r0,[r1,#0]
                  |L7.1438|
;;;860                        }
;;;861                    }
;;;862                    
;;;863    //                if( Tmy.Motor.state != MOTOR_UP ) //步进电机不是在上升
;;;864    //                {
;;;865    //                    MOTOR_Stop();//步进电机停止
;;;866    //                    MOTOR_SetDir( UP );//方向上升
;;;867    //                    MOTOR_SetSpeed( CYCLE_KSJ ); //设置电机速度 XXX
;;;868    //                    Tmy.Motor.state = MOTOR_UP;//更改步进电机状态
;;;869    //                }else //步进电机在上升
;;;870    //                {
;;;871    //                    if( key_v == PEDAL_UP )//检测到脚踏抬起
;;;872    //                    {
;;;873    //                        dg_sta = DG_STOP;//停止
;;;874    //                    }
;;;875    //                }
;;;876                    
;;;877                    break;
00059e  e102              B        |L7.1958|
                  |L7.1440|
;;;878                
;;;879                case DG_STOP_TOP : //停留在顶部
;;;880                    
;;;881                    if( dg_sta_c != dg_sta )
0005a0  4883              LDR      r0,|L7.1968|
0005a2  7800              LDRB     r0,[r0,#0]  ; dg_sta
0005a4  4284              CMP      r4,r0
0005a6  d006              BEQ      |L7.1462|
;;;882                    {
;;;883                        dg_sta_c = dg_sta;
0005a8  4881              LDR      r0,|L7.1968|
0005aa  7804              LDRB     r4,[r0,#0]  ; dg_sta
;;;884                        SetTextValue(0,26,"到顶停机待机");
0005ac  a288              ADR      r2,|L7.2000|
0005ae  211a              MOVS     r1,#0x1a
0005b0  2000              MOVS     r0,#0
0005b2  f7fffffe          BL       SetTextValue
                  |L7.1462|
;;;885                    }
;;;886                    
;;;887                    if( Tmy.Motor.state != MOTOR_STOP ) //步进电机在运行
0005b6  487f              LDR      r0,|L7.1972|
0005b8  7800              LDRB     r0,[r0,#0]  ; Tmy
0005ba  b138              CBZ      r0,|L7.1484|
;;;888                    {
;;;889                        MOTOR_Stop();//电机暂停
0005bc  f7fffffe          BL       MOTOR_Stop
;;;890                        MOTOR_SetDir( DOWN ); //方向下降
0005c0  2001              MOVS     r0,#1
0005c2  f7fffffe          BL       MOTOR_SetDir
;;;891                        Tmy.Motor.state = MOTOR_STOP;//更改电机状态
0005c6  2000              MOVS     r0,#0
0005c8  497a              LDR      r1,|L7.1972|
0005ca  7008              STRB     r0,[r1,#0]
                  |L7.1484|
;;;892                    }
;;;893                    
;;;894                    if( key_v == PEDAL_DOWN ) //检测到踩脚踏 // || ( key_v == PEDAL_DOWN ) ) //或 按复位键
0005cc  2e19              CMP      r6,#0x19
0005ce  d108              BNE      |L7.1506|
;;;895                    {
;;;896                        //if( dev_sta == DEV_RUN )//设备运行状态
;;;897                        {
;;;898                            SetTextValue(0,26,"顶杆归零...");
0005d0  f2af1238          ADR      r2,|L7.1180|
0005d4  211a              MOVS     r1,#0x1a
0005d6  2000              MOVS     r0,#0
0005d8  f7fffffe          BL       SetTextValue
;;;899                            dg_sta = DG_FIX_DOWN;//顶杆归零
0005dc  200f              MOVS     r0,#0xf
0005de  4974              LDR      r1,|L7.1968|
0005e0  7008              STRB     r0,[r1,#0]
                  |L7.1506|
;;;900                        }
;;;901                    }
;;;902                    
;;;903    				//if( 1 )//在xxx速度下，到顶后自动归零
;;;904    				if( ( Tmy.speed == NORMAL )   //中速
0005e2  4874              LDR      r0,|L7.1972|
0005e4  7900              LDRB     r0,[r0,#4]  ; Tmy
0005e6  2802              CMP      r0,#2
0005e8  d003              BEQ      |L7.1522|
;;;905    			     || ( Tmy.speed == FAST    ) ) //FAST
0005ea  4872              LDR      r0,|L7.1972|
0005ec  7900              LDRB     r0,[r0,#4]  ; Tmy
0005ee  2803              CMP      r0,#3
0005f0  d108              BNE      |L7.1540|
                  |L7.1522|
;;;906    				{
;;;907    					SetTextValue(0,26,"顶杆归零...");
0005f2  f2af1258          ADR      r2,|L7.1180|
0005f6  211a              MOVS     r1,#0x1a
0005f8  2000              MOVS     r0,#0
0005fa  f7fffffe          BL       SetTextValue
;;;908                        dg_sta = DG_FIX_DOWN;//顶杆归零
0005fe  200f              MOVS     r0,#0xf
000600  496b              LDR      r1,|L7.1968|
000602  7008              STRB     r0,[r1,#0]
                  |L7.1540|
;;;909    				}
;;;910    				
;;;911                    break;
000604  e0cf              B        |L7.1958|
                  |L7.1542|
;;;912                    
;;;913                case DG_DOWN : //顶杆下降 可能没有此状态！！！
;;;914                    
;;;915                    if( dg_sta_c != dg_sta )
000606  486a              LDR      r0,|L7.1968|
000608  7800              LDRB     r0,[r0,#0]  ; dg_sta
00060a  4284              CMP      r4,r0
00060c  d006              BEQ      |L7.1564|
;;;916                    {
;;;917                        dg_sta_c = dg_sta;
00060e  4868              LDR      r0,|L7.1968|
000610  7804              LDRB     r4,[r0,#0]  ; dg_sta
;;;918                        SetTextValue(0,26,"顶杆下降...");
000612  a273              ADR      r2,|L7.2016|
000614  211a              MOVS     r1,#0x1a
000616  2000              MOVS     r0,#0
000618  f7fffffe          BL       SetTextValue
                  |L7.1564|
;;;919                    }
;;;920                    
;;;921                    if(Tmy.Sensor.bit.bottom) //到达底部
00061c  4865              LDR      r0,|L7.1972|
00061e  79c0              LDRB     r0,[r0,#7]  ; Tmy
000620  f0000001          AND      r0,r0,#1
000624  b110              CBZ      r0,|L7.1580|
;;;922                    {
;;;923                        dg_sta = DG_STOP_TOP;//停留在底部
000626  2004              MOVS     r0,#4
000628  4961              LDR      r1,|L7.1968|
00062a  7008              STRB     r0,[r1,#0]
                  |L7.1580|
;;;924                    }
;;;925                    
;;;926                    if( Tmy.Motor.state != MOTOR_DOWN ) //步进电机不是在下降
00062c  4861              LDR      r0,|L7.1972|
00062e  7800              LDRB     r0,[r0,#0]  ; Tmy
000630  2802              CMP      r0,#2
000632  d00b              BEQ      |L7.1612|
;;;927                    {
;;;928                        MOTOR_Stop();//步进电机停止
000634  f7fffffe          BL       MOTOR_Stop
;;;929                        MOTOR_SetDir( DOWN );//方向上升
000638  2001              MOVS     r0,#1
00063a  f7fffffe          BL       MOTOR_SetDir
;;;930                        MOTOR_SetSpeed( CYCLE_DGJC ); //设置电机速度 XXX
00063e  2026              MOVS     r0,#0x26
000640  f7fffffe          BL       MOTOR_SetSpeed
;;;931                        Tmy.Motor.state = MOTOR_DOWN;//更改步进电机状态
000644  2002              MOVS     r0,#2
000646  495b              LDR      r1,|L7.1972|
000648  7008              STRB     r0,[r1,#0]
00064a  e004              B        |L7.1622|
                  |L7.1612|
;;;932                    }else //步进电机在下降
;;;933                    {
;;;934                        if( key_v == PEDAL_UP )//检测到脚踏抬起
00064c  2e1a              CMP      r6,#0x1a
00064e  d102              BNE      |L7.1622|
;;;935                        {
;;;936                            dg_sta = DG_STOP;//停止
000650  2000              MOVS     r0,#0
000652  4957              LDR      r1,|L7.1968|
000654  7008              STRB     r0,[r1,#0]
                  |L7.1622|
;;;937                        }
;;;938                    }
;;;939                    break;
000656  e0a6              B        |L7.1958|
                  |L7.1624|
;;;940                    
;;;941                case DG_HX_DOWN : //回吸下降
;;;942    			
;;;943                    if( dg_sta_c != dg_sta )
000658  4855              LDR      r0,|L7.1968|
00065a  7800              LDRB     r0,[r0,#0]  ; dg_sta
00065c  4284              CMP      r4,r0
00065e  d006              BEQ      |L7.1646|
;;;944                    {
;;;945                        dg_sta_c = dg_sta;
000660  4853              LDR      r0,|L7.1968|
000662  7804              LDRB     r4,[r0,#0]  ; dg_sta
;;;946                        SetTextValue(0,26,"回吸下降...");
000664  a261              ADR      r2,|L7.2028|
000666  211a              MOVS     r1,#0x1a
000668  2000              MOVS     r0,#0
00066a  f7fffffe          BL       SetTextValue
                  |L7.1646|
;;;947                    }
;;;948                    
;;;949                    if( ( Motor.counter_step <= Motor.counter_hx_step )//到达回吸底部
00066e  484f              LDR      r0,|L7.1964|
000670  6840              LDR      r0,[r0,#4]  ; Motor
000672  494e              LDR      r1,|L7.1964|
000674  68c9              LDR      r1,[r1,#0xc]  ; Motor
000676  4288              CMP      r0,r1
000678  d902              BLS      |L7.1664|
;;;950    								  ||( Motor.counter_step == 0 ) )//触底,此处对触情况底做了限制
00067a  484c              LDR      r0,|L7.1964|
00067c  6840              LDR      r0,[r0,#4]  ; Motor
00067e  b9a0              CBNZ     r0,|L7.1706|
                  |L7.1664|
;;;951                    {
;;;952                        MOTOR_Stop();//电机停止
000680  f7fffffe          BL       MOTOR_Stop
;;;953                        Motor.counter_hx_step = Motor.counter_step + Motor.max_hx_step;
000684  4849              LDR      r0,|L7.1964|
000686  6840              LDR      r0,[r0,#4]  ; Motor
000688  4948              LDR      r1,|L7.1964|
00068a  6909              LDR      r1,[r1,#0x10]  ; Motor
00068c  4408              ADD      r0,r0,r1
00068e  4947              LDR      r1,|L7.1964|
000690  60c8              STR      r0,[r1,#0xc]  ; Motor
;;;954                        
;;;955                        if( Tmy.speed == SLOW )   //常慢速
000692  4848              LDR      r0,|L7.1972|
000694  7900              LDRB     r0,[r0,#4]  ; Tmy
000696  2801              CMP      r0,#1
000698  d103              BNE      |L7.1698|
;;;956                        {
;;;957                            vTaskDelay(pdMS_TO_TICKS(1000));//延时1秒
00069a  f44f707a          MOV      r0,#0x3e8
00069e  f7fffffe          BL       vTaskDelay
                  |L7.1698|
;;;958                        }
;;;959                        dg_sta = DG_HX_UP;//
0006a2  200a              MOVS     r0,#0xa
0006a4  4942              LDR      r1,|L7.1968|
0006a6  7008              STRB     r0,[r1,#0]
0006a8  e013              B        |L7.1746|
                  |L7.1706|
;;;960                    }else
;;;961                    {
;;;962                        if( Tmy.Motor.state != MOTOR_DOWN ) //步进电机未下降
0006aa  4842              LDR      r0,|L7.1972|
0006ac  7800              LDRB     r0,[r0,#0]  ; Tmy
0006ae  2802              CMP      r0,#2
0006b0  d00f              BEQ      |L7.1746|
;;;963                        {
;;;964                            MOTOR_Stop(); //电机暂停
0006b2  f7fffffe          BL       MOTOR_Stop
;;;965                            MOTOR_SetDir( DOWN ); //设置电机方向
0006b6  2001              MOVS     r0,#1
0006b8  f7fffffe          BL       MOTOR_SetDir
;;;966                            MOTOR_SetSpeed( CYCLE_HX ); //设置电机速度，运行
0006bc  2086              MOVS     r0,#0x86
0006be  f7fffffe          BL       MOTOR_SetSpeed
;;;967                            SetTextValue(0,18,"回吸下降"); //更新提示
0006c2  a24d              ADR      r2,|L7.2040|
0006c4  2112              MOVS     r1,#0x12
0006c6  2000              MOVS     r0,#0
0006c8  f7fffffe          BL       SetTextValue
;;;968                            Tmy.Motor.state = MOTOR_DOWN;//
0006cc  2002              MOVS     r0,#2
0006ce  4939              LDR      r1,|L7.1972|
0006d0  7008              STRB     r0,[r1,#0]
                  |L7.1746|
;;;969                        }
;;;970                    }
;;;971                    
;;;972    //	            if( Motor.counter_step > Motor.counter_hx_step ) //
;;;973    //	            {
;;;974    //	                ;//行进中
;;;975    //	            }else //到达回吸底部
;;;976    //	            {
;;;977    //	                MOTOR_Stop();
;;;978    //	                dg_sta = DG_HX_UP;//
;;;979    //                    Motor.counter_hx_step = Motor.counter_step + Motor.max_hx_step;
;;;980    //                    MOTOR_SetDir( UP );
;;;981    //	                MOTOR_SetSpeed( CYCLE_HX ); //设置电机速度
;;;982    //                    SetTextValue(0,18,"回吸上升");
;;;983    //                    if( Tmy.speed == SLOW )   //常慢速
;;;984    //                    {
;;;985    //                        vTaskDelay(pdMS_TO_TICKS(1000));//延时1秒
;;;986    //                    }
;;;987    //	            }
;;;988    	            
;;;989    	            break;
0006d2  e068              B        |L7.1958|
                  |L7.1748|
;;;990    	            
;;;991    	        case DG_HX_UP : //回吸上升
;;;992    	            
;;;993    	            if( dg_sta_c != dg_sta )
0006d4  4836              LDR      r0,|L7.1968|
0006d6  7800              LDRB     r0,[r0,#0]  ; dg_sta
0006d8  4284              CMP      r4,r0
0006da  d006              BEQ      |L7.1770|
;;;994                    {
;;;995                        dg_sta_c = dg_sta;
0006dc  4834              LDR      r0,|L7.1968|
0006de  7804              LDRB     r4,[r0,#0]  ; dg_sta
;;;996                        SetTextValue(0,26,"回吸上升...");
0006e0  a248              ADR      r2,|L7.2052|
0006e2  211a              MOVS     r1,#0x1a
0006e4  2000              MOVS     r0,#0
0006e6  f7fffffe          BL       SetTextValue
                  |L7.1770|
;;;997                    }
;;;998                    
;;;999                    if( Motor.counter_step > Motor.counter_hx_step-1 )//到达回吸顶部
0006ea  4830              LDR      r0,|L7.1964|
0006ec  6841              LDR      r1,[r0,#4]  ; Motor
0006ee  68c0              LDR      r0,[r0,#0xc]  ; Motor
0006f0  1e40              SUBS     r0,r0,#1
0006f2  4281              CMP      r1,r0
0006f4  d905              BLS      |L7.1794|
;;;1000                   {
;;;1001                       MOTOR_Stop(); //电机停止
0006f6  f7fffffe          BL       MOTOR_Stop
;;;1002                       //Tmy.state.bit.hx = 0;
;;;1003                       dg_sta = DG_STOP; //
0006fa  2000              MOVS     r0,#0
0006fc  492c              LDR      r1,|L7.1968|
0006fe  7008              STRB     r0,[r1,#0]
000700  e013              B        |L7.1834|
                  |L7.1794|
;;;1004                   }else
;;;1005                   {
;;;1006                       if( Tmy.Motor.state != MOTOR_UP ) //步进电机未下降
000702  482c              LDR      r0,|L7.1972|
000704  7800              LDRB     r0,[r0,#0]  ; Tmy
000706  2801              CMP      r0,#1
000708  d00f              BEQ      |L7.1834|
;;;1007                       {
;;;1008                           MOTOR_Stop(); //电机暂停
00070a  f7fffffe          BL       MOTOR_Stop
;;;1009                           MOTOR_SetDir( UP ); //设置电机方向
00070e  2000              MOVS     r0,#0
000710  f7fffffe          BL       MOTOR_SetDir
;;;1010                           MOTOR_SetSpeed( CYCLE_HX ); //设置电机速度，运行
000714  2086              MOVS     r0,#0x86
000716  f7fffffe          BL       MOTOR_SetSpeed
;;;1011                           SetTextValue(0,18,"回吸上升"); //更新提示
00071a  a23d              ADR      r2,|L7.2064|
00071c  2112              MOVS     r1,#0x12
00071e  2000              MOVS     r0,#0
000720  f7fffffe          BL       SetTextValue
;;;1012                           Tmy.Motor.state = MOTOR_UP;//
000724  2001              MOVS     r0,#1
000726  4923              LDR      r1,|L7.1972|
000728  7008              STRB     r0,[r1,#0]
                  |L7.1834|
;;;1013                       }
;;;1014                   }
;;;1015                   
;;;1016   //	            if( Motor.counter_step < Motor.counter_hx_step ) 
;;;1017   //	            {
;;;1018   //	                ;//行进中
;;;1019   //	            }else //到达回吸顶部
;;;1020   //	            {
;;;1021   //	                MOTOR_Stop();
;;;1022   //	                Tmy.state.bit.hx = 0;
;;;1023   //	                Tmy.work_state = STA_STANDBY;
;;;1024   //	            }
;;;1025   	            
;;;1026   	            break;
00072a  e03c              B        |L7.1958|
                  |L7.1836|
;;;1027   	            
;;;1028               case DG_FIX_UP : //顶杆检查上升
;;;1029                   
;;;1030                   if( ( Motor.counter_step >= Motor.max_step ) //到达顶部
00072c  481f              LDR      r0,|L7.1964|
00072e  6840              LDR      r0,[r0,#4]  ; Motor
000730  491e              LDR      r1,|L7.1964|
000732  6889              LDR      r1,[r1,#8]  ; Motor
000734  4288              CMP      r0,r1
000736  d204              BCS      |L7.1858|
;;;1031                    || ( Tmy.Sensor.bit.top ) )
000738  481e              LDR      r0,|L7.1972|
00073a  79c0              LDRB     r0,[r0,#7]  ; Tmy
00073c  f3c00040          UBFX     r0,r0,#1,#1
000740  b128              CBZ      r0,|L7.1870|
                  |L7.1858|
;;;1032                   {
;;;1033                       MOTOR_Stop();//这个是冗余操作，多一次保护
000742  f7fffffe          BL       MOTOR_Stop
;;;1034                       dg_sta = DG_STOP_TOP;//停留在顶部
000746  2004              MOVS     r0,#4
000748  4919              LDR      r1,|L7.1968|
00074a  7008              STRB     r0,[r1,#0]
00074c  e00e              B        |L7.1900|
                  |L7.1870|
;;;1035                   }else
;;;1036                   {
;;;1037                       if( Tmy.Motor.state != MOTOR_UP ) //步进电机未上升
00074e  4819              LDR      r0,|L7.1972|
000750  7800              LDRB     r0,[r0,#0]  ; Tmy
000752  2801              CMP      r0,#1
000754  d00a              BEQ      |L7.1900|
;;;1038                       {
;;;1039                           MOTOR_Stop(); //电机暂停
000756  f7fffffe          BL       MOTOR_Stop
;;;1040                           MOTOR_SetDir( UP ); //设置电机方向
00075a  2000              MOVS     r0,#0
00075c  f7fffffe          BL       MOTOR_SetDir
;;;1041                           MOTOR_SetSpeed( CYCLE_DGJC ); //设置电机速度，运行
000760  2026              MOVS     r0,#0x26
000762  f7fffffe          BL       MOTOR_SetSpeed
;;;1042                           //SetTextValue(0,18,"顶杆检查上升"); //更新提示
;;;1043                       
;;;1044                           Tmy.Motor.state = MOTOR_UP;//
000766  2001              MOVS     r0,#1
000768  4912              LDR      r1,|L7.1972|
00076a  7008              STRB     r0,[r1,#0]
                  |L7.1900|
;;;1045                       }
;;;1046                   }
;;;1047                   
;;;1048                   break;
00076c  e01b              B        |L7.1958|
                  |L7.1902|
;;;1049                   
;;;1050               case DG_FIX_DOWN : //顶杆检查下降
;;;1051                   
;;;1052                   if( Tmy.Sensor.bit.bottom )//检测到底
00076e  4811              LDR      r0,|L7.1972|
000770  79c0              LDRB     r0,[r0,#7]  ; Tmy
000772  f0000001          AND      r0,r0,#1
000776  b128              CBZ      r0,|L7.1924|
;;;1053                   {
;;;1054                       MOTOR_Stop();//这个是冗余操作，多一次保护
000778  f7fffffe          BL       MOTOR_Stop
;;;1055                       dg_sta = DG_STOP_BOT;//
00077c  2005              MOVS     r0,#5
00077e  490c              LDR      r1,|L7.1968|
000780  7008              STRB     r0,[r1,#0]
000782  e00e              B        |L7.1954|
                  |L7.1924|
;;;1056                   }else
;;;1057                   {
;;;1058                       if( Tmy.Motor.state != MOTOR_DOWN ) //步进电机未下降
000784  480b              LDR      r0,|L7.1972|
000786  7800              LDRB     r0,[r0,#0]  ; Tmy
000788  2802              CMP      r0,#2
00078a  d00a              BEQ      |L7.1954|
;;;1059                       {
;;;1060                           MOTOR_Stop(); //电机暂停
00078c  f7fffffe          BL       MOTOR_Stop
;;;1061                           MOTOR_SetDir( DOWN ); //设置电机方向
000790  2001              MOVS     r0,#1
000792  f7fffffe          BL       MOTOR_SetDir
;;;1062                           MOTOR_SetSpeed( CYCLE_DGJC ); //设置电机速度，运行
000796  2026              MOVS     r0,#0x26
000798  f7fffffe          BL       MOTOR_SetSpeed
;;;1063                           //SetTextValue(0,18,"顶杆检查下降"); //更新提示
;;;1064                       
;;;1065                           Tmy.Motor.state = MOTOR_DOWN;//
00079c  2002              MOVS     r0,#2
00079e  4905              LDR      r1,|L7.1972|
0007a0  7008              STRB     r0,[r1,#0]
                  |L7.1954|
;;;1066                       }
;;;1067                   }
;;;1068                   
;;;1069                   break;
0007a2  e000              B        |L7.1958|
                  |L7.1956|
;;;1070               
;;;1071               default : 
;;;1072                   break;
0007a4  bf00              NOP      
                  |L7.1958|
0007a6  bf00              NOP                            ;616
                  |L7.1960|
0007a8  e441              B        |L7.46|
;;;1073           }
;;;1074           
;;;1075       }
;;;1076   }
;;;1077   
                          ENDP

0007aa  0000              DCW      0x0000
                  |L7.1964|
                          DCD      Motor
                  |L7.1968|
                          DCD      dg_sta
                  |L7.1972|
                          DCD      Tmy
                  |L7.1976|
0007b8  b6a5b8cb          DCB      182,165,184,203,201,207,201,253,"...",0
0007bc  c9cfc9fd
0007c0  2e2e2e00
                  |L7.1988|
                          DCD      MOTOR_SPEED_INDEX
                  |L7.1992|
                          DCD      MOTOR_SPEED_CYCLE
                  |L7.1996|
                          DCD      MOTOR_SPEED_DISPLAY
                  |L7.2000|
0007d0  b5bdb6a5          DCB      181,189,182,165,205,163,187,250,180,253,187,250,0
0007d4  cda3bbfa
0007d8  b4fdbbfa
0007dc  00      
0007dd  00                DCB      0
0007de  00                DCB      0
0007df  00                DCB      0
                  |L7.2016|
0007e0  b6a5b8cb          DCB      182,165,184,203,207,194,189,181,"...",0
0007e4  cfc2bdb5
0007e8  2e2e2e00
                  |L7.2028|
0007ec  bbd8cefc          DCB      187,216,206,252,207,194,189,181,"...",0
0007f0  cfc2bdb5
0007f4  2e2e2e00
                  |L7.2040|
0007f8  bbd8cefc          DCB      187,216,206,252,207,194,189,181,0
0007fc  cfc2bdb5
000800  00      
000801  00                DCB      0
000802  00                DCB      0
000803  00                DCB      0
                  |L7.2052|
000804  bbd8cefc          DCB      187,216,206,252,201,207,201,253,"...",0
000808  c9cfc9fd
00080c  2e2e2e00
                  |L7.2064|
000810  bbd8cefc          DCB      187,216,206,252,201,207,201,253,0
000814  c9cfc9fd
000818  00      
000819  00                DCB      0
00081a  00                DCB      0
00081b  00                DCB      0

                          AREA ||i.vTaskSensor||, CODE, READONLY, ALIGN=2

                  vTaskSensor PROC
;;;230    */
;;;231    static void vTaskSensor(void *pvParameters)
000000  2400              MOVS     r4,#0
;;;232    {
;;;233    	uint8_t tem8 = 0;
;;;234    	
;;;235    //    SoftWdtInit( vTaskSensor_ID, 10 );
;;;236        
;;;237        //timer_sensor = 4;
;;;238        while( 1 )
000002  e0a3              B        |L8.332|
                  |L8.4|
;;;239        {
;;;240    //        SoftWdtFed( vTaskSensor_ID );
;;;241            
;;;242            //vTaskDelay( pdMS_TO_TICKS(1000) );//
;;;243            vTaskDelay( 2 );
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       vTaskDelay
;;;244            
;;;245            ADC1_GetV();
00000a  f7fffffe          BL       ADC1_GetV
;;;246            //Tmy.pressure = HX711_Read();
;;;247            
;;;248            //bsp_KeyScan();
;;;249            if( tem8 != Tmy.Sensor.bit.bottom )
00000e  4850              LDR      r0,|L8.336|
000010  79c0              LDRB     r0,[r0,#7]  ; Tmy
000012  f0000001          AND      r0,r0,#1
000016  42a0              CMP      r0,r4
000018  d013              BEQ      |L8.66|
;;;250            {
;;;251                tem8 = Tmy.Sensor.bit.bottom;
00001a  484d              LDR      r0,|L8.336|
00001c  79c0              LDRB     r0,[r0,#7]  ; Tmy
00001e  f0000401          AND      r4,r0,#1
;;;252                
;;;253                if( Tmy.Sensor.bit.bottom ) //触底检测
000022  484b              LDR      r0,|L8.336|
000024  79c0              LDRB     r0,[r0,#7]  ; Tmy
000026  f0000001          AND      r0,r0,#1
00002a  b128              CBZ      r0,|L8.56|
;;;254                {
;;;255                    SetTextValue(0,29,"已触底"); //已触底
00002c  a249              ADR      r2,|L8.340|
00002e  211d              MOVS     r1,#0x1d
000030  2000              MOVS     r0,#0
000032  f7fffffe          BL       SetTextValue
000036  e004              B        |L8.66|
                  |L8.56|
;;;256                }else
;;;257                {
;;;258                    SetTextValue(0,29,"未触底"); //未触底
000038  a248              ADR      r2,|L8.348|
00003a  211d              MOVS     r1,#0x1d
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       SetTextValue
                  |L8.66|
;;;259                }
;;;260            }
;;;261            
;;;262    		if( bsp_GetKeyState( KID_K1 ) ) //紧急制动按钮
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       bsp_GetKeyState
000048  b130              CBZ      r0,|L8.88|
;;;263            {
;;;264                Tmy.Key.jjzd = 0; //
00004a  4841              LDR      r0,|L8.336|
00004c  7940              LDRB     r0,[r0,#5]  ; Tmy
00004e  f0200040          BIC      r0,r0,#0x40
000052  493f              LDR      r1,|L8.336|
000054  7148              STRB     r0,[r1,#5]
000056  e006              B        |L8.102|
                  |L8.88|
;;;265            }else //按下
;;;266            {
;;;267                Tmy.Key.jjzd = 1; //
000058  483d              LDR      r0,|L8.336|
00005a  7940              LDRB     r0,[r0,#5]  ; Tmy
00005c  f0200040          BIC      r0,r0,#0x40
000060  3040              ADDS     r0,r0,#0x40
000062  493b              LDR      r1,|L8.336|
000064  7148              STRB     r0,[r1,#5]
                  |L8.102|
;;;268            }
;;;269    		
;;;270            if( bsp_GetKeyState( KID_ZERO ) ) //触底检测
000066  2009              MOVS     r0,#9
000068  f7fffffe          BL       bsp_GetKeyState
00006c  b130              CBZ      r0,|L8.124|
;;;271            {
;;;272                Tmy.Sensor.bit.bottom = 0; //未触底
00006e  4838              LDR      r0,|L8.336|
000070  79c0              LDRB     r0,[r0,#7]  ; Tmy
000072  f0200001          BIC      r0,r0,#1
000076  4936              LDR      r1,|L8.336|
000078  71c8              STRB     r0,[r1,#7]
00007a  e006              B        |L8.138|
                  |L8.124|
;;;273            }else
;;;274            {
;;;275                Tmy.Sensor.bit.bottom = 1; //已触底
00007c  4834              LDR      r0,|L8.336|
00007e  79c0              LDRB     r0,[r0,#7]  ; Tmy
000080  f0200001          BIC      r0,r0,#1
000084  1c40              ADDS     r0,r0,#1
000086  4932              LDR      r1,|L8.336|
000088  71c8              STRB     r0,[r1,#7]
                  |L8.138|
;;;276            }
;;;277            
;;;278            //if( Motor.counter_step > Motor.counter_hx_step-1 ) //触顶检测 //if( bsp_GetKeyState( KID_ZERO ) ) 
;;;279            if( Motor.counter_step >= Motor.max_step )//触顶检测
00008a  4836              LDR      r0,|L8.356|
00008c  6840              LDR      r0,[r0,#4]  ; Motor
00008e  4935              LDR      r1,|L8.356|
000090  6889              LDR      r1,[r1,#8]  ; Motor
000092  4288              CMP      r0,r1
000094  d307              BCC      |L8.166|
;;;280            {
;;;281                Tmy.Sensor.bit.top = 1; //已触顶
000096  482e              LDR      r0,|L8.336|
000098  79c0              LDRB     r0,[r0,#7]  ; Tmy
00009a  f0200002          BIC      r0,r0,#2
00009e  1c80              ADDS     r0,r0,#2
0000a0  492b              LDR      r1,|L8.336|
0000a2  71c8              STRB     r0,[r1,#7]
0000a4  e005              B        |L8.178|
                  |L8.166|
;;;282            }else
;;;283            {
;;;284                Tmy.Sensor.bit.top = 0; //未触顶
0000a6  482a              LDR      r0,|L8.336|
0000a8  79c0              LDRB     r0,[r0,#7]  ; Tmy
0000aa  f0200002          BIC      r0,r0,#2
0000ae  4928              LDR      r1,|L8.336|
0000b0  71c8              STRB     r0,[r1,#7]
                  |L8.178|
;;;285            }
;;;286            
;;;287            if( Tmy.State.bit.init ) //初始化完成
0000b2  4827              LDR      r0,|L8.336|
0000b4  7980              LDRB     r0,[r0,#6]  ; Tmy
0000b6  f3c00040          UBFX     r0,r0,#1,#1
0000ba  b180              CBZ      r0,|L8.222|
;;;288            {
;;;289                if( Motor.counter_step == 0 )//触低底检测
0000bc  4829              LDR      r0,|L8.356|
0000be  6840              LDR      r0,[r0,#4]  ; Motor
0000c0  b938              CBNZ     r0,|L8.210|
;;;290                {
;;;291                    Tmy.Sensor.bit.bottom = 1; //已触底
0000c2  4823              LDR      r0,|L8.336|
0000c4  79c0              LDRB     r0,[r0,#7]  ; Tmy
0000c6  f0200001          BIC      r0,r0,#1
0000ca  1c40              ADDS     r0,r0,#1
0000cc  4920              LDR      r1,|L8.336|
0000ce  71c8              STRB     r0,[r1,#7]
0000d0  e005              B        |L8.222|
                  |L8.210|
;;;292                }else
;;;293                {
;;;294                    Tmy.Sensor.bit.bottom = 0; //未触底
0000d2  481f              LDR      r0,|L8.336|
0000d4  79c0              LDRB     r0,[r0,#7]  ; Tmy
0000d6  f0200001          BIC      r0,r0,#1
0000da  491d              LDR      r1,|L8.336|
0000dc  71c8              STRB     r0,[r1,#7]
                  |L8.222|
;;;295                }
;;;296            }
;;;297            
;;;298            if( bsp_GetKeyState( KID_SYRINGE ) ) //注射器类型
0000de  200a              MOVS     r0,#0xa
0000e0  f7fffffe          BL       bsp_GetKeyState
0000e4  b138              CBZ      r0,|L8.246|
;;;299            {
;;;300                Tmy.Sensor.bit.SyringeType = SYRINGE_2ML2; //2.2ml
0000e6  481a              LDR      r0,|L8.336|
0000e8  79c0              LDRB     r0,[r0,#7]  ; Tmy
0000ea  f0200004          BIC      r0,r0,#4
0000ee  1d00              ADDS     r0,r0,#4
0000f0  4917              LDR      r1,|L8.336|
0000f2  71c8              STRB     r0,[r1,#7]
0000f4  e005              B        |L8.258|
                  |L8.246|
;;;301            }else
;;;302            {
;;;303                Tmy.Sensor.bit.SyringeType = SYRINGE_1ML8; //1.8ml
0000f6  4816              LDR      r0,|L8.336|
0000f8  79c0              LDRB     r0,[r0,#7]  ; Tmy
0000fa  f0200004          BIC      r0,r0,#4
0000fe  4914              LDR      r1,|L8.336|
000100  71c8              STRB     r0,[r1,#7]
                  |L8.258|
;;;304            }
;;;305            
;;;306            if( bsp_GetKeyState( KID_SYRINGE ) ) //注射器插入状态 XXX
000102  200a              MOVS     r0,#0xa
000104  f7fffffe          BL       bsp_GetKeyState
000108  b138              CBZ      r0,|L8.282|
;;;307            {
;;;308                Tmy.Sensor.bit.SyringeState = SYRINGE_ON; //已插入
00010a  4811              LDR      r0,|L8.336|
00010c  79c0              LDRB     r0,[r0,#7]  ; Tmy
00010e  f0200008          BIC      r0,r0,#8
000112  3008              ADDS     r0,r0,#8
000114  490e              LDR      r1,|L8.336|
000116  71c8              STRB     r0,[r1,#7]
000118  e005              B        |L8.294|
                  |L8.282|
;;;309            }else
;;;310            {
;;;311                Tmy.Sensor.bit.SyringeState = SYRINGE_OFF; //未插入
00011a  480d              LDR      r0,|L8.336|
00011c  79c0              LDRB     r0,[r0,#7]  ; Tmy
00011e  f0200008          BIC      r0,r0,#8
000122  490b              LDR      r1,|L8.336|
000124  71c8              STRB     r0,[r1,#7]
                  |L8.294|
;;;312            }
;;;313            
;;;314            if( Tmy.pressure > MAX_PRESSURE ) //过压
000126  480a              LDR      r0,|L8.336|
000128  68c0              LDR      r0,[r0,#0xc]  ; Tmy
00012a  f5b07f7a          CMP      r0,#0x3e8
00012e  d907              BLS      |L8.320|
;;;315            {
;;;316                Tmy.Sensor.bit.OverPressure = 1; //已插入
000130  4807              LDR      r0,|L8.336|
000132  79c0              LDRB     r0,[r0,#7]  ; Tmy
000134  f0200010          BIC      r0,r0,#0x10
000138  3010              ADDS     r0,r0,#0x10
00013a  4905              LDR      r1,|L8.336|
00013c  71c8              STRB     r0,[r1,#7]
00013e  e005              B        |L8.332|
                  |L8.320|
;;;317            }else
;;;318            {
;;;319                Tmy.Sensor.bit.OverPressure = 0; //未插入
000140  4803              LDR      r0,|L8.336|
000142  79c0              LDRB     r0,[r0,#7]  ; Tmy
000144  f0200010          BIC      r0,r0,#0x10
000148  4901              LDR      r1,|L8.336|
00014a  71c8              STRB     r0,[r1,#7]
                  |L8.332|
00014c  e75a              B        |L8.4|
;;;320            }
;;;321        }
;;;322    }
;;;323    
                          ENDP

00014e  0000              DCW      0x0000
                  |L8.336|
                          DCD      Tmy
                  |L8.340|
000154  d2d1b4a5          DCB      210,209,180,165,181,215,0
000158  b5d700  
00015b  00                DCB      0
                  |L8.348|
00015c  ceb4b4a5          DCB      206,180,180,165,181,215,0
000160  b5d700  
000163  00                DCB      0
                  |L8.356|
                          DCD      Motor

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  BLE_TxBuf
                          %        100
                  BLE_RxBuf
                          %        100
                  Tmy
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  dg_sta
000000  00                DCB      0x00
                  dev_sta
000001  000000            DCB      0x00,0x00,0x00
                  xHandleTaskLCD
                          DCD      0x00000000
                  xHandleTaskMotorCtrl
                          DCD      0x00000000
                  xHandleTaskSensor
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_251558ba____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_main_c_251558ba____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_251558ba____REVSH|
#line 128
|__asm___6_main_c_251558ba____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
