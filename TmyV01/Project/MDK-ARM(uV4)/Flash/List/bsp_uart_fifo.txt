; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app -I..\..\User\lcd\inc -I..\..\User\hx711 -ID:\MyDoc\MyPrj\MyGitPrj\TmyV01\Project\MDK-ARM(uV4)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;93     */
;;;94     UART_T *ComToUart(COM_PORT_E _ucPort)
000000  4601              MOV      r1,r0
;;;95     {
;;;96     	if (_ucPort == COM1)
000002  b909              CBNZ     r1,|L1.8|
;;;97     	{
;;;98     		#if UART1_FIFO_EN == 1
;;;99     			return &g_tUart1;
000004  4809              LDR      r0,|L1.44|
                  |L1.6|
;;;100    		#else
;;;101    			return 0;
;;;102    		#endif
;;;103    	}
;;;104    	else if (_ucPort == COM2)
;;;105    	{
;;;106    		#if UART2_FIFO_EN == 1
;;;107    			return &g_tUart2;
;;;108    		#else
;;;109    			return 0;
;;;110    		#endif
;;;111    	}
;;;112    	else if (_ucPort == COM3)
;;;113    	{
;;;114    		#if UART3_FIFO_EN == 1
;;;115    			return &g_tUart3;
;;;116    		#else
;;;117    			return 0;
;;;118    		#endif
;;;119    	}
;;;120    	else if (_ucPort == COM4)
;;;121    	{
;;;122    		#if UART4_FIFO_EN == 1
;;;123    			return &g_tUart4;
;;;124    		#else
;;;125    			return 0;
;;;126    		#endif
;;;127    	}
;;;128    	else if (_ucPort == COM5)
;;;129    	{
;;;130    		#if UART5_FIFO_EN == 1
;;;131    			return &g_tUart5;
;;;132    		#else
;;;133    			return 0;
;;;134    		#endif
;;;135    	}
;;;136    	else
;;;137    	{
;;;138    		/* 不做任何处理 */
;;;139    		return 0;
;;;140    	}
;;;141    }
000006  4770              BX       lr
                  |L1.8|
000008  2901              CMP      r1,#1                 ;104
00000a  d101              BNE      |L1.16|
00000c  4808              LDR      r0,|L1.48|
00000e  e7fa              B        |L1.6|
                  |L1.16|
000010  2902              CMP      r1,#2                 ;112
000012  d101              BNE      |L1.24|
000014  2000              MOVS     r0,#0                 ;117
000016  e7f6              B        |L1.6|
                  |L1.24|
000018  2903              CMP      r1,#3                 ;120
00001a  d101              BNE      |L1.32|
00001c  4805              LDR      r0,|L1.52|
00001e  e7f2              B        |L1.6|
                  |L1.32|
000020  2904              CMP      r1,#4                 ;128
000022  d101              BNE      |L1.40|
000024  2000              MOVS     r0,#0                 ;133
000026  e7ee              B        |L1.6|
                  |L1.40|
000028  2000              MOVS     r0,#0                 ;139
00002a  e7ec              B        |L1.6|
;;;142    
                          ENDP

                  |L1.44|
                          DCD      g_tUart1
                  |L1.48|
                          DCD      g_tUart2
                  |L1.52|
                          DCD      g_tUart4

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;845    */
;;;846    static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;847    {
;;;848    	NVIC_InitTypeDef NVIC_InitStructure;
;;;849    
;;;850    	/* Configure the NVIC Preemption Priority Bits */
;;;851    	/*	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  --- 在 bsp.c 中 bsp_Init() 中配置中断优先级组 */
;;;852    
;;;853    #if UART1_FIFO_EN == 1
;;;854    	/* 使能串口1中断 */
;;;855    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000002  2025              MOVS     r0,#0x25
000004  f88d0000          STRB     r0,[sp,#0]
;;;856    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000008  2001              MOVS     r0,#1
00000a  f88d0001          STRB     r0,[sp,#1]
;;;857    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00000e  2000              MOVS     r0,#0
000010  f88d0002          STRB     r0,[sp,#2]
;;;858    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;859    	NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;860    #endif
;;;861    
;;;862    #if UART2_FIFO_EN == 1
;;;863    	/* 使能串口2中断 */
;;;864    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
000020  2026              MOVS     r0,#0x26
000022  f88d0000          STRB     r0,[sp,#0]
;;;865    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000026  2001              MOVS     r0,#1
000028  f88d0001          STRB     r0,[sp,#1]
;;;866    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00002c  2000              MOVS     r0,#0
00002e  f88d0002          STRB     r0,[sp,#2]
;;;867    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  2001              MOVS     r0,#1
000034  f88d0003          STRB     r0,[sp,#3]
;;;868    	NVIC_Init(&NVIC_InitStructure);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       NVIC_Init
;;;869    #endif
;;;870    
;;;871    #if UART3_FIFO_EN == 1
;;;872    	/* 使能串口3中断t */
;;;873    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
;;;874    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;875    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;876    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;877    	NVIC_Init(&NVIC_InitStructure);
;;;878    #endif
;;;879    
;;;880    #if UART4_FIFO_EN == 1
;;;881    	/* 使能串口4中断t */
;;;882    	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
00003e  2034              MOVS     r0,#0x34
000040  f88d0000          STRB     r0,[sp,#0]
;;;883    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000044  2001              MOVS     r0,#1
000046  f88d0001          STRB     r0,[sp,#1]
;;;884    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00004a  2000              MOVS     r0,#0
00004c  f88d0002          STRB     r0,[sp,#2]
;;;885    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000050  2001              MOVS     r0,#1
000052  f88d0003          STRB     r0,[sp,#3]
;;;886    	NVIC_Init(&NVIC_InitStructure);
000056  4668              MOV      r0,sp
000058  f7fffffe          BL       NVIC_Init
;;;887    #endif
;;;888    
;;;889    #if UART5_FIFO_EN == 1
;;;890    	/* 使能串口5中断t */
;;;891    	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
;;;892    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;893    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;894    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;895    	NVIC_Init(&NVIC_InitStructure);
;;;896    #endif
;;;897    
;;;898    #if UART6_FIFO_EN == 1
;;;899    	/* 使能串口6中断t */
;;;900    	NVIC_InitStructure.NVIC_IRQChannel = USART6_IRQn;
;;;901    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;902    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;903    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;904    	NVIC_Init(&NVIC_InitStructure);
;;;905    #endif
;;;906    }
00005c  bd08              POP      {r3,pc}
;;;907    
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;605    */
;;;606    static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;607    {
000002  b085              SUB      sp,sp,#0x14
;;;608    	GPIO_InitTypeDef GPIO_InitStructure;
;;;609    	USART_InitTypeDef USART_InitStructure;
;;;610    
;;;611    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;612    
;;;613    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;614    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;615    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;616    
;;;617    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;618    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;619    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;620    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
000024  f88d0012          STRB     r0,[sp,#0x12]
;;;621    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  a904              ADD      r1,sp,#0x10
00002a  485b              LDR      r0,|L3.408|
00002c  f7fffffe          BL       GPIO_Init
;;;622    
;;;623    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;624    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;625    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;626    	*/
;;;627    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;628    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;629    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  4855              LDR      r0,|L3.408|
000042  f7fffffe          BL       GPIO_Init
;;;630    	
;;;631    	/* 第4步： 配置串口硬件参数 */
;;;632    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
000046  f44f30e1          MOV      r0,#0x1c200
00004a  9000              STR      r0,[sp,#0]
;;;633    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;634    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000052  f8ad0006          STRH     r0,[sp,#6]
;;;635    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000056  f8ad0008          STRH     r0,[sp,#8]
;;;636    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;637    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;638    	USART_Init(USART1, &USART_InitStructure);
000064  4669              MOV      r1,sp
000066  484d              LDR      r0,|L3.412|
000068  f7fffffe          BL       USART_Init
;;;639    
;;;640    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
00006c  2201              MOVS     r2,#1
00006e  f2405125          MOV      r1,#0x525
000072  484a              LDR      r0,|L3.412|
000074  f7fffffe          BL       USART_ITConfig
;;;641    	/*
;;;642    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;643    		注意: 不要在此处打开发送中断
;;;644    		发送中断使能在SendUart()函数打开
;;;645    	*/
;;;646    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000078  2101              MOVS     r1,#1
00007a  4848              LDR      r0,|L3.412|
00007c  f7fffffe          BL       USART_Cmd
;;;647    
;;;648    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;649    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;650    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000080  2140              MOVS     r1,#0x40
000082  4846              LDR      r0,|L3.412|
000084  f7fffffe          BL       USART_ClearFlag
;;;651    #endif
;;;652    
;;;653    #if UART2_FIFO_EN == 1		/* 串口2 TX = PA2， RX = PA3  */
;;;654    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;655    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000088  2101              MOVS     r1,#1
00008a  2005              MOVS     r0,#5
00008c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;656    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
000090  2101              MOVS     r1,#1
000092  0448              LSLS     r0,r1,#17
000094  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;657    
;;;658    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;659    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000098  2004              MOVS     r0,#4
00009a  f8ad0010          STRH     r0,[sp,#0x10]
;;;660    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00009e  2018              MOVS     r0,#0x18
0000a0  f88d0013          STRB     r0,[sp,#0x13]
;;;661    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a4  2003              MOVS     r0,#3
0000a6  f88d0012          STRB     r0,[sp,#0x12]
;;;662    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000aa  a904              ADD      r1,sp,#0x10
0000ac  483a              LDR      r0,|L3.408|
0000ae  f7fffffe          BL       GPIO_Init
;;;663    
;;;664    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;665    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;666    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;667    	*/
;;;668    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
0000b2  2008              MOVS     r0,#8
0000b4  f8ad0010          STRH     r0,[sp,#0x10]
;;;669    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000b8  2004              MOVS     r0,#4
0000ba  f88d0013          STRB     r0,[sp,#0x13]
;;;670    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000be  a904              ADD      r1,sp,#0x10
0000c0  4835              LDR      r0,|L3.408|
0000c2  f7fffffe          BL       GPIO_Init
;;;671    	/*  第3步已经做了，因此这步可以不做
;;;672    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;673    	*/
;;;674    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000c6  a904              ADD      r1,sp,#0x10
0000c8  4833              LDR      r0,|L3.408|
0000ca  f7fffffe          BL       GPIO_Init
;;;675    
;;;676    	/* 第4步： 配置串口硬件参数 */
;;;677    	USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
0000ce  f44f4096          MOV      r0,#0x4b00
0000d2  9000              STR      r0,[sp,#0]
;;;678    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000d4  2000              MOVS     r0,#0
0000d6  f8ad0004          STRH     r0,[sp,#4]
;;;679    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000da  f8ad0006          STRH     r0,[sp,#6]
;;;680    	USART_InitStructure.USART_Parity = USART_Parity_No ;
0000de  f8ad0008          STRH     r0,[sp,#8]
;;;681    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000e2  f8ad000c          STRH     r0,[sp,#0xc]
;;;682    	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;		/* 仅选择接收模式 */
0000e6  200c              MOVS     r0,#0xc
0000e8  f8ad000a          STRH     r0,[sp,#0xa]
;;;683    	USART_Init(USART2, &USART_InitStructure);
0000ec  4669              MOV      r1,sp
0000ee  482c              LDR      r0,|L3.416|
0000f0  f7fffffe          BL       USART_Init
;;;684    
;;;685    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0000f4  2201              MOVS     r2,#1
0000f6  f2405125          MOV      r1,#0x525
0000fa  4829              LDR      r0,|L3.416|
0000fc  f7fffffe          BL       USART_ITConfig
;;;686    	/*
;;;687    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;688    		注意: 不要在此处打开发送中断
;;;689    		发送中断使能在SendUart()函数打开
;;;690    	*/
;;;691    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
000100  2101              MOVS     r1,#1
000102  4827              LDR      r0,|L3.416|
000104  f7fffffe          BL       USART_Cmd
;;;692    
;;;693    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;694    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;695    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000108  2140              MOVS     r1,#0x40
00010a  4825              LDR      r0,|L3.416|
00010c  f7fffffe          BL       USART_ClearFlag
;;;696    #endif
;;;697    
;;;698    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;699    
;;;700    	/* 配置 PB2为推挽输出，用于切换 RS485芯片的收发状态 */
;;;701    	{
;;;702    		RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
;;;703    
;;;704    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;705    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;706    		GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
;;;707    		GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
;;;708    	}
;;;709    
;;;710    	/* 第1步： 开启GPIO和UART时钟 */
;;;711    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
;;;712    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
;;;713    
;;;714    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;715    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;716    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;717    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;718    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;719    
;;;720    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;721    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;722    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;723    	*/
;;;724    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;725    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;726    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;727    	/*  第3步已经做了，因此这步可以不做
;;;728    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;729    	*/
;;;730    	GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;731    
;;;732    	/* 第4步： 配置串口硬件参数 */
;;;733    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
;;;734    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;735    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;736    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;737    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;738    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;739    	USART_Init(USART3, &USART_InitStructure);
;;;740    
;;;741    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;742    	/*
;;;743    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;744    		注意: 不要在此处打开发送中断
;;;745    		发送中断使能在SendUart()函数打开
;;;746    	*/
;;;747    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
;;;748    
;;;749    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;750    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;751    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;752    #endif
;;;753    
;;;754    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;755    	/* 第1步： 开启GPIO和UART时钟 */
;;;756    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
000110  2101              MOVS     r1,#1
000112  2011              MOVS     r0,#0x11
000114  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;757    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
000118  2101              MOVS     r1,#1
00011a  04c8              LSLS     r0,r1,#19
00011c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;758    
;;;759    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;760    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000120  f44f6080          MOV      r0,#0x400
000124  f8ad0010          STRH     r0,[sp,#0x10]
;;;761    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000128  2018              MOVS     r0,#0x18
00012a  f88d0013          STRB     r0,[sp,#0x13]
;;;762    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00012e  2003              MOVS     r0,#3
000130  f88d0012          STRB     r0,[sp,#0x12]
;;;763    	GPIO_Init(GPIOC, &GPIO_InitStructure);
000134  a904              ADD      r1,sp,#0x10
000136  481b              LDR      r0,|L3.420|
000138  f7fffffe          BL       GPIO_Init
;;;764    
;;;765    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;766    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;767    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;768    	*/
;;;769    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
00013c  f44f6000          MOV      r0,#0x800
000140  f8ad0010          STRH     r0,[sp,#0x10]
;;;770    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000144  2004              MOVS     r0,#4
000146  f88d0013          STRB     r0,[sp,#0x13]
;;;771    	GPIO_Init(GPIOC, &GPIO_InitStructure);
00014a  a904              ADD      r1,sp,#0x10
00014c  4815              LDR      r0,|L3.420|
00014e  f7fffffe          BL       GPIO_Init
;;;772    
;;;773    	/* 第4步： 配置串口硬件参数 */
;;;774    	USART_InitStructure.USART_BaudRate = UART4_BAUD;	/* 波特率 */
000152  f44f30e1          MOV      r0,#0x1c200
000156  9000              STR      r0,[sp,#0]
;;;775    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000158  2000              MOVS     r0,#0
00015a  f8ad0004          STRH     r0,[sp,#4]
;;;776    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00015e  f8ad0006          STRH     r0,[sp,#6]
;;;777    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000162  f8ad0008          STRH     r0,[sp,#8]
;;;778    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000166  f8ad000c          STRH     r0,[sp,#0xc]
;;;779    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00016a  200c              MOVS     r0,#0xc
00016c  f8ad000a          STRH     r0,[sp,#0xa]
;;;780    	USART_Init(UART4, &USART_InitStructure);
000170  4669              MOV      r1,sp
000172  480d              LDR      r0,|L3.424|
000174  f7fffffe          BL       USART_Init
;;;781    
;;;782    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000178  2201              MOVS     r2,#1
00017a  f2405125          MOV      r1,#0x525
00017e  480a              LDR      r0,|L3.424|
000180  f7fffffe          BL       USART_ITConfig
;;;783    	/*
;;;784    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;785    		注意: 不要在此处打开发送中断
;;;786    		发送中断使能在SendUart()函数打开
;;;787    	*/
;;;788    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
000184  2101              MOVS     r1,#1
000186  4808              LDR      r0,|L3.424|
000188  f7fffffe          BL       USART_Cmd
;;;789    
;;;790    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;791    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;792    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
00018c  2140              MOVS     r1,#0x40
00018e  4806              LDR      r0,|L3.424|
000190  f7fffffe          BL       USART_ClearFlag
;;;793    #endif
;;;794    
;;;795    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;796    	/* 第1步： 开启GPIO和UART时钟 */
;;;797    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
;;;798    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
;;;799    
;;;800    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;801    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;802    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;803    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;804    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;805    
;;;806    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;807    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;808    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;809    	*/
;;;810    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;811    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;812    	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;813    
;;;814    
;;;815    	/* 第4步： 配置串口硬件参数 */
;;;816    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
;;;817    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;818    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;819    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;820    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;821    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;822    	USART_Init(UART5, &USART_InitStructure);
;;;823    
;;;824    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;825    	/*
;;;826    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;827    		注意: 不要在此处打开发送中断
;;;828    		发送中断使能在SendUart()函数打开
;;;829    	*/
;;;830    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
;;;831    
;;;832    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;833    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;834    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;835    #endif
;;;836    }
000194  b005              ADD      sp,sp,#0x14
000196  bd00              POP      {pc}
;;;837    
                          ENDP

                  |L3.408|
                          DCD      0x40010800
                  |L3.412|
                          DCD      0x40013800
                  |L3.416|
                          DCD      0x40004400
                  |L3.420|
                          DCD      0x40011000
                  |L3.424|
                          DCD      0x40004c00

                          AREA ||i.RS485_InitTXE||, CODE, READONLY, ALIGN=2

                  RS485_InitTXE PROC
;;;378    */
;;;379    void RS485_InitTXE(void)
000000  b508              PUSH     {r3,lr}
;;;380    {
;;;381    	GPIO_InitTypeDef GPIO_InitStructure;
;;;382    
;;;383    	RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;384    
;;;385    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;386    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;387    	GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000016  2004              MOVS     r0,#4
000018  f8ad0000          STRH     r0,[sp,#0]
;;;388    	GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L4.40|
000020  f7fffffe          BL       GPIO_Init
;;;389    }
000024  bd08              POP      {r3,pc}
;;;390    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x40010c00

                          AREA ||i.RS485_ReciveNew||, CODE, READONLY, ALIGN=1

                  RS485_ReciveNew PROC
;;;478    //extern void MODBUS_ReciveNew(uint8_t _byte);
;;;479    void RS485_ReciveNew(uint8_t _byte)
000000  4770              BX       lr
;;;480    {
;;;481    //	MODBUS_ReciveNew(_byte);
;;;482    }
;;;483    
                          ENDP


                          AREA ||i.RS485_SendBefor||, CODE, READONLY, ALIGN=2

                  RS485_SendBefor PROC
;;;421    */
;;;422    void RS485_SendBefor(void)
000000  2004              MOVS     r0,#4
;;;423    {
;;;424    	RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
000002  4901              LDR      r1,|L6.8|
000004  6008              STR      r0,[r1,#0]
;;;425    }
000006  4770              BX       lr
;;;426    
                          ENDP

                  |L6.8|
                          DCD      0x40010c10

                          AREA ||i.RS485_SendBuf||, CODE, READONLY, ALIGN=1

                  RS485_SendBuf PROC
;;;449    */
;;;450    void RS485_SendBuf(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;451    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;452    	comSendBuf(COM3, _ucaBuf, _usLen);
000006  462a              MOV      r2,r5
000008  4621              MOV      r1,r4
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       comSendBuf
;;;453    }
000010  bd70              POP      {r4-r6,pc}
;;;454    
                          ENDP


                          AREA ||i.RS485_SendOver||, CODE, READONLY, ALIGN=2

                  RS485_SendOver PROC
;;;435    */
;;;436    void RS485_SendOver(void)
000000  2004              MOVS     r0,#4
;;;437    {
;;;438    	RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
000002  4901              LDR      r1,|L8.8|
000004  6008              STR      r0,[r1,#0]
;;;439    }
000006  4770              BX       lr
;;;440    
                          ENDP

                  |L8.8|
                          DCD      0x40010c14

                          AREA ||i.RS485_SendStr||, CODE, READONLY, ALIGN=1

                  RS485_SendStr PROC
;;;464    */
;;;465    void RS485_SendStr(char *_pBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;466    {
000002  4604              MOV      r4,r0
;;;467    	RS485_SendBuf((uint8_t *)_pBuf, strlen(_pBuf));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       strlen
00000a  b285              UXTH     r5,r0
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RS485_SendBuf
;;;468    }
000014  bd70              POP      {r4-r6,pc}
;;;469    
                          ENDP


                          AREA ||i.UART4_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART4_IRQHandler PROC
;;;1151   #if UART4_FIFO_EN == 1
;;;1152   void UART4_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1153   {
;;;1154   	UartIRQ(&g_tUart4);
000002  4802              LDR      r0,|L10.12|
000004  f7fffffe          BL       UartIRQ
;;;1155   }
000008  bd10              POP      {r4,pc}
;;;1156   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      g_tUart4

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;1119   #if UART1_FIFO_EN == 1
;;;1120   void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1121   {
;;;1122   	UartIRQ(&g_tUart1);
000002  4802              LDR      r0,|L11.12|
000004  f7fffffe          BL       UartIRQ
;;;1123   }
000008  bd10              POP      {r4,pc}
;;;1124   
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      g_tUart1

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;1137   #if UART2_FIFO_EN == 1
;;;1138   void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1139   {
;;;1140   	UartIRQ(&g_tUart2);
000002  4802              LDR      r0,|L12.12|
000004  f7fffffe          BL       UartIRQ
;;;1141   }
000008  bd10              POP      {r4,pc}
;;;1142   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      g_tUart2

                          AREA ||i.UartGetChar||, CODE, READONLY, ALIGN=1

                  UartGetChar PROC
;;;987    */
;;;988    static uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;989    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;990    	uint16_t usCount;
;;;991    
;;;992    	/* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;993    	DISABLE_INT();
000006  f7fffffe          BL       vPortEnterCritical
;;;994    	usCount = _pUart->usRxCount;
00000a  8b66              LDRH     r6,[r4,#0x1a]
;;;995    	ENABLE_INT();
00000c  f7fffffe          BL       vPortExitCritical
;;;996    
;;;997    	/* 如果读和写索引相同，则返回0 */
;;;998    	//if (_pUart->usRxRead == usRxWrite)
;;;999    	if (usCount == 0)	/* 已经没有数据 */
000010  b90e              CBNZ     r6,|L13.22|
;;;1000   	{
;;;1001   		return 0;
000012  2000              MOVS     r0,#0
                  |L13.20|
;;;1002   	}
;;;1003   	else
;;;1004   	{
;;;1005   		*_pByte = _pUart->pRxBuf[_pUart->usRxRead];		/* 从串口接收FIFO取1个数据 */
;;;1006   
;;;1007   		/* 改写FIFO读索引 */
;;;1008   		DISABLE_INT();
;;;1009   		if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;1010   		{
;;;1011   			_pUart->usRxRead = 0;
;;;1012   		}
;;;1013   		_pUart->usRxCount--;
;;;1014   		ENABLE_INT();
;;;1015   		return 1;
;;;1016   	}
;;;1017   }
000014  bd70              POP      {r4-r6,pc}
                  |L13.22|
000016  8b21              LDRH     r1,[r4,#0x18]         ;1005
000018  68a0              LDR      r0,[r4,#8]            ;1005
00001a  5c40              LDRB     r0,[r0,r1]            ;1005
00001c  7028              STRB     r0,[r5,#0]            ;1005
00001e  f7fffffe          BL       vPortEnterCritical
000022  8b20              LDRH     r0,[r4,#0x18]         ;1009
000024  1c40              ADDS     r0,r0,#1              ;1009
000026  b280              UXTH     r0,r0                 ;1009
000028  8320              STRH     r0,[r4,#0x18]         ;1009
00002a  89e1              LDRH     r1,[r4,#0xe]          ;1009
00002c  4288              CMP      r0,r1                 ;1009
00002e  db01              BLT      |L13.52|
000030  2000              MOVS     r0,#0                 ;1011
000032  8320              STRH     r0,[r4,#0x18]         ;1011
                  |L13.52|
000034  8b60              LDRH     r0,[r4,#0x1a]         ;1013
000036  1e40              SUBS     r0,r0,#1              ;1013
000038  8360              STRH     r0,[r4,#0x1a]         ;1013
00003a  f7fffffe          BL       vPortExitCritical
00003e  2001              MOVS     r0,#1                 ;1015
000040  e7e8              B        |L13.20|
;;;1018   
                          ENDP


                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;1026   */
;;;1027   static void UartIRQ(UART_T *_pUart)
000000  b570              PUSH     {r4-r6,lr}
;;;1028   {
000002  4604              MOV      r4,r0
;;;1029   	/* 处理接收中断  */
;;;1030   	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b1e0              CBZ      r0,|L14.74|
;;;1031   	{
;;;1032   		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;1033   		uint8_t ch;
;;;1034   
;;;1035   		ch = USART_ReceiveData(_pUart->uart);
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c5              UXTB     r5,r0
;;;1036   		_pUart->pRxBuf[_pUart->usRxWrite] = ch;
000018  8ae1              LDRH     r1,[r4,#0x16]
00001a  68a0              LDR      r0,[r4,#8]
00001c  5445              STRB     r5,[r0,r1]
;;;1037   		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
00001e  8ae0              LDRH     r0,[r4,#0x16]
000020  1c40              ADDS     r0,r0,#1
000022  b280              UXTH     r0,r0
000024  82e0              STRH     r0,[r4,#0x16]
000026  89e1              LDRH     r1,[r4,#0xe]
000028  4288              CMP      r0,r1
00002a  db01              BLT      |L14.48|
;;;1038   		{
;;;1039   			_pUart->usRxWrite = 0;
00002c  2000              MOVS     r0,#0
00002e  82e0              STRH     r0,[r4,#0x16]
                  |L14.48|
;;;1040   		}
;;;1041   		if (_pUart->usRxCount < _pUart->usRxBufSize)
000030  8b60              LDRH     r0,[r4,#0x1a]
000032  89e1              LDRH     r1,[r4,#0xe]
000034  4288              CMP      r0,r1
000036  da02              BGE      |L14.62|
;;;1042   		{
;;;1043   			_pUart->usRxCount++;
000038  8b60              LDRH     r0,[r4,#0x1a]
00003a  1c40              ADDS     r0,r0,#1
00003c  8360              STRH     r0,[r4,#0x1a]
                  |L14.62|
;;;1044   		}
;;;1045   
;;;1046   		/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;1047   		//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;1048   		//if (_pUart->usRxCount == 1)
;;;1049   		{
;;;1050   			if (_pUart->ReciveNew)
00003e  6a60              LDR      r0,[r4,#0x24]
000040  b110              CBZ      r0,|L14.72|
;;;1051   			{
;;;1052   				_pUart->ReciveNew(ch);
000042  4628              MOV      r0,r5
000044  6a61              LDR      r1,[r4,#0x24]
000046  4788              BLX      r1
                  |L14.72|
;;;1053   			}
;;;1054   		}
;;;1055   	}
000048  bf00              NOP      
                  |L14.74|
;;;1056   
;;;1057   	/* 处理发送缓冲区空中断 */
;;;1058   	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
00004a  f2407127          MOV      r1,#0x727
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       USART_GetITStatus
000054  b308              CBZ      r0,|L14.154|
;;;1059   	{
;;;1060   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1061   		if (_pUart->usTxCount == 0)
000056  8aa0              LDRH     r0,[r4,#0x14]
000058  b960              CBNZ     r0,|L14.116|
;;;1062   		{
;;;1063   			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;1064   			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
00005a  2200              MOVS     r2,#0
00005c  f2407127          MOV      r1,#0x727
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       USART_ITConfig
;;;1065   
;;;1066   			/* 使能数据发送完毕中断 */
;;;1067   			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
000066  2201              MOVS     r2,#1
000068  f2406126          MOV      r1,#0x626
00006c  6820              LDR      r0,[r4,#0]
00006e  f7fffffe          BL       USART_ITConfig
000072  e037              B        |L14.228|
                  |L14.116|
;;;1068   		}
;;;1069   		else
;;;1070   		{
;;;1071   			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;1072   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000074  8a63              LDRH     r3,[r4,#0x12]
000076  6862              LDR      r2,[r4,#4]
000078  5cd1              LDRB     r1,[r2,r3]
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       USART_SendData
;;;1073   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
000080  8a60              LDRH     r0,[r4,#0x12]
000082  1c40              ADDS     r0,r0,#1
000084  b280              UXTH     r0,r0
000086  8260              STRH     r0,[r4,#0x12]
000088  89a1              LDRH     r1,[r4,#0xc]
00008a  4288              CMP      r0,r1
00008c  db01              BLT      |L14.146|
;;;1074   			{
;;;1075   				_pUart->usTxRead = 0;
00008e  2000              MOVS     r0,#0
000090  8260              STRH     r0,[r4,#0x12]
                  |L14.146|
;;;1076   			}
;;;1077   			_pUart->usTxCount--;
000092  8aa0              LDRH     r0,[r4,#0x14]
000094  1e40              SUBS     r0,r0,#1
000096  82a0              STRH     r0,[r4,#0x14]
000098  e024              B        |L14.228|
                  |L14.154|
;;;1078   		}
;;;1079   
;;;1080   	}
;;;1081   	/* 数据bit位全部发送完毕的中断 */
;;;1082   	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
00009a  f2406126          MOV      r1,#0x626
00009e  6820              LDR      r0,[r4,#0]
0000a0  f7fffffe          BL       USART_GetITStatus
0000a4  b1f0              CBZ      r0,|L14.228|
;;;1083   	{
;;;1084   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1085   		if (_pUart->usTxCount == 0)
0000a6  8aa0              LDRH     r0,[r4,#0x14]
0000a8  b950              CBNZ     r0,|L14.192|
;;;1086   		{
;;;1087   			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;1088   			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
0000aa  2200              MOVS     r2,#0
0000ac  f2406126          MOV      r1,#0x626
0000b0  6820              LDR      r0,[r4,#0]
0000b2  f7fffffe          BL       USART_ITConfig
;;;1089   
;;;1090   			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;1091   			if (_pUart->SendOver)
0000b6  6a20              LDR      r0,[r4,#0x20]
0000b8  b1a0              CBZ      r0,|L14.228|
;;;1092   			{
;;;1093   				_pUart->SendOver();
0000ba  6a20              LDR      r0,[r4,#0x20]
0000bc  4780              BLX      r0
0000be  e011              B        |L14.228|
                  |L14.192|
;;;1094   			}
;;;1095   		}
;;;1096   		else
;;;1097   		{
;;;1098   			/* 正常情况下，不会进入此分支 */
;;;1099   
;;;1100   			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;1101   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
0000c0  8a63              LDRH     r3,[r4,#0x12]
0000c2  6862              LDR      r2,[r4,#4]
0000c4  5cd1              LDRB     r1,[r2,r3]
0000c6  6820              LDR      r0,[r4,#0]
0000c8  f7fffffe          BL       USART_SendData
;;;1102   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
0000cc  8a60              LDRH     r0,[r4,#0x12]
0000ce  1c40              ADDS     r0,r0,#1
0000d0  b280              UXTH     r0,r0
0000d2  8260              STRH     r0,[r4,#0x12]
0000d4  89a1              LDRH     r1,[r4,#0xc]
0000d6  4288              CMP      r0,r1
0000d8  db01              BLT      |L14.222|
;;;1103   			{
;;;1104   				_pUart->usTxRead = 0;
0000da  2000              MOVS     r0,#0
0000dc  8260              STRH     r0,[r4,#0x12]
                  |L14.222|
;;;1105   			}
;;;1106   			_pUart->usTxCount--;
0000de  8aa0              LDRH     r0,[r4,#0x14]
0000e0  1e40              SUBS     r0,r0,#1
0000e2  82a0              STRH     r0,[r4,#0x14]
                  |L14.228|
;;;1107   		}
;;;1108   	}
;;;1109   }
0000e4  bd70              POP      {r4-r6,pc}
;;;1110   
                          ENDP


                          AREA ||i.UartSend||, CODE, READONLY, ALIGN=1

                  UartSend PROC
;;;915    */
;;;916    static void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, uint16_t _usLen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;917    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;918    	uint16_t i;
;;;919    
;;;920    	for (i = 0; i < _usLen; i++)
000008  2500              MOVS     r5,#0
00000a  e025              B        |L15.88|
                  |L15.12|
;;;921    	{
;;;922    		/* 如果发送缓冲区已经满了，则等待缓冲区空 */
;;;923    	#if 0
;;;924    		/*
;;;925    			在调试GPRS例程时，下面的代码出现死机，while 死循环
;;;926    			原因： 发送第1个字节时 _pUart->usTxWrite = 1；_pUart->usTxRead = 0;
;;;927    			将导致while(1) 无法退出
;;;928    		*/
;;;929    		while (1)
;;;930    		{
;;;931    			uint16_t usRead;
;;;932    
;;;933    			DISABLE_INT();
;;;934    			usRead = _pUart->usTxRead;
;;;935    			ENABLE_INT();
;;;936    
;;;937    			if (++usRead >= _pUart->usTxBufSize)
;;;938    			{
;;;939    				usRead = 0;
;;;940    			}
;;;941    
;;;942    			if (usRead != _pUart->usTxWrite)
;;;943    			{
;;;944    				break;
;;;945    			}
;;;946    		}
;;;947    	#else
;;;948    		/* 当 _pUart->usTxBufSize == 1 时, 下面的函数会死掉(待完善) */
;;;949    		while (1)
00000c  e00c              B        |L15.40|
                  |L15.14|
;;;950    		{
;;;951    			__IO uint16_t usCount;
;;;952    
;;;953    			DISABLE_INT();
00000e  f7fffffe          BL       vPortEnterCritical
;;;954    			usCount = _pUart->usTxCount;
000012  8aa0              LDRH     r0,[r4,#0x14]
000014  9000              STR      r0,[sp,#0]
;;;955    			ENABLE_INT();
000016  f7fffffe          BL       vPortExitCritical
;;;956    
;;;957    			if (usCount < _pUart->usTxBufSize)
00001a  89a0              LDRH     r0,[r4,#0xc]
00001c  f8bd1000          LDRH     r1,[sp,#0]
000020  4288              CMP      r0,r1
000022  dd00              BLE      |L15.38|
;;;958    			{
;;;959    				break;
000024  e001              B        |L15.42|
                  |L15.38|
;;;960    			}
;;;961    		}
000026  bf00              NOP      
                  |L15.40|
000028  e7f1              B        |L15.14|
                  |L15.42|
00002a  bf00              NOP                            ;959
;;;962    	#endif
;;;963    
;;;964    		/* 将新数据填入发送缓冲区 */
;;;965    		_pUart->pTxBuf[_pUart->usTxWrite] = _ucaBuf[i];
00002c  5d70              LDRB     r0,[r6,r5]
00002e  8a22              LDRH     r2,[r4,#0x10]
000030  6861              LDR      r1,[r4,#4]
000032  5488              STRB     r0,[r1,r2]
;;;966    
;;;967    		DISABLE_INT();
000034  f7fffffe          BL       vPortEnterCritical
;;;968    		if (++_pUart->usTxWrite >= _pUart->usTxBufSize)
000038  8a20              LDRH     r0,[r4,#0x10]
00003a  1c40              ADDS     r0,r0,#1
00003c  b280              UXTH     r0,r0
00003e  8220              STRH     r0,[r4,#0x10]
000040  89a1              LDRH     r1,[r4,#0xc]
000042  4288              CMP      r0,r1
000044  db01              BLT      |L15.74|
;;;969    		{
;;;970    			_pUart->usTxWrite = 0;
000046  2000              MOVS     r0,#0
000048  8220              STRH     r0,[r4,#0x10]
                  |L15.74|
;;;971    		}
;;;972    		_pUart->usTxCount++;
00004a  8aa0              LDRH     r0,[r4,#0x14]
00004c  1c40              ADDS     r0,r0,#1
00004e  82a0              STRH     r0,[r4,#0x14]
;;;973    		ENABLE_INT();
000050  f7fffffe          BL       vPortExitCritical
000054  1c68              ADDS     r0,r5,#1              ;920
000056  b285              UXTH     r5,r0                 ;920
                  |L15.88|
000058  42bd              CMP      r5,r7                 ;920
00005a  dbd7              BLT      |L15.12|
;;;974    	}
;;;975    
;;;976    	USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
00005c  2201              MOVS     r2,#1
00005e  f2407127          MOV      r1,#0x727
000062  6820              LDR      r0,[r4,#0]
000064  f7fffffe          BL       USART_ITConfig
;;;977    }
000068  bdf8              POP      {r3-r7,pc}
;;;978    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;491    */
;;;492    static void UartVarInit(void)
000000  481f              LDR      r0,|L16.128|
;;;493    {
;;;494    #if UART1_FIFO_EN == 1
;;;495    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  4920              LDR      r1,|L16.132|
000004  6008              STR      r0,[r1,#0]  ; g_tUart1
;;;496    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
000006  4820              LDR      r0,|L16.136|
000008  6048              STR      r0,[r1,#4]  ; g_tUart1
;;;497    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
00000a  4820              LDR      r0,|L16.140|
00000c  6088              STR      r0,[r1,#8]  ; g_tUart1
;;;498    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00000e  f44f7080          MOV      r0,#0x100
000012  8188              STRH     r0,[r1,#0xc]
;;;499    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000014  81c8              STRH     r0,[r1,#0xe]
;;;500    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
000016  2000              MOVS     r0,#0
000018  8208              STRH     r0,[r1,#0x10]
;;;501    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001a  8248              STRH     r0,[r1,#0x12]
;;;502    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
00001c  82c8              STRH     r0,[r1,#0x16]
;;;503    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
00001e  8308              STRH     r0,[r1,#0x18]
;;;504    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000020  8348              STRH     r0,[r1,#0x1a]
;;;505    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000022  8288              STRH     r0,[r1,#0x14]
;;;506    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
000024  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;507    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000026  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;508    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000028  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;509    #endif
;;;510    
;;;511    #if UART2_FIFO_EN == 1
;;;512    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
00002a  4819              LDR      r0,|L16.144|
00002c  4919              LDR      r1,|L16.148|
00002e  6008              STR      r0,[r1,#0]  ; g_tUart2
;;;513    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
000030  4819              LDR      r0,|L16.152|
000032  6048              STR      r0,[r1,#4]  ; g_tUart2
;;;514    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
000034  4819              LDR      r0,|L16.156|
000036  6088              STR      r0,[r1,#8]  ; g_tUart2
;;;515    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000038  f44f7080          MOV      r0,#0x100
00003c  8188              STRH     r0,[r1,#0xc]
;;;516    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
00003e  81c8              STRH     r0,[r1,#0xe]
;;;517    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
000040  2000              MOVS     r0,#0
000042  8208              STRH     r0,[r1,#0x10]
;;;518    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
000044  8248              STRH     r0,[r1,#0x12]
;;;519    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
000046  82c8              STRH     r0,[r1,#0x16]
;;;520    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
000048  8308              STRH     r0,[r1,#0x18]
;;;521    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
00004a  8348              STRH     r0,[r1,#0x1a]
;;;522    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */
00004c  8288              STRH     r0,[r1,#0x14]
;;;523    	g_tUart2.SendBefor = 0;						/* 发送数据前的回调函数 */
00004e  61c8              STR      r0,[r1,#0x1c]  ; g_tUart2
;;;524    	g_tUart2.SendOver = 0;						/* 发送完毕后的回调函数 */
000050  6208              STR      r0,[r1,#0x20]  ; g_tUart2
;;;525    	g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000052  6248              STR      r0,[r1,#0x24]  ; g_tUart2
;;;526    #endif
;;;527    
;;;528    #if UART3_FIFO_EN == 1
;;;529    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
;;;530    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
;;;531    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
;;;532    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;533    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;534    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;535    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
;;;536    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;537    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
;;;538    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
;;;539    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
;;;540    	g_tUart3.SendBefor = RS485_SendBefor;		/* 发送数据前的回调函数 */
;;;541    	g_tUart3.SendOver = RS485_SendOver;			/* 发送完毕后的回调函数 */
;;;542    	g_tUart3.ReciveNew = RS485_ReciveNew;		/* 接收到新数据后的回调函数 */
;;;543    #endif
;;;544    
;;;545    #if UART4_FIFO_EN == 1
;;;546    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
000054  4812              LDR      r0,|L16.160|
000056  4913              LDR      r1,|L16.164|
000058  6008              STR      r0,[r1,#0]  ; g_tUart4
;;;547    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
00005a  4813              LDR      r0,|L16.168|
00005c  6048              STR      r0,[r1,#4]  ; g_tUart4
;;;548    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
00005e  4813              LDR      r0,|L16.172|
000060  6088              STR      r0,[r1,#8]  ; g_tUart4
;;;549    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000062  f44f6080          MOV      r0,#0x400
000066  8188              STRH     r0,[r1,#0xc]
;;;550    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000068  81c8              STRH     r0,[r1,#0xe]
;;;551    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
00006a  2000              MOVS     r0,#0
00006c  8208              STRH     r0,[r1,#0x10]
;;;552    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
00006e  8248              STRH     r0,[r1,#0x12]
;;;553    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
000070  82c8              STRH     r0,[r1,#0x16]
;;;554    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
000072  8308              STRH     r0,[r1,#0x18]
;;;555    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
000074  8348              STRH     r0,[r1,#0x1a]
;;;556    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
000076  8288              STRH     r0,[r1,#0x14]
;;;557    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
000078  61c8              STR      r0,[r1,#0x1c]  ; g_tUart4
;;;558    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
00007a  6208              STR      r0,[r1,#0x20]  ; g_tUart4
;;;559    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
00007c  6248              STR      r0,[r1,#0x24]  ; g_tUart4
;;;560    #endif
;;;561    
;;;562    #if UART5_FIFO_EN == 1
;;;563    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
;;;564    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
;;;565    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
;;;566    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;567    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;568    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;569    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
;;;570    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;571    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
;;;572    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
;;;573    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */
;;;574    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;575    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;576    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;577    #endif
;;;578    
;;;579    
;;;580    #if UART6_FIFO_EN == 1
;;;581    	g_tUart6.uart = USART6;						/* STM32 串口设备 */
;;;582    	g_tUart6.pTxBuf = g_TxBuf6;					/* 发送缓冲区指针 */
;;;583    	g_tUart6.pRxBuf = g_RxBuf6;					/* 接收缓冲区指针 */
;;;584    	g_tUart6.usTxBufSize = UART6_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;585    	g_tUart6.usRxBufSize = UART6_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;586    	g_tUart6.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;587    	g_tUart6.usTxRead = 0;						/* 发送FIFO读索引 */
;;;588    	g_tUart6.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;589    	g_tUart6.usRxRead = 0;						/* 接收FIFO读索引 */
;;;590    	g_tUart6.usRxCount = 0;						/* 接收到的新数据个数 */
;;;591    	g_tUart6.usTxCount = 0;						/* 待发送的数据个数 */
;;;592    	g_tUart6.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;593    	g_tUart6.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;594    	g_tUart6.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;595    #endif
;;;596    }
00007e  4770              BX       lr
;;;597    
                          ENDP

                  |L16.128|
                          DCD      0x40013800
                  |L16.132|
                          DCD      g_tUart1
                  |L16.136|
                          DCD      g_TxBuf1
                  |L16.140|
                          DCD      g_RxBuf1
                  |L16.144|
                          DCD      0x40004400
                  |L16.148|
                          DCD      g_tUart2
                  |L16.152|
                          DCD      g_TxBuf2
                  |L16.156|
                          DCD      g_RxBuf2
                  |L16.160|
                          DCD      0x40004c00
                  |L16.164|
                          DCD      g_tUart4
                  |L16.168|
                          DCD      g_TxBuf4
                  |L16.172|
                          DCD      g_RxBuf4

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;74     */
;;;75     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;76     {
;;;77     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;78     
;;;79     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;80     
;;;81     	RS485_InitTXE();	/* 配置RS485芯片的发送使能硬件，配置为推挽输出 */
00000a  f7fffffe          BL       RS485_InitTXE
;;;82     
;;;83     	ConfigUartNVIC();	/* 配置串口中断 */
00000e  f7fffffe          BL       ConfigUartNVIC
;;;84     }
000012  bd10              POP      {r4,pc}
;;;85     
                          ENDP


                          AREA ||i.bsp_Set485Baud||, CODE, READONLY, ALIGN=2

                  bsp_Set485Baud PROC
;;;398    */
;;;399    void bsp_Set485Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;400    {
000002  4604              MOV      r4,r0
;;;401    	USART_InitTypeDef USART_InitStructure;
;;;402    
;;;403    	/* 第2步： 配置串口硬件参数 */
;;;404    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;405    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;406    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;407    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;408    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;409    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;410    	USART_Init(USART3, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L18.40|
000022  f7fffffe          BL       USART_Init
;;;411    }
000026  bd1f              POP      {r0-r4,pc}
;;;412    
                          ENDP

                  |L18.40|
                          DCD      0x40004800

                          AREA ||i.bsp_SetUart1Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart1Baud PROC
;;;331    */
;;;332    void bsp_SetUart1Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;333    {
000002  4604              MOV      r4,r0
;;;334    	USART_InitTypeDef USART_InitStructure;
;;;335    
;;;336    	/* 第2步： 配置串口硬件参数 */
;;;337    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;338    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;339    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;340    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;341    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;342    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;343    	USART_Init(USART2, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L19.40|
000022  f7fffffe          BL       USART_Init
;;;344    }
000026  bd1f              POP      {r0-r4,pc}
;;;345    
                          ENDP

                  |L19.40|
                          DCD      0x40004400

                          AREA ||i.bsp_SetUart2Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart2Baud PROC
;;;353    */
;;;354    void bsp_SetUart2Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;355    {
000002  4604              MOV      r4,r0
;;;356    	USART_InitTypeDef USART_InitStructure;
;;;357    
;;;358    	/* 第2步： 配置串口硬件参数 */
;;;359    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;360    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;361    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;362    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;363    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;364    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;365    	USART_Init(USART2, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L20.40|
000022  f7fffffe          BL       USART_Init
;;;366    }
000026  bd1f              POP      {r0-r4,pc}
;;;367    
                          ENDP

                  |L20.40|
                          DCD      0x40004400

                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;308    */
;;;309    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;310    {
000002  4603              MOV      r3,r0
;;;311    	UART_T *pUart;
;;;312    
;;;313    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;314    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L21.16|
                  |L21.14|
;;;315    	{
;;;316    		return;
;;;317    	}
;;;318    
;;;319    	pUart->usRxWrite = 0;
;;;320    	pUart->usRxRead = 0;
;;;321    	pUart->usRxCount = 0;
;;;322    }
00000e  bd00              POP      {pc}
                  |L21.16|
000010  2000              MOVS     r0,#0                 ;319
000012  82d0              STRH     r0,[r2,#0x16]         ;319
000014  8310              STRH     r0,[r2,#0x18]         ;320
000016  8350              STRH     r0,[r2,#0x1a]         ;321
000018  bf00              NOP      
00001a  e7f8              B        |L21.14|
;;;323    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;285    */
;;;286    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;287    {
000002  4603              MOV      r3,r0
;;;288    	UART_T *pUart;
;;;289    
;;;290    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;291    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L22.16|
                  |L22.14|
;;;292    	{
;;;293    		return;
;;;294    	}
;;;295    
;;;296    	pUart->usTxWrite = 0;
;;;297    	pUart->usTxRead = 0;
;;;298    	pUart->usTxCount = 0;
;;;299    }
00000e  bd00              POP      {pc}
                  |L22.16|
000010  2000              MOVS     r0,#0                 ;296
000012  8210              STRH     r0,[r2,#0x10]         ;296
000014  8250              STRH     r0,[r2,#0x12]         ;297
000016  8290              STRH     r0,[r2,#0x14]         ;298
000018  bf00              NOP      
00001a  e7f8              B        |L22.14|
;;;300    
                          ENDP


                          AREA ||i.comGetALine||, CODE, READONLY, ALIGN=1

                  comGetALine PROC
;;;226    
;;;227    uint16_t comGetALine(COM_PORT_E _ucPort, uint8_t *TEM)
000000  b5f8              PUSH     {r3-r7,lr}
;;;228    {
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
;;;229        uint16_t i;
;;;230        uint8_t temC;//, TEM[200];
;;;231        uint16_t timeout;
;;;232        
;;;233        i = 0;
000006  2400              MOVS     r4,#0
;;;234        temC = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;235    	timeout = 0;
00000c  2600              MOVS     r6,#0
;;;236    	
;;;237    	if( comGetLen(_ucPort)>2 )
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       comGetLen
000014  2802              CMP      r0,#2
000016  dd29              BLE      |L23.108|
;;;238        {
;;;239            while( timeout<2000)//( comGetLen(_ucPort) )
000018  e023              B        |L23.98|
                  |L23.26|
;;;240            {
;;;241                if( comGetChar(_ucPort, &temC) )
00001a  4669              MOV      r1,sp
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       comGetChar
000022  b1c8              CBZ      r0,|L23.88|
;;;242            	{
;;;243            	    TEM[i++] = temC;
000024  f89d2000          LDRB     r2,[sp,#0]
000028  4620              MOV      r0,r4
00002a  1c61              ADDS     r1,r4,#1
00002c  b28c              UXTH     r4,r1
00002e  542a              STRB     r2,[r5,r0]
;;;244            	    
;;;245            	    if(temC==0x0A)
000030  f89d0000          LDRB     r0,[sp,#0]
000034  280a              CMP      r0,#0xa
000036  d114              BNE      |L23.98|
;;;246                    {
;;;247                        if( TEM[i-2] == 0x0D )//检测到AT指令
000038  1ea0              SUBS     r0,r4,#2
00003a  5c28              LDRB     r0,[r5,r0]
00003c  280d              CMP      r0,#0xd
00003e  d110              BNE      |L23.98|
;;;248                        {
;;;249                            if( i >1 )
000040  2c01              CMP      r4,#1
000042  dd07              BLE      |L23.84|
;;;250                            {
;;;251                                //TEM[i-1] = '\0';//把0x0D,0x0A转换为字符串结束符
;;;252                                //TEM[i-2] = '\0';//
;;;253                                TEM[i++] = '\0';
000044  2200              MOVS     r2,#0
000046  4620              MOV      r0,r4
000048  1c61              ADDS     r1,r4,#1
00004a  b28c              UXTH     r4,r1
00004c  542a              STRB     r2,[r5,r0]
;;;254                                //strncpy((char*)line, (char*)TEM, i);
;;;255                                return i-1;//return i-3;//实际长度没有算0x0D，0x0A, 0x00
00004e  1e60              SUBS     r0,r4,#1
000050  b280              UXTH     r0,r0
                  |L23.82|
;;;256                            }else
;;;257                            {
;;;258                                return 0;
;;;259                            }
;;;260                        }
;;;261                    }
;;;262            	}
;;;263            	else
;;;264        	    {
;;;265        	        vTaskDelay(1);
;;;266        	        timeout++;
;;;267        	        
;;;268        	       //vTaskDelay(pdMS_TO_TICKS(1000));//delay
;;;269        	    }
;;;270            }
;;;271            
;;;272            return 0;
;;;273        }
;;;274    	
;;;275    	return 0;
;;;276    }
000052  bdf8              POP      {r3-r7,pc}
                  |L23.84|
000054  2000              MOVS     r0,#0                 ;258
000056  e7fc              B        |L23.82|
                  |L23.88|
000058  2001              MOVS     r0,#1                 ;265
00005a  f7fffffe          BL       vTaskDelay
00005e  1c70              ADDS     r0,r6,#1              ;266
000060  b286              UXTH     r6,r0                 ;266
                  |L23.98|
000062  f5b66ffa          CMP      r6,#0x7d0             ;239
000066  dbd8              BLT      |L23.26|
000068  2000              MOVS     r0,#0                 ;272
00006a  e7f2              B        |L23.82|
                  |L23.108|
00006c  2000              MOVS     r0,#0                 ;275
00006e  e7f0              B        |L23.82|
;;;277    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;203    */
;;;204    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;205    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;206    	UART_T *pUart;
;;;207    
;;;208    	pUart = ComToUart(_ucPort);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       ComToUart
00000c  4604              MOV      r4,r0
;;;209    	if (pUart == 0)
00000e  b90c              CBNZ     r4,|L24.20|
;;;210    	{
;;;211    		return 0;
000010  2000              MOVS     r0,#0
                  |L24.18|
;;;212    	}
;;;213    
;;;214    	return UartGetChar(pUart, _pByte);
;;;215    }
000012  bd70              POP      {r4-r6,pc}
                  |L24.20|
000014  4631              MOV      r1,r6                 ;214
000016  4620              MOV      r0,r4                 ;214
000018  f7fffffe          BL       UartGetChar
00001c  e7f9              B        |L24.18|
;;;216    
                          ENDP


                          AREA ||i.comGetLen||, CODE, READONLY, ALIGN=1

                  comGetLen PROC
;;;216    
;;;217    uint16_t comGetLen(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;218    {
000002  4602              MOV      r2,r0
;;;219    	UART_T *pUart;
;;;220    
;;;221    	pUart = ComToUart(_ucPort);
000004  4610              MOV      r0,r2
000006  f7fffffe          BL       ComToUart
00000a  4603              MOV      r3,r0
;;;222    	
;;;223    	return pUart->usRxCount;
00000c  8b58              LDRH     r0,[r3,#0x1a]
;;;224    }
00000e  bd00              POP      {pc}
;;;225    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;152    */
;;;153    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;154    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;155    	UART_T *pUart;
;;;156    
;;;157    	pUart = ComToUart(_ucPort);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ComToUart
000010  4604              MOV      r4,r0
;;;158    	if (pUart == 0)
000012  b90c              CBNZ     r4,|L26.24|
                  |L26.20|
;;;159    	{
;;;160    		return;
;;;161    	}
;;;162    
;;;163    	if (pUart->SendBefor != 0)
;;;164    	{
;;;165    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
;;;166    	}
;;;167    
;;;168    	UartSend(pUart, _ucaBuf, _usLen);
;;;169    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L26.24|
000018  69e0              LDR      r0,[r4,#0x1c]         ;163
00001a  b108              CBZ      r0,|L26.32|
00001c  69e0              LDR      r0,[r4,#0x1c]         ;165
00001e  4780              BLX      r0                    ;165
                  |L26.32|
000020  463a              MOV      r2,r7                 ;168
000022  4631              MOV      r1,r6                 ;168
000024  4620              MOV      r0,r4                 ;168
000026  f7fffffe          BL       UartSend
00002a  bf00              NOP      
00002c  e7f2              B        |L26.20|
;;;170    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;179    */
;;;180    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;181    {
000002  4604              MOV      r4,r0
;;;182    	comSendBuf(_ucPort, &_ucByte, 1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       comSendBuf
;;;183    }
00000e  bd1c              POP      {r2-r4,pc}
;;;184    
                          ENDP


                          AREA ||i.comSendCharHex||, CODE, READONLY, ALIGN=2

                  comSendCharHex PROC
;;;188    
;;;189    void comSendCharHex(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;190    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;191        comSendBuf(_ucPort, &HexToCharArray[ ( _ucByte&0xF0 )>>4 ], 1);
000006  4808              LDR      r0,|L28.40|
000008  eb001114          ADD      r1,r0,r4,LSR #4
00000c  2201              MOVS     r2,#1
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       comSendBuf
;;;192    	comSendBuf(_ucPort, &HexToCharArray[ _ucByte&0x0F ], 1);
000014  f004000f          AND      r0,r4,#0xf
000018  4a03              LDR      r2,|L28.40|
00001a  1881              ADDS     r1,r0,r2
00001c  2201              MOVS     r2,#1
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       comSendBuf
;;;193    }
000024  bd70              POP      {r4-r6,pc}
;;;194    
                          ENDP

000026  0000              DCW      0x0000
                  |L28.40|
                          DCD      HexToCharArray

                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;1205   */
;;;1206   int fgetc(FILE *f)
000000  b510              PUSH     {r4,lr}
;;;1207   {
000002  4604              MOV      r4,r0
;;;1208   
;;;1209   #if 0	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;1210   	uint8_t ucData;
;;;1211   
;;;1212   	while(comGetChar(COM1, &ucData) == 0);
;;;1213   
;;;1214   	return ucData;
;;;1215   #else
;;;1216   	/* 等待串口1输入数据 */
;;;1217   	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
000004  bf00              NOP      
                  |L29.6|
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L29.28|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L29.6|
;;;1218   
;;;1219   	return (int)USART_ReceiveData(USART1);
000012  4802              LDR      r0,|L29.28|
000014  f7fffffe          BL       USART_ReceiveData
;;;1220   #endif
;;;1221   }
000018  bd10              POP      {r4,pc}
;;;1222   
                          ENDP

00001a  0000              DCW      0x0000
                  |L29.28|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;1179   */
;;;1180   int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;1181   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1182   #if 0	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;1183   	comSendChar(COM1, ch);
;;;1184   
;;;1185   	return ch;
;;;1186   #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;1187   	/* 写一个字节到USART1 */
;;;1188   	USART_SendData(USART1, (uint8_t) ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L30.32|
00000a  f7fffffe          BL       USART_SendData
;;;1189   
;;;1190   	/* 等待发送结束 */
;;;1191   	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
00000e  bf00              NOP      
                  |L30.16|
000010  2140              MOVS     r1,#0x40
000012  4803              LDR      r0,|L30.32|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L30.16|
;;;1192   	{}
;;;1193   
;;;1194   	return ch;
00001c  4620              MOV      r0,r4
;;;1195   #endif
;;;1196   }
00001e  bd70              POP      {r4-r6,pc}
;;;1197   
                          ENDP

                  |L30.32|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  BLE_TxBuf
                          %        100
                  BLE_RxBuf
                          %        100
                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        256
                  g_RxBuf1
                          %        256
                  g_tUart2
                          %        40
                  g_TxBuf2
                          %        256
                  g_RxBuf2
                          %        256
                  g_tUart4
                          %        40
                  g_TxBuf4
                          %        1024
                  g_RxBuf4
                          %        1024

                          AREA ||.data||, DATA, ALIGN=0

                  HexToCharArray
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38394142          DCB      0x38,0x39,0x41,0x42
00000c  43444546          DCB      0x43,0x44,0x45,0x46
000010  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_b28b0d00____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH|
#line 128
|__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
