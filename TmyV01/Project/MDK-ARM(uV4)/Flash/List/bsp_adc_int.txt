; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_adc_int.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_adc_int.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\..\User\app -I..\..\User\lcd\inc -I..\..\User\hx711 -ID:\MyDoc\MyPrj\MyGitPrj\TmyV01\Project\MDK-ARM(uV4)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -D__MICROLIB -D__UVISION_VERSION=514 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_adc_int.crf ..\..\User\bsp\src\bsp_adc_int.c]
                          THUMB

                          AREA ||i.ADC1_2_IRQHandler||, CODE, READONLY, ALIGN=2

                  ADC1_2_IRQHandler PROC
;;;180     
;;;181    void ADC1_2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;182    {	
;;;183        uint16_t adc_v;
;;;184        
;;;185    	if (ADC_GetITStatus(ADC1,ADC_IT_EOC)==SET) 
000002  f44f7108          MOV      r1,#0x220
000006  4809              LDR      r0,|L1.44|
000008  f7fffffe          BL       ADC_GetITStatus
00000c  2801              CMP      r0,#1
00000e  d106              BNE      |L1.30|
;;;186    	{
;;;187    		// 读取ADC的转换值
;;;188    		adc_v = ADC_GetConversionValue(ADC1);
000010  4806              LDR      r0,|L1.44|
000012  f7fffffe          BL       ADC_GetConversionValue
000016  4604              MOV      r4,r0
;;;189    		FILTER_Push( adc_v );//ADC1_Value = FILTER_Push( adc_v );
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       FILTER_Push
                  |L1.30|
;;;190    	}
;;;191    	ADC_ClearITPendingBit(ADC1,ADC_IT_EOC);
00001e  f44f7108          MOV      r1,#0x220
000022  4802              LDR      r0,|L1.44|
000024  f7fffffe          BL       ADC_ClearITPendingBit
;;;192    }
000028  bd10              POP      {r4,pc}
;;;193     
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      0x40012400

                          AREA ||i.ADC1_GPIO_Config||, CODE, READONLY, ALIGN=2

                  ADC1_GPIO_Config PROC
;;;75     
;;;76     static void ADC1_GPIO_Config(void)
000000  b508              PUSH     {r3,lr}
;;;77     {
;;;78     	GPIO_InitTypeDef GPIO_InitStructure;
;;;79     	/* 使能 ADC1 and GPIOC clock */
;;;80     	RCC_AHBPeriphClockCmd( RCC_APB2Periph_GPIOA, ENABLE);
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;81         
;;;82     	/* 配置PA6为模拟输入(ADC Channel14) */
;;;83     	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_ADC_DAT;
00000a  2001              MOVS     r0,#1
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;84     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000010  2000              MOVS     r0,#0
000012  f88d0003          STRB     r0,[sp,#3]
;;;85     	GPIO_Init(GPIO_PORT_AD_DAT, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  4801              LDR      r0,|L2.32|
00001a  f7fffffe          BL       GPIO_Init
;;;86     }
00001e  bd08              POP      {r3,pc}
;;;87      
                          ENDP

                  |L2.32|
                          DCD      0x40011000

                          AREA ||i.ADC1_GetV||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  ADC1_GetV PROC
;;;202    
;;;203    void ADC1_GetV(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;204    {
000004  b087              SUB      sp,sp,#0x1c
;;;205        uint8_t err;
;;;206        uint16_t AdcValue = 0;
000006  2000              MOVS     r0,#0
000008  9004              STR      r0,[sp,#0x10]
;;;207        
;;;208    	float voltage;
;;;209    	
;;;210        err = FILTER_Get( &AdcValue );
00000a  a804              ADD      r0,sp,#0x10
00000c  f7fffffe          BL       FILTER_Get
000010  9005              STR      r0,[sp,#0x14]
;;;211        if( AdcValue == 0 ) //无效值
000012  f8bd0010          LDRH     r0,[sp,#0x10]
000016  b910              CBNZ     r0,|L3.30|
                  |L3.24|
;;;212        {
;;;213            return;
;;;214        }else
;;;215        if( err<FILTER_N )
;;;216        {
;;;217            ;//未达到采样总数FILTER_N，输出的是即时数据
;;;218        }
;;;219        //printf("FILTER_Get%d %ld\r\n", err, AdcValue );
;;;220        
;;;221        voltage = ((float)AdcValue / 4096)*3.3*(ADC_R1+ADC_R2)/ADC_R2;
;;;222    
;;;223        
;;;224    	Tmy.power_v = (uint16_t)( voltage*1000 );
;;;225    	
;;;226        //printf("voltage:%f power_v:%d\r\n", voltage, Tmy.power_v );
;;;227        
;;;228    	if( Tmy.power_v > MAX_POWER )
;;;229    	{
;;;230    		Tmy.power_v = MAX_POWER;
;;;231    	}
;;;232    	else if( Tmy.power_v <= MIN_POWER )
;;;233    	{
;;;234    		Tmy.power_v = MIN_POWER;
;;;235    	}
;;;236        
;;;237    	Tmy.power_percent = (uint8_t)( (Tmy.power_v - MIN_POWER) * 100 / (MAX_POWER - MIN_POWER) );
;;;238    	if( Tmy.power_percent < 20 )
;;;239    	{
;;;240    		//Tmy.alarm.bit.power = 1;
;;;241    	}else
;;;242    	{
;;;243    	    //Tmy.alarm.bit.power = 0;
;;;244    	}
;;;245    	printf("power_v:%d power_percent:%d\r\n", Tmy.power_v, Tmy.power_percent );
;;;246    }
000018  b007              ADD      sp,sp,#0x1c
00001a  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.30|
00001e  bf00              NOP                            ;215
000020  f8bd0010          LDRH     r0,[sp,#0x10]         ;221
000024  f7fffffe          BL       __aeabi_ui2f
000028  f04f418b          MOV      r1,#0x45800000        ;221
00002c  9001              STR      r0,[sp,#4]            ;221
00002e  f7fffffe          BL       __aeabi_fdiv
000032  4683              MOV      r11,r0                ;221
000034  f7fffffe          BL       __aeabi_f2d
000038  f04f3266          MOV      r2,#0x66666666        ;221
00003c  4b21              LDR      r3,|L3.196|
00003e  e9cd0102          STRD     r0,r1,[sp,#8]         ;221
000042  f7fffffe          BL       __aeabi_dmul
000046  4606              MOV      r6,r0                 ;221
000048  2200              MOVS     r2,#0                 ;221
00004a  4b1f              LDR      r3,|L3.200|
00004c  f7fffffe          BL       __aeabi_dmul
000050  4604              MOV      r4,r0                 ;221
000052  2200              MOVS     r2,#0                 ;221
000054  4b1d              LDR      r3,|L3.204|
000056  f7fffffe          BL       __aeabi_ddiv
00005a  4680              MOV      r8,r0                 ;221
00005c  f7fffffe          BL       __aeabi_d2f
000060  4682              MOV      r10,r0                ;221
000062  491b              LDR      r1,|L3.208|
000064  4650              MOV      r0,r10                ;224
000066  f7fffffe          BL       __aeabi_fmul
00006a  4604              MOV      r4,r0                 ;224
00006c  f7fffffe          BL       __aeabi_f2uiz
000070  4918              LDR      r1,|L3.212|
000072  8148              STRH     r0,[r1,#0xa]          ;224
000074  4608              MOV      r0,r1                 ;228
000076  8940              LDRH     r0,[r0,#0xa]          ;228  ; Tmy
000078  f2462170          MOV      r1,#0x6270            ;228
00007c  4288              CMP      r0,r1                 ;228
00007e  dd03              BLE      |L3.136|
000080  4608              MOV      r0,r1                 ;230
000082  4914              LDR      r1,|L3.212|
000084  8148              STRH     r0,[r1,#0xa]          ;230
000086  e008              B        |L3.154|
                  |L3.136|
000088  4812              LDR      r0,|L3.212|
00008a  8940              LDRH     r0,[r0,#0xa]          ;232  ; Tmy
00008c  f2440174          MOV      r1,#0x4074            ;232
000090  4288              CMP      r0,r1                 ;232
000092  dc02              BGT      |L3.154|
000094  4608              MOV      r0,r1                 ;234
000096  490f              LDR      r1,|L3.212|
000098  8148              STRH     r0,[r1,#0xa]          ;234
                  |L3.154|
00009a  480e              LDR      r0,|L3.212|
00009c  8940              LDRH     r0,[r0,#0xa]          ;237  ; Tmy
00009e  f5a04080          SUB      r0,r0,#0x4000         ;237
0000a2  3874              SUBS     r0,r0,#0x74           ;237
0000a4  2164              MOVS     r1,#0x64              ;237
0000a6  4348              MULS     r0,r1,r0              ;237
0000a8  f24211fc          MOV      r1,#0x21fc            ;237
0000ac  fb90f0f1          SDIV     r0,r0,r1              ;237
0000b0  4908              LDR      r1,|L3.212|
0000b2  7208              STRB     r0,[r1,#8]            ;237
0000b4  4608              MOV      r0,r1                 ;245
0000b6  7a02              LDRB     r2,[r0,#8]            ;245  ; Tmy
0000b8  8941              LDRH     r1,[r0,#0xa]          ;245  ; Tmy
0000ba  a007              ADR      r0,|L3.216|
0000bc  f7fffffe          BL       __2printf
0000c0  bf00              NOP      
0000c2  e7a9              B        |L3.24|
;;;247    
                          ENDP

                  |L3.196|
                          DCD      0x400a6666
                  |L3.200|
                          DCD      0x40554000
                  |L3.204|
                          DCD      0x40240000
                  |L3.208|
                          DCD      0x447a0000
                  |L3.212|
                          DCD      Tmy
                  |L3.216|
0000d8  706f7765          DCB      "power_v:%d power_percent:%d\r\n",0
0000dc  725f763a
0000e0  25642070
0000e4  6f776572
0000e8  5f706572
0000ec  63656e74
0000f0  3a25640d
0000f4  0a00    
0000f6  00                DCB      0
0000f7  00                DCB      0

                          AREA ||i.ADC1_InSigEn||, CODE, READONLY, ALIGN=2

                  ADC1_InSigEn PROC
;;;43     */
;;;44     void ADC1_InSigEn( uint8_t onoff )
000000  b918              CBNZ     r0,|L4.10|
;;;45     {
;;;46         
;;;47         if (onoff == ADC_OFF)
;;;48     	{
;;;49     		GPIO_PORT_ADC_EN->BRR = GPIO_PIN_ADC_EN;
000002  2102              MOVS     r1,#2
000004  4a03              LDR      r2,|L4.20|
000006  6151              STR      r1,[r2,#0x14]
000008  e002              B        |L4.16|
                  |L4.10|
;;;50     	}else
;;;51     	{
;;;52     		GPIO_PORT_ADC_EN->BSRR = GPIO_PIN_ADC_EN;
00000a  2102              MOVS     r1,#2
00000c  4a01              LDR      r2,|L4.20|
00000e  6111              STR      r1,[r2,#0x10]
                  |L4.16|
;;;53     	}
;;;54     }
000010  4770              BX       lr
;;;55     
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40011000

                          AREA ||i.ADC1_InSigEnInit||, CODE, READONLY, ALIGN=2

                  ADC1_InSigEnInit PROC
;;;56     
;;;57     void ADC1_InSigEnInit(void)
000000  b508              PUSH     {r3,lr}
;;;58     {
;;;59     	GPIO_InitTypeDef GPIO_InitStructure;
;;;60     
;;;61     	/* 打开GPIO时钟 */
;;;62     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
000002  2101              MOVS     r1,#1
000004  0248              LSLS     r0,r1,#9
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;63     	RCC_AHBPeriphClockCmd( RCC_APB2Periph_GPIOA, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2004              MOVS     r0,#4
00000e  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;64     	
;;;65     	ADC1_InSigEn(ADC_OFF);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       ADC1_InSigEn
;;;66     
;;;67     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;68     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	//推挽输出模式
00001e  2010              MOVS     r0,#0x10
000020  f88d0003          STRB     r0,[sp,#3]
;;;69     	
;;;70     	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_ADC_EN;
000024  2002              MOVS     r0,#2
000026  f8ad0000          STRH     r0,[sp,#0]
;;;71     	GPIO_Init(GPIO_PORT_ADC_EN, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4803              LDR      r0,|L5.60|
00002e  f7fffffe          BL       GPIO_Init
;;;72         
;;;73     	ADC1_InSigEn( ADC_ON );
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       ADC1_InSigEn
;;;74     }
000038  bd08              POP      {r3,pc}
;;;75     
                          ENDP

00003a  0000              DCW      0x0000
                  |L5.60|
                          DCD      0x40011000

                          AREA ||i.ADC1_Init||, CODE, READONLY, ALIGN=1

                  ADC1_Init PROC
;;;193     
;;;194    void ADC1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;195    {
;;;196        ADC1_InSigEnInit();
000002  f7fffffe          BL       ADC1_InSigEnInit
;;;197    	ADC1_GPIO_Config();
000006  f7fffffe          BL       ADC1_GPIO_Config
;;;198    	ADC1_Mode_Config();
00000a  f7fffffe          BL       ADC1_Mode_Config
;;;199    	ADC_NVIC_Config();
00000e  f7fffffe          BL       ADC_NVIC_Config
;;;200    	FILTER_Clear( );
000012  f7fffffe          BL       FILTER_Clear
;;;201    }
000016  bd10              POP      {r4,pc}
;;;202    
                          ENDP


                          AREA ||i.ADC1_Mode_Config||, CODE, READONLY, ALIGN=2

                  ADC1_Mode_Config PROC
;;;90      
;;;91     static void ADC1_Mode_Config(void)
000000  b500              PUSH     {lr}
;;;92     {
000002  b085              SUB      sp,sp,#0x14
;;;93         ADC_InitTypeDef ADC_InitStructure;
;;;94     	
;;;95     	/* 使能 ADC1 and GPIOC clock */
;;;96         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
000004  2101              MOVS     r1,#1
000006  0248              LSLS     r0,r1,#9
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;97     
;;;98         /* 配置ADC1, 不用DMA, 用软件触发 */
;;;99     	//ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
;;;100    	
;;;101    	//单次转换，定时器T3触发
;;;102    	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; //ADC 独立模式
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;103    	ADC_InitStructure.ADC_ScanConvMode = DISABLE; //单通道模式
000010  f88d0004          STRB     r0,[sp,#4]
;;;104        ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; //单次转换模式
000014  f88d0005          STRB     r0,[sp,#5]
;;;105        ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T3_TRGO;//外部触发设置为TIM3
000018  f44f2000          MOV      r0,#0x80000
00001c  9002              STR      r0,[sp,#8]
;;;106        ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//ADC 数据右对齐
00001e  2000              MOVS     r0,#0
000020  9003              STR      r0,[sp,#0xc]
;;;107        
;;;108    	ADC_InitStructure.ADC_NbrOfChannel = 1;//顺序进行规则转换的ADC 通道的数目
000022  2001              MOVS     r0,#1
000024  f88d0010          STRB     r0,[sp,#0x10]
;;;109    	ADC_Init(ADC1, &ADC_InitStructure);
000028  4669              MOV      r1,sp
00002a  4817              LDR      r0,|L7.136|
00002c  f7fffffe          BL       ADC_Init
;;;110    
;;;111    	
;;;112    	
;;;113    //	//连续转换模式
;;;114    //	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
;;;115    //	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
;;;116    	
;;;117    	
;;;118    //    //单次转换，定时器T3触发
;;;119    //	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;            //禁用连续转换模式  ENABLE;
;;;120    //	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T3_TRGO; //外部触发设置为TIM3
;;;121    //	
;;;122    //	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
;;;123    //	//ADC_InitStructure.ADC_ScanDirection = ADC_ScanDirection_Backward;
;;;124    //	ADC_Init(ADC1, &ADC_InitStructure);
;;;125        
;;;126        
;;;127    	//RCC_ADCCLKConfig(RCC_ADCCLK_PCLK_Div4);
;;;128    	
;;;129        /* 配置ADC1 规则通道14 channel9 configuration */
;;;130    	//ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1, ADC_SampleTime_55Cycles5);//ADC_ChannelConfig(ADC1, ADC_Channel_1, ADC_SampleTime_55_5Cycles); //ADC_SampleTime_239_5Cycles
;;;131        ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_55Cycles5);
000030  2305              MOVS     r3,#5
000032  2201              MOVS     r2,#1
000034  210a              MOVS     r1,#0xa
000036  4814              LDR      r0,|L7.136|
000038  f7fffffe          BL       ADC_RegularChannelConfig
;;;132    	/* 失能 ADC1 */
;;;133    	ADC_Cmd(ADC1, DISABLE);
00003c  2100              MOVS     r1,#0
00003e  4812              LDR      r0,|L7.136|
000040  f7fffffe          BL       ADC_Cmd
;;;134    	
;;;135    	/* ADC 校准 */
;;;136    	//ADC_GetCalibrationFactor(ADC1);
;;;137    	//while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_ADCAL));//?
;;;138    	
;;;139    	// ADC2 转换结束产生中断，在中断服务程序中读取转换值
;;;140        ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);//???
000044  2201              MOVS     r2,#1
000046  f44f7108          MOV      r1,#0x220
00004a  480f              LDR      r0,|L7.136|
00004c  f7fffffe          BL       ADC_ITConfig
;;;141        
;;;142    	/* 使能 ADC1 */
;;;143    	ADC_Cmd(ADC1, ENABLE);
000050  2101              MOVS     r1,#1
000052  480d              LDR      r0,|L7.136|
000054  f7fffffe          BL       ADC_Cmd
;;;144    	
;;;145    	/* 使能ADC1 复位校准寄存器 */
;;;146    	ADC_ResetCalibration(ADC1);
000058  480b              LDR      r0,|L7.136|
00005a  f7fffffe          BL       ADC_ResetCalibration
;;;147    	/* 检查ADC1的复位寄存器 */
;;;148    	while(ADC_GetResetCalibrationStatus(ADC1));
00005e  bf00              NOP      
                  |L7.96|
000060  4809              LDR      r0,|L7.136|
000062  f7fffffe          BL       ADC_GetResetCalibrationStatus
000066  2800              CMP      r0,#0
000068  d1fa              BNE      |L7.96|
;;;149    
;;;150    	/* 启动ADC1校准 */
;;;151    	ADC_StartCalibration(ADC1);
00006a  4807              LDR      r0,|L7.136|
00006c  f7fffffe          BL       ADC_StartCalibration
;;;152    	/* 检查校准是否结束 */
;;;153    	while(ADC_GetCalibrationStatus(ADC1));
000070  bf00              NOP      
                  |L7.114|
000072  4805              LDR      r0,|L7.136|
000074  f7fffffe          BL       ADC_GetCalibrationStatus
000078  2800              CMP      r0,#0
00007a  d1fa              BNE      |L7.114|
;;;154    
;;;155    	/* ADC1 常规软件启动转换 */
;;;156    	ADC_SoftwareStartConvCmd( ADC1, ENABLE );
00007c  2101              MOVS     r1,#1
00007e  4802              LDR      r0,|L7.136|
000080  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;157    }
000084  b005              ADD      sp,sp,#0x14
000086  bd00              POP      {pc}
;;;158     
                          ENDP

                  |L7.136|
                          DCD      0x40012400

                          AREA ||i.ADC_NVIC_Config||, CODE, READONLY, ALIGN=1

                  ADC_NVIC_Config PROC
;;;160     
;;;161    static void ADC_NVIC_Config(void)
000000  b508              PUSH     {r3,lr}
;;;162    {
;;;163        NVIC_InitTypeDef NVIC_InitStructure;
;;;164    	// 优先级分组
;;;165        //NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
;;;166     
;;;167        // 配置中断优先级
;;;168        NVIC_InitStructure.NVIC_IRQChannel = ADC1_2_IRQn;//ADC1_IRQn;
000002  2012              MOVS     r0,#0x12
000004  f88d0000          STRB     r0,[sp,#0]
;;;169        //NVIC_InitStructure.NVIC_IRQChannelPriority = 0x03;
;;;170        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
000008  2003              MOVS     r0,#3
00000a  f88d0001          STRB     r0,[sp,#1]
;;;171        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00000e  2000              MOVS     r0,#0
000010  f88d0002          STRB     r0,[sp,#2]
;;;172        
;;;173        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000014  2001              MOVS     r0,#1
000016  f88d0003          STRB     r0,[sp,#3]
;;;174        NVIC_Init(&NVIC_InitStructure);
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       NVIC_Init
;;;175      
;;;176    //    // ADC2 转换结束产生中断，在中断服务程序中读取转换值
;;;177    //    ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);
;;;178    
;;;179    }
000020  bd08              POP      {r3,pc}
;;;180     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  BLE_TxBuf
                          %        100
                  BLE_RxBuf
                          %        100

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_adc_int.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_adc_int_c_c62fa76d____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_adc_int_c_c62fa76d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_adc_int_c_c62fa76d____REVSH|
#line 128
|__asm___13_bsp_adc_int_c_c62fa76d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
